<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Docker-Swarm学习笔记</title>
      <link href="/2018/11/06/Docker-Swarm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/06/Docker-Swarm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="#Docker Swarm概述">Docker Swarm概述</a></li><li><a href="#swarm操作">swarm操作</a></li></ul><a id="more"></a><h1 id="Docker-Swarm概述"><a href="#Docker-Swarm概述" class="headerlink" title="Docker Swarm概述"></a>Docker Swarm概述</h1><p>Docker Swarm用于跨主机部署管理docker集群。从1.12版本开始就集成在docker engine中，并称为swarm mode。swarm已内置kv存储功能，不再需要外置的etcd，内置Overlay网络，服务发现，负载均衡。</p><p>当 Docker Engine 初始化了一个 swarm 或者加入到一个存在的 swarm 时，它就启动了 swarm mode。没启动 swarm mode 时，Docker 执行的是容器命令；运行 swarm mode 后，Docker 增加了编排 service 的能力。Docker 允许在同一个 Docker 主机上既运行 swarm service，又运行单独的容器。</p><p>Swarm特点</p><ul><li>Docker Engine集成了swarm</li><li>去中心化设计：Swarm角色分为Manager和Worker，Manager的故障不会影响应用使用</li><li>扩容缩容：可声明每个服务运行的容器数量，会自动添加或删除容器数，以调整到期望的状态</li><li>期望状态协调：Manager节点监控集群状态，自动调整当前状态与期望状态之间的差异。</li><li>多主机网络：可为服务指定Overlay网络，党初始化或更新应用程序时，Manager会自动为Overlay网络上的容器分配IP地址</li><li>服务发现：Manager为集群的每个服务分配唯一的DNS记录和负载均衡VIP，可通过Swarm内置的DNS服务器查询集群中每个运行的容器</li><li>安全传输：Swarm中每个节点使用TLS互相验证和加密，确保节点间安全通信</li><li>滚动更新：升级时，逐步将应用服务更新到节点，若出现问题，可以将任务回滚到先前版本</li></ul><p>Swarm术语</p><ul><li><p><strong>node</strong>：swarm中每个docker engine都是一个node，有两种类型：<strong>manager</strong>和<strong>worker</strong></p></li><li><p><strong>manager node</strong>负责执行编排和集群管理工作，保持并维护 swarm 处于期望的状态。manager node会将部署任务拆解并分配给一个或多个worker node完成部署。Manager节点默认也作为worker节点，不过可以将其配置成 manager-only node，让其专职负责编排和集群管理工作。</p><p>swarm 中如果有多个 manager node，它们会自动协商并选举出一个 leader 执行编排任务。</p></li><li><p><strong>worker node</strong> 接收并执行管理节点分配的任务，并会定期向 manager node 报告自己的状态和它正在执行的任务的状态</p></li><li><p><strong>service</strong>与<strong>task</strong>：定义了 worker node 上要执行的任务。swarm 的主要编排任务就是保证 service 处于期望的状态下。</p><p>任务Task是swarm中的最小原子调度单位。Services是一组task的集合，service定义了这些task的属性。</p></li></ul><p>swarm的工作流程：</p><ol><li>Client发送请求给Swarm </li><li>Swarm处理并发送给相应docker node  </li><li>docker node执行操作并返回结果</li></ol><p>services有两种模式：</p><ul><li><p>replicated services：按照一定规则在各个worker node上运行指定个数的tasks，和k8s的replicate、marathon中的instance概念一样。</p></li><li><p>global services：每个woker node上运行一个此task</p></li></ul><img src="/2018/11/06/Docker-Swarm学习笔记/0.png"><p>Swarm调度模块</p><ul><li><p><strong><code>filter</code></strong>：使用过滤器挑出符合条件的节点，并从中选出最优节点。有以下过滤器：</p><ul><li>Constraints：</li><li>Affinity：</li><li>Dependency：</li><li>Health filter：</li><li>Ports filter：</li></ul></li><li><p><strong><code>strategy</code></strong>：使用策略挑出最优节点。有以下策略：</p><ul><li>Binpack：</li><li>Spread：</li><li>Random：</li></ul></li></ul><p>服务发现：分为三种场景</p><ul><li>Ingress：</li><li>Ingress+Link：</li><li>自定义网络：</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>swarm manager使用<strong>入口负载均衡（Ingress load balance）</strong>来发布向集群外部提供的服务。swarm manager可以<strong>自动为已发布的端口（published port）分配服务</strong>，也可以为服务配置发布端口（Published Port）。可以指定任何未使用的端口，如果未指定端口，则swarm manager会为服务分配30000-32767范围内的端口。</p><p>外部组件（例如云负载平衡器）可以访问集群中任何节点的发布端口上的服务，无论该节点当前是否正在运行该服务的任务。集群中的所有节点都将入口连接到正在运行的任务实例。</p><p>Swarm模式有一个内部DNS组件，可以自动为swarm中的每个服务分配一个DNS条目。swarm manager使用内部负载均衡（Internal load balance）来根据服务的DNS名称在集群内的服务之间分发请求。</p><h1 id="swarm操作"><a href="#swarm操作" class="headerlink" title="swarm操作"></a>swarm操作</h1><p>实验环境：</p><ul><li>Manager：本机192.168.43.106</li><li>Worker：atom-1  172.16.246.138</li><li>Worker：atom-2  172.16.246.139</li></ul><h2 id="创建与查看服务"><a href="#创建与查看服务" class="headerlink" title="创建与查看服务"></a>创建与查看服务</h2><p>初始化一个swarm，<code>docker swarm init --advertise-addr IP地址</code>，指定发布的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker swarm init --advertise-addr 192.168.43.106</span><br><span class="line">Swarm initialized: current node (w4wogxb10dhxtcvh3ljx5ltqh) is now a manager.</span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line">    docker swarm join --token XXXXXX 192.168.43.106:2377</span><br></pre></td></tr></table></figure><p>在atom-1、atom-2上执行提示的<code>docker swarm join</code>命令。然后在Manager上执行<code>docker node ls</code>查看节点，集群已创建成功。</p><blockquote><p>如果<code>docker swarm join</code>的命令忘记了，则可以在Manager上执行<code>docker swarm join-token worker</code>查看</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker node ls</span><br><span class="line">ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">7r0pg83uetbwp1jc2ysgkitj5     atom-1              Ready               Active                                  1.13.1</span><br><span class="line">e3fnuzkgzjhxqg748us07pb48     atom-2              Ready               Active                                  1.13.1</span><br><span class="line">w4wogxb10dhxtcvh3ljx5ltqh *   gutianyi-PC         Ready               Active              Leader              18.06.1-ce</span><br></pre></td></tr></table></figure><p><code>docker node</code>命令。专门对swarm节点操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker node COMMAND</span><br><span class="line">  demote      降级一个或多个节点（从Manager降为Worker）</span><br><span class="line">  inspect     显示一个或多个节点的详细信息。输出为Json格式，或者添加--pretty会重新排版，便于查看</span><br><span class="line">  ls          显示所有节点</span><br><span class="line">  promote     提升一个或多个节点（从Worker升为Manager）</span><br><span class="line">  ps          列出在一个或多个节点上运行的任务（tasks），默认为当前节点</span><br><span class="line">  rm          从集群中删除指定节点（通过ID）</span><br><span class="line">  update      更新一个节点</span><br></pre></td></tr></table></figure><p><code>docker service</code>命令。管理docker 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker service COMMAND</span><br><span class="line">  create      创建一个服务</span><br><span class="line">  inspect     显示一个或多个服务的详细信息</span><br><span class="line">  logs        获取一个服务或任务的日志</span><br><span class="line">  ls          显示所有服务</span><br><span class="line">  ps          显示指定服务的任务</span><br><span class="line">  rm          删除一个或多个服务</span><br><span class="line">  rollback    回滚一个服务的配置</span><br><span class="line">  scale       扩展一个或多个复制的服务</span><br><span class="line">  update      更新一个服务</span><br></pre></td></tr></table></figure><p>在Manager上创建服务<code>docker service create --replicas 2 --name busybox busybox /bin/ping &quot;baidu.com&quot;</code>。其中<code>--replicas</code>表示期望状态的实例个数，由于busybox一定要参数任务，否则服务无法正常启动，所以在后面加上了ping的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">p519w5pjai5y        busybox             replicated          2/2                 busybox:latest      </span><br><span class="line"># MODE为replicated说明会根据调度算法动态调度节点</span><br></pre></td></tr></table></figure><p>若暂时未添加参数，未能成功启动：<code>docker service create --replicas 2 --name busybox_1 busybox</code>，也可以通过<code>docker service update</code>对服务添加参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service update busybox_1 --args &quot;/bin/ping baidu.com&quot;</span><br><span class="line">busybox_1</span><br><span class="line">overall progress: 2 out of 2 tasks </span><br><span class="line">1/2: running   </span><br><span class="line">2/2: running   </span><br><span class="line">verify: Service converged</span><br></pre></td></tr></table></figure><p>可以通过<code>docker service ps SERVICE</code>查看服务的任务，可以查看到该服务在哪个节点NODE上运行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service ps busybox</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR                              PORTS</span><br><span class="line">r9eogiyc0xkl        busybox.1           busybox:latest      gutianyi-PC         Running             Running 20 minutes ago                                          </span><br><span class="line">5z2rfa8xiuvq         \_ busybox.1       busybox:latest      gutianyi-PC         Shutdown            Failed 20 minutes ago        &quot;task: non-zero exit (1)&quot;          </span><br><span class="line">txz74rterci8         \_ busybox.1       busybox:latest      gutianyi-PC         Shutdown            Failed 21 minutes ago        &quot;task: non-zero exit (1)&quot;</span><br></pre></td></tr></table></figure><p>还可以通过<code>-f</code>指定满足条件的条目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service ps busybox -f &quot;desired-state=running&quot;  #只查看正在运行的任务</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE               ERROR               PORTS</span><br><span class="line">r9eogiyc0xkl        busybox.1           busybox:latest      gutianyi-PC         Running             Running 22 minutes ago                          </span><br><span class="line">axvqvs5wuvw4        busybox.2           busybox:latest      gutianyi-PC         Running             Running about an hour ago</span><br></pre></td></tr></table></figure><h2 id="扩缩容"><a href="#扩缩容" class="headerlink" title="扩缩容"></a>扩缩容</h2><p>可通过<code>docker service scale SERVICE=REPLICAS</code>进行扩容或缩容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service scale busybox=3        # 将busybox的replicas扩容到3台</span><br><span class="line">busybox scaled to 3</span><br><span class="line">overall progress: 3 out of 3 tasks </span><br><span class="line">1/3: running   [==================================================&gt;] </span><br><span class="line">2/3: running   [==================================================&gt;] </span><br><span class="line">3/3: running   [==================================================&gt;] </span><br><span class="line">verify: Service converged </span><br><span class="line"></span><br><span class="line">&gt; docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">p519w5pjai5y        busybox             replicated          3/3                 busybox:latest</span><br></pre></td></tr></table></figure><h2 id="更新与回滚"><a href="#更新与回滚" class="headerlink" title="更新与回滚"></a>更新与回滚</h2><p>创建web服务，设置定时更新策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">  --name web \</span><br><span class="line">  --replicas 3 \   </span><br><span class="line">  --update-delay 2s \         # 任务升级间的间隔</span><br><span class="line">  --update-parallelism 2 \    # 同时更新的最大任务数</span><br><span class="line">  nginx:1.12                  # 使用nginx:1.12镜像</span><br><span class="line"></span><br><span class="line">docker service ps web </span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR                              PORTS</span><br><span class="line">p1w8ee6fhrt8        web.1               nginx:1.12          gutianyi-PC         Running             Running 13 minutes ago                                     </span><br><span class="line">gv5jm09qsvq7        web.2               nginx:1.12          atom-2              Running             Running 13 hours ago                                        </span><br><span class="line">600wh1qru5f5        web.3               nginx:1.12          atom-1              Running             Running 13 hours ago</span><br></pre></td></tr></table></figure><p>然后执行<code>docker service update</code>命令升级镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service update --image nginx:1.13 web</span><br><span class="line"></span><br><span class="line"># 查看任务，确认镜像已全部升级到nginx:1.13</span><br><span class="line">docker service ps web -f &quot;desired-state=running&quot;</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">e8t755h66a32        web.1               nginx:1.13          atom-3              Running             Running 13 hours ago                             </span><br><span class="line">lkf51u3brkun        web.2               nginx:1.13          gutianyi-PC         Running             Running about a minute ago                       </span><br><span class="line">u240xfs3q023        web.3               nginx:1.13          atom-1              Running             Running 13 hours ago</span><br></pre></td></tr></table></figure><p>手动回滚镜像版本到nginx:1.12</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service update --rollback web</span><br><span class="line"></span><br><span class="line"># 已回滚完成，版本又变为nginx:1.12</span><br><span class="line">docker service ps web -f &quot;desired-state=running&quot;</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE          ERROR               PORTS</span><br><span class="line">yuj9ry8uipy4        web.1               nginx:1.12          atom-2              Running             Running 13 hours ago                       </span><br><span class="line">szfnmk3o7wgv        web.2               nginx:1.12          atom-3              Running             Running 13 hours ago                       </span><br><span class="line">jjsutat7tc65        web.3               nginx:1.12          atom-1              Running             Running 13 hours ago</span><br></pre></td></tr></table></figure><p><code>docker service update</code>与<strong>更新回滚</strong>相关的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">--rollback                   # 回滚到上一个版本</span><br><span class="line">--rollback-delay duration    # 回滚时间间隔，单位(ns|us|ms|s|m|h)</span><br><span class="line">--rollback-failure-action string     # 回滚失败执行的动作(&quot;pause&quot;|&quot;continue&quot;)</span><br><span class="line">--rollback-max-failure-ratio float   # 能够容忍的回滚错误率</span><br><span class="line">--rollback-monitor duration     # 每次任务回滚后等待的时间，以监视是否回滚失败 (ns|us|ms|s|m|h)</span><br><span class="line">--rollback-order string         # 回滚指令(&quot;start-first&quot;|&quot;stop-first&quot;)</span><br><span class="line">--rollback-parallelism uint     # 同时回滚的最大任务数，若为0则同时回滚所有任务</span><br><span class="line"></span><br><span class="line">--update-delay duration         #更新时间间隔(ns|us|ms|s|m|h)</span><br><span class="line">--update-failure-action string  #更新失败执行的动作(&quot;pause&quot;|&quot;continue&quot;|&quot;rollback&quot;)</span><br><span class="line">--update-max-failure-ratio float  # 能够容忍的更新失败率</span><br><span class="line">--update-monitor duration         # 每次更新后等待的时间，以监视是否更新失败(ns|us|ms|s|m|h)</span><br><span class="line">--update-order string             # 更新指令(&quot;start-first&quot;|&quot;stop-first&quot;)</span><br><span class="line">--update-parallelism uint         # 同时更新的最大任务数，若为0则同时更新所有任务</span><br></pre></td></tr></table></figure><h2 id="DRAIN可用性"><a href="#DRAIN可用性" class="headerlink" title="DRAIN可用性"></a>DRAIN可用性</h2><p>有时，例如计划的维护时间，需要将节点设置为<code>DRAIN</code>可用性。<code>DRAIN</code>可用性会<strong>阻止节点从swarm manager接收新任务</strong>。这也就意味着manager会停止在该节点上运行的任务，并在具有<code>ACTIVE</code>可用性的节点上启动副本任务。</p><blockquote><p>将节点设置为<code>DRAIN</code>不会从该节点中删除独立容器，例如使用docker run，docker-compose up或Docker Engine API创建的容器。节点的状态（包括<code>DRAIN</code>）仅影响节点调度swarm服务工作负载的能力。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 最初每个worker上都有一个任务</span><br><span class="line">&gt; docker service ps web -f &quot;desired-state=running&quot;</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">tffbqbf4v2ah        web.1               nginx:1.12          atom-1              Running             Running 17 hours ago                             </span><br><span class="line">n0bk8a7nva7m        web.2               nginx:1.12          atom-2              Running             Running 17 hours ago                             </span><br><span class="line">ugw21hq29jt3        web.3               nginx:1.12          atom-3              Running             Running 17 hours ago                             </span><br><span class="line">exvdophp0rc6        web.4               nginx:1.12          gutianyi-PC         Running             Running about a minute ago             </span><br><span class="line"></span><br><span class="line"># 将atom-1的可用性设为drain</span><br><span class="line">&gt; docker node update --availability drain atom-1</span><br><span class="line"></span><br><span class="line"># 查看atom-1，可看到可用性已变为drain</span><br><span class="line">&gt; docker node inspect atom-1 --pretty </span><br><span class="line">ID:845ol5bc51p68esmt14w1r7k8</span><br><span class="line">Hostname:              atom-1</span><br><span class="line">Joined at:             2018-11-06 12:33:43.750433367 +0000 utc</span><br><span class="line">Status:</span><br><span class="line"> State:Ready</span><br><span class="line"> Availability:         Drain</span><br><span class="line"> Address:192.168.43.106</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"># 查看服务，atom-1已不再接受任务，并且任务由另一个节点接替（此处为manager节点）</span><br><span class="line">&gt; docker service ps web -f &quot;desired-state=running&quot;</span><br><span class="line">ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">kid3lp31jvz0        web.1               nginx:1.12          gutianyi-PC         Running             Running about a minute ago                       </span><br><span class="line">n0bk8a7nva7m        web.2               nginx:1.12          atom-2              Running             Running 17 hours ago                             </span><br><span class="line">ugw21hq29jt3        web.3               nginx:1.12          atom-3              Running             Running 17 hours ago                             </span><br><span class="line">exvdophp0rc6        web.4               nginx:1.12          gutianyi-PC         Running             Running 5 minutes ago                        </span><br><span class="line"></span><br><span class="line"># 可再通过将可用性设回active使该节点重新开始接受任务</span><br></pre></td></tr></table></figure><h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><ul><li>volume</li><li>bind</li></ul><p>创建服务使用volume数据卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service create --name web-1 --mount src=test,dst=/data nginx:1.12</span><br><span class="line">&gt; docker inspect web-1 -f &quot;&#123;&#123;json .Spec.TaskTemplate.ContainerSpec.Mounts&#125;&#125;&quot;</span><br><span class="line">[&#123;&quot;Type&quot;:&quot;volume&quot;,&quot;Source&quot;:&quot;test&quot;,&quot;Target&quot;:&quot;/data&quot;&#125;]</span><br><span class="line"># src必须是volume的名字，不能是绝对路径</span><br><span class="line"># 还可指定type，默认不指定就是volume</span><br><span class="line"></span><br><span class="line">通过docker volume ls也可查看到test的volume</span><br><span class="line">&gt; docker exec -it web-1.1.uowomv72xjti9l5373erxskra /bin/bash</span><br><span class="line"># 在容器内部的data目录中创建一个文件</span><br><span class="line"># touch 1.txt</span><br><span class="line">在volume的目录中就能看到该文件</span><br><span class="line">&gt; ls /var/lib/docker/volumes/test/_data</span><br><span class="line">1.txt</span><br></pre></td></tr></table></figure><p>创建服务使用bind挂载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service create --mount type=bind,src=/home/gutianyi/test,dst=/data --name web1 nginx:1.12 </span><br><span class="line"># 使用bind的话，src必须是绝对路径</span><br><span class="line"></span><br><span class="line">&gt; docker inspect web1 -f &quot;&#123;&#123;json .Spec.TaskTemplate.ContainerSpec.Mounts&#125;&#125;&quot;</span><br><span class="line">[&#123;&quot;Type&quot;:&quot;bind&quot;,&quot;Source&quot;:&quot;/home/gutianyi/test&quot;,&quot;Target&quot;:&quot;/data&quot;&#125;]</span><br><span class="line"></span><br><span class="line"># 若要挂载只读权限，可以在--mount中添加readonly</span><br><span class="line">&gt; docker service create --mount type=bind,src=/home/gutianyi/test,dst=/data,readonly --name web1 nginx:1.12</span><br></pre></td></tr></table></figure><h2 id="路由网格（routing-mesh）"><a href="#路由网格（routing-mesh）" class="headerlink" title="路由网格（routing mesh）"></a>路由网格（routing mesh）</h2><p>Docker  Engine的swarm模式可以轻松发布服务端口，使其可用于群组外的资源。所有节点都参与入口路由网格（ingress routing mesh）。路由网格允许群集中的每个节点接受已发布端口上的连接，以便在群集中运行的任何服务，即使节点上没有任何任务正在运行。路由网格将所有请求路由到可用节点上的已发布端口的活动容器。</p><p>要在群集中使用入口网络，需要在启用swarm模式之前在集群节点之间打开以下端口：</p><ul><li>端口<strong><code>7946 TCP / UDP</code>用于容器网络发现</strong>。</li><li>端口<strong><code>4789 UDP</code>用于容器入口网络</strong>。</li></ul><p>并且还必须打开集群节点与需要访问端口的任何外部资源（如外部负载平衡器）之间的已发布端口。</p><p>使用<code>--publish</code>在创建服务时发布端口。 <code>target</code>用于指定容器内的端口，<code>published</code>用于指定要在路由网格上绑定的端口。如果不使用已发布的端口，则会为每个服务任务绑定一个随机端口（30000-32767）。默认发布的是TCP端口，若要设置协议可在<code>--publish</code>中添加<code>protocol=tcp|udp</code>指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service create --name web \</span><br><span class="line">  --replicas 5 \</span><br><span class="line">  --update-delay 5s \</span><br><span class="line">  --update-parallelism 2 \</span><br><span class="line">  --publish published=8080,target=80 \</span><br><span class="line">  nginx:1.12</span><br><span class="line">  </span><br><span class="line">&gt; docker service inspect web -f &quot;&#123;&#123;json .Endpoint.Ports&#125;&#125;&quot;</span><br><span class="line">[&#123;&quot;Protocol&quot;:&quot;tcp&quot;,&quot;TargetPort&quot;:80,&quot;PublishedPort&quot;:8080,&quot;PublishMode&quot;:&quot;ingress&quot;&#125;]</span><br></pre></td></tr></table></figure><p>该服务的每个容器都能作为一个负载均衡器，如下图（docker文档的图）</p><img src="/2018/11/06/Docker-Swarm学习笔记/1.png"><p><code>docker service update --published-add published=XX,target=XX SERVICE</code>能够添加发布的端口（不是替换）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service create --name web-1 --publish published=8081,target=80 nginx:1.12 </span><br><span class="line"></span><br><span class="line">&gt; docker service update --publish-add published=8082,target=80 web-1</span><br><span class="line"></span><br><span class="line">&gt; docker service inspect web-1 -f &quot;&#123;&#123;json .Endpoint.Ports&#125;&#125;&quot;</span><br><span class="line">[&#123;&quot;Protocol&quot;:&quot;tcp&quot;,&quot;TargetPort&quot;:80,&quot;PublishedPort&quot;:8081,&quot;PublishMode&quot;:&quot;ingress&quot;&#125;,&#123;&quot;Protocol&quot;:&quot;tcp&quot;,&quot;TargetPort&quot;:80,&quot;PublishedPort&quot;:8082,&quot;PublishMode&quot;:&quot;ingress&quot;&#125;]</span><br></pre></td></tr></table></figure><p>可以绕过路由网格，在访问给定节点上的绑定端口时，始终访问在该节点上运行的服务实例，这称为<strong>主机模式（host）</strong>。在<code>--publish</code>后加上<code>mode=host</code></p><h2 id="服务发现与负载均衡"><a href="#服务发现与负载均衡" class="headerlink" title="服务发现与负载均衡"></a>服务发现与负载均衡</h2><p>swarm模式内置DNS组件，可自动为集群中每个服务分配DNS记录，swarm manager使用内部负载均衡，根据服务的DNS名在集群内的服务间分发请求。swarm manager使用ingress load balancing暴露服务。ingress network是特殊的overlay网络，便于服务的节点直接负载均衡，当任何swarm节点在已发布的端口上接受请求时，会将请求转发到IPVS模块，IPVS追踪该服务的所有容器IP地址，选择其中一个并将请求路由给它。</p><p>需要创建overlay网络<code>docker network create -d overlay --subnet 192.1.1.0/24 --myoverlay</code></p><p><strong>注：</strong>若没有指定<code>--subnet</code>，一定要注意查看创建的网络的子网，有可能会创建子网为<code>10.0.0.0/16</code>的网络，这会与docker的默认子网冲突，导致后续的DNS解析出错，因此最好指定子网。</p><p>创建一个Nginx web集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service create --replicas 3 --network myoverlay --name web nginx:1.12</span><br><span class="line"></span><br><span class="line">&gt; docker inspect web -f &quot;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&quot;</span><br><span class="line">[&#123;&quot;NetworkID&quot;:&quot;ne9ejireolrulkw9072gstiaq&quot;,&quot;Addr&quot;:&quot;192.1.1.22/24&quot;&#125;]</span><br></pre></td></tr></table></figure><p>创建一个busybox服务，使用与web集群相同的网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker service create --network myoverlay --name busy busybox</span><br><span class="line">&gt; docker inspect busy -f &quot;&#123;&#123;json .Endpoint.VirtualIPs&#125;&#125;&quot;</span><br><span class="line">[&#123;&quot;NetworkID&quot;:&quot;ne9ejireolrulkw9072gstiaq&quot;,&quot;Addr&quot;:&quot;192.1.1.26/24&quot;&#125;]</span><br><span class="line"></span><br><span class="line"># 进入busy服务的容器</span><br><span class="line">&gt; docker exec -it busy.1.a8mzyt0vlb7ic68aehmlzrmik sh</span><br><span class="line"># 使用nslookup解析服务</span><br><span class="line"># nslookup web</span><br><span class="line">Server:127.0.0.11</span><br><span class="line">Address:127.0.0.11:53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:web</span><br><span class="line">Address: 192.1.1.22</span><br><span class="line"># 得到负载均衡器的IP</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 容器编排 </tag>
            
            <tag> docker swarm </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Memcached笔记</title>
      <link href="/2018/11/05/Memcached%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/05/Memcached%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> Memcached </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB基础笔记</title>
      <link href="/2018/10/29/MongoDB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/29/MongoDB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>基于MongoDB 4.0.3</p><ul><li><a href="#MongoDB概述">MongoDB概述</a></li><li><a href="#CRUD">CRUD</a></li><li><a href="#索引">索引</a></li><li><a href="#权限">权限</a></li></ul><a id="more"></a><h1 id="MongoDB概述"><a href="#MongoDB概述" class="headerlink" title="MongoDB概述"></a>MongoDB概述</h1><p>MongoDB是一个跨平台的基于分布式文件存储的面向文档的数据库，提供高性能，高可用性和易于扩展。由 C++ 语言编写，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB中的记录是一个文档，由键值对组成。 MongoDB文档类似于JSON对象。字段的值可以包括其他文档，数组和文档数组。</p><p>MongoDB特点：</p><ul><li><p>提供<strong>高性能</strong>数据持久性：对嵌入式数据模型的支持减少了数据库系统的I / O活动。索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</p></li><li><p>丰富的查询语言</p></li><li><p><strong>高可用性</strong>：MongoDB的复制工具称为副本集（replica set），它提供自动故障转移和数据冗余。</p><blockquote><p>副本集是一组MongoDB服务器，它们维护相同的数据集，提供冗余并提高数据可用性。</p></blockquote></li><li><p>水平扩展（Horizontal Scalability）：分片将数据分配到集群的不同机器上。支持基于分片键（shard key）创建数据区域（zones of data）</p></li><li><p>支持主从复制。主服务器可以执行读写操作，从服务器从主机复制数据，只能用于读取或备份</p></li><li><p>MongoDB能够实现负载均衡</p></li><li><p>支持多个存储引擎（WiredTiger、In-Memory、MMAPv1）</p></li><li><p>提供可插拔存储引擎API，允许第三方为MongoDB开发存储引擎</p></li><li><p>可以将不同结构的文档存储在同一个数据库中</p></li><li><p>可对任何属性创建索引</p></li><li><p>支持二进制数据和大型对象</p></li></ul><p>MongoDB结构：</p><ul><li>database：数据库</li><li>collection：集合，对应了SQL的table</li><li>document：文档，对应了SQL的row，即值</li><li>field：域，对应SQL的column字段</li><li>index：索引</li><li>primary key：主键，MongoDB自动将<strong><code>_id</code></strong>字段设置为主键</li></ul><p>安装MongoDB需要安装<code>mongodb-org</code>、<code>mongodb-org-mongos</code>、<code>mongodb-server</code>、<code>mongodb-org-shell</code>、<code>mongodb-org-tools</code></p><p>MongoDB默认端口27017，配置文件<code>/etc/mongod.conf</code>。</p><p>常见命令：</p><ul><li><code>db</code>：显示当前数据库名</li><li><code>show dbs</code>：显示所有数据库，默认有四个，<code>admin</code>、<code>config</code>、<code>local</code>、<code>test</code></li><li><code>use 数据库名</code>：切换数据库，若不存在就会自动创建</li><li><code>db.dropDatabase()</code>：删除数据库，删除前一定要切换到该数据库</li><li><code>show collections</code>：显示当前库中的所有集合</li><li><code>db.collection.drop()</code>：删除指定集合</li><li><code>show users</code>：显示当前数据库的所有用户</li></ul><p>MongoDB的数据类型：</p><ul><li>ObjectID：文档ID，12字节，十六进制数。由以下信息构成：<ul><li>前4个字节为创建时的时间戳</li><li>接下来3个字节为机器ID</li><li>接下来2个字节为MongoDB的服务进程ID</li><li>最后3个字节为简单的增量值</li><li>例：<code>5bd6b780  ba51d7  f829  d135e9</code></li></ul></li><li>String：字符串，必须是有效的UTF-8</li><li>Boolean：布尔值</li><li>Integer：整型</li><li>Double：浮点型</li><li>Arrays：数组或列表</li><li>Object：用于嵌入式文档，一个值就是一个文档</li><li>Null：Null值</li><li>Timestamp：时间戳</li><li>Date：当前日期或时间，unix格式</li></ul><h1 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h1><ul><li><code>db.createCollection(name, options)</code>：创建集合。options是一个文档，用于指定集合配置。</li><li><p><code>db.collection.insertOne()</code>：插入单个文档，若集合不存在，会自动创建</p></li><li><p><code>db.collection.insertMany()</code>：插入多个文档</p></li><li><code>db.collection.insert()</code>：既可以插入单个文档，也可插入多个文档</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">db.users.insertOne(</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;zhangsan&quot;,</span><br><span class="line">    age: 22,</span><br><span class="line">    hobby: [&quot;climbing&quot;, &quot;swimming&quot;, &quot;game&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.users.insertMany([</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;lisi&quot;,</span><br><span class="line">    age: 23,</span><br><span class="line">    hobby: [&quot;swimming&quot;, &quot;game&quot;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &quot;wangwu&quot;,</span><br><span class="line">    age: 25,</span><br><span class="line">    hobby: [&quot;tennis&quot;, &quot;swimming&quot;]</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name: &quot;zhaoliu&quot;,</span><br><span class="line">    age: 21,</span><br><span class="line">    hobby: [&quot;game&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>在MongoDB中，存储在集合中的每个文档都需要一个唯一的<code>_id</code>字段作为主键。如果插入的文档省略了<code>_id</code>字段，MongoDB驱动程序会自动为<code>_id</code>字段生成<code>ObjectId</code>。</p><p><strong>MongoDB中的所有写入操作都是单个文档级别的原子操作。</strong></p><ul><li><code>db.collection.find()</code>：从集合中检索文档</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">db.users.find( &#123;&#125; )                 # 显示所有记录</span><br><span class="line"></span><br><span class="line">&#123; &lt;field1&gt;: &lt;value1&gt;, ... &#125;  直接指定键值查询</span><br><span class="line">db.users.find(</span><br><span class="line">&#123; name: &quot;zhaoliu&quot; &#125;             # name为zhaoliu</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#123; &lt;field1&gt;: &#123; &lt;operator1&gt;: &lt;value1&gt; &#125;, ... &#125;  使用查询运算符指定条件</span><br><span class="line">db.users.find(</span><br><span class="line">&#123;</span><br><span class="line">age: &#123;$gt: 23&#125;,             # age大于23</span><br><span class="line">hobby: &quot;climbing&quot;           # 且hobby中有climbing</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">db.users.find(</span><br><span class="line">&#123;</span><br><span class="line">        $or: [                      # or关系</span><br><span class="line">        &#123; age: &#123;$gt: 23&#125; &#125;,     # 要么age大于23</span><br><span class="line">        &#123; hobby: &quot;climbing&quot; &#125;   # 要么hobby中有climbing</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">db.users.find(</span><br><span class="line">&#123;</span><br><span class="line">        age: &#123;$gt: 23&#125;,             # age大于23</span><br><span class="line">        $or: [                      # 下面的为或关系</span><br><span class="line">            &#123; hobby: &quot;climbing&quot; &#125;,  # 要么hobby中有climbing</span><br><span class="line">            &#123; hobby: &quot;game&quot; &#125;       # 要么hobby中有game</span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">相当于SQL：select * from users where age &gt; 23 and (hobby=&quot;climbing&quot; or hobby=&quot;game&quot;)</span><br><span class="line"></span><br><span class="line">db.users.find(</span><br><span class="line">&#123; age: &#123; $in: [23, 24] &#125; &#125;      # 查询age在[23, 24]中的文档</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.users.find(</span><br><span class="line">&#123; hobby: [ &quot;swimming&quot;, &quot;game&quot; ] &#125;    # hobby必须包含该列表（包括列表中顺序也要一致）</span><br><span class="line">)</span><br><span class="line">db.users.find(</span><br><span class="line">&#123; hobby: &#123; $all: [ &quot;game&quot;, &quot;swimming&quot; ] &#125;&#125;  # hobby必须包含该列表（顺序不用一致）</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">$elemMatch运算符匹配包含数组字段的文档，其中至少有一个元素匹配所有指定的查询条件。</span><br><span class="line">例：&#123; _id: 1, results: [ 82, 85, 88 ] &#125;,&#123; _id: 2, results: [ 75, 88, 89 ] &#125;</span><br><span class="line">db.scores.find(</span><br><span class="line">   &#123; results: &#123; $elemMatch: &#123; $gte: 80, $lt: 85 &#125; &#125; &#125;</span><br><span class="line">)</span><br><span class="line">返回结果为_id为1的文档</span><br><span class="line"></span><br><span class="line">若包含数组（列表），可通过指定列表的下标进行匹配</span><br><span class="line">db.users.find(</span><br><span class="line">&#123;</span><br><span class="line">&quot;hobby.1&quot;: &quot;climbing&quot;  # 查找hobby列表的下标为1的值为climbing的文档，一定要加引号</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">在匹配数组中的文档时，该字典的字段顺序必须完全一致</span><br><span class="line">匹配列表中的文章，只要有一项满足就会被匹配</span><br><span class="line">例：&#123;&quot;item&quot; : &quot;paper&quot;, &quot;instock&quot; : [ &#123; &quot;warehouse&quot; : &quot;A&quot;, &quot;qty&quot; : 60 &#125;, &#123; &quot;warehouse&quot; : &quot;B&quot;, &quot;qty&quot; : 15 &#125; ] &#125;</span><br><span class="line">则db.inventory.find( &#123; &apos;instock.qty&apos;: &#123; $lte: 20 &#125; &#125; )也能匹配到该条文档</span><br></pre></td></tr></table></figure><ul><li><code>db.collection.updateOne()</code>：更新单个文档</li><li><code>db.collection.updateMany()</code>：更新多个文档</li><li><code>db.collection.update()</code>：更新一个或多个文档</li><li><code>db.collection.replaceOne()</code>：替换除<code>_id</code>字段之外的文档的整个内容</li><li><code>db.collection.save()</code>：更新现有文档或插入新文档，用法与<code>update()</code>或<code>insert()</code>一致</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(</span><br><span class="line">&#123; name: &quot;zhangsan&quot; &#125;,               # 指定要改的满足条件的文档</span><br><span class="line">&#123; $set:                             # 指定$set进行修改</span><br><span class="line">&#123;</span><br><span class="line">        &quot;hobby.1&quot;: &quot;tennis&quot;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.users.replaceOne(</span><br><span class="line">&#123; name: &quot;zhangsan&quot; &#125;,</span><br><span class="line">&#123;</span><br><span class="line">        name: &quot;zhangsan&quot;,</span><br><span class="line">        age: 24,</span><br><span class="line">        hobby: [&quot;swimming&quot;, &quot;basketball&quot;, &quot;football&quot;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line">替换文档必须仅包含字段/值对，即不包括更新运算符表达式。</span><br><span class="line">_id字段始终是文档中的第一个字段。字段名称的更新（包括重命名）可能会导致文档中字段的重新排序。</span><br></pre></td></tr></table></figure><ul><li><code>db.collection.deleteOne()</code>：删除一个文档</li><li><code>db.collection.deleteMany()</code>：删除多个文档</li><li><code>db.collection.remove()</code>：删除单个文档或与指定过滤器匹配的所有文档。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.users.deleteOne(</span><br><span class="line">&#123;</span><br><span class="line">        name: &quot;zhangsan&quot;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>先创建200000条数据做测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(i = 0; i &lt; 200000;i++)&#123;</span><br><span class="line">db.test.insert(</span><br><span class="line">&#123; name: &quot;test&quot;+i &#125;</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询指定数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.test.find(</span><br><span class="line">&#123;</span><br><span class="line">name: &quot;test10000&quot;</span><br><span class="line">&#125;</span><br><span class="line">).explain(&apos;executionStats&apos;)</span><br><span class="line"># explain(&apos;executionStats&apos;)用于显示查询过程信息</span><br></pre></td></tr></table></figure><p>返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;executionStats&quot; : &#123;</span><br><span class="line">&quot;executionSuccess&quot; : true,</span><br><span class="line">&quot;nReturned&quot; : 1,</span><br><span class="line">&quot;executionTimeMillis&quot; : 93,        # 花费93毫秒</span><br><span class="line">&quot;totalKeysExamined&quot; : 0,</span><br><span class="line">&quot;totalDocsExamined&quot; : 210000,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>创建索引：<code>db.collection.ensureIndex()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.test.ensureIndex(&#123; name: 1 &#125;)</span><br><span class="line">对name创建索引，1表示升序，-1表示降序</span><br></pre></td></tr></table></figure><p>再次执行查询语句，得到以下结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;executionStats&quot; : &#123;</span><br><span class="line">&quot;executionSuccess&quot; : true,</span><br><span class="line">&quot;nReturned&quot; : 1,</span><br><span class="line">&quot;executionTimeMillis&quot; : 0,       # 创建索引后，基本不消耗时间</span><br><span class="line">&quot;totalKeysExamined&quot; : 1,</span><br><span class="line">&quot;totalDocsExamined&quot; : 1,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>唯一索引：<code>db.collection.ensureIndex({ name: 1 }, { unique: true })</code></p><p>联合索引：<code>db.collection.ensureIndex({ name: 1, XXX: 1 })</code>设置多个字段</p><p>查看当前集合的所有索引：<code>db.collection.getIndexes()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;v&quot; : 2,</span><br><span class="line">&quot;key&quot; : &#123;</span><br><span class="line">&quot;_id&quot; : 1         # _id为主键，也是默认的索引</span><br><span class="line">&#125;,</span><br><span class="line">&quot;name&quot; : &quot;_id_&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.test&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;v&quot; : 2,</span><br><span class="line">&quot;key&quot; : &#123;</span><br><span class="line">&quot;name&quot; : 1        # 添加的索引name</span><br><span class="line">&#125;,</span><br><span class="line">&quot;name&quot; : &quot;name_1&quot;,</span><br><span class="line">&quot;ns&quot; : &quot;test.test&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>删除指定索引：<code>db.collection.dropIndexes(&#39;索引名&#39;)</code></p><h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><p>MongoDB采用<strong>角色-用户-数据库</strong>的管理模式</p><p>常见的系统角色：</p><ul><li><strong>root</strong>：只能在admin数据库中可用，是超级用户，具有超级权限</li><li><strong>read</strong>：允许用户读取指定数据库</li><li><strong>readWrite</strong>：允许用户读写指定数据库</li></ul><p><strong>创建超级管理员</strong></p><p>先切换到admin数据库，然后创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">    user: &apos;admin&apos;,</span><br><span class="line">    pwd: &apos;123123&apos;,</span><br><span class="line">    roles: [&#123;</span><br><span class="line">      role: &apos;root&apos;,</span><br><span class="line">      db: &apos;admin&apos;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>然后修改MongoDB的配置文件<code>/etc/mongod.conf</code></p><p>找到<code>security</code>配置，删除注释，并添加内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br></pre></td></tr></table></figure><p>然后重启MongoDB，<code>systemctl restart mongod</code>，再重进mongo</p><p>执行<code>show dbs</code>，出现报错，说明授权起作用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[js] Error: listDatabases failed:&#123;</span><br><span class="line">&quot;ok&quot; : 0,</span><br><span class="line">&quot;errmsg&quot; : &quot;command listDatabases requires authentication&quot;,</span><br><span class="line">&quot;code&quot; : 13,</span><br><span class="line">&quot;codeName&quot; : &quot;Unauthorized&quot;</span><br><span class="line">&#125; :</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>需要指定用户名和密码以及参数<code>--authenticationDatabase admin</code></p><p><code>mongo -u username -p password --authenticationDatabase admin</code>，登录后可以正常操作数据库</p><p>为单独的应用创建用户，专门用于该数据库的读写。</p><p>首先切换到测试数据库test，创建用户testuser</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>退出MongoDB，重新使用该用户登录</p><p><code>mongo -u testuser -p 123123 --authenticationDatabase test</code></p><p>能查看到的数据库就只有<code>test</code>了，切换到别的数据库也无法查看任何数据</p>]]></content>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重学Docker笔记</title>
      <link href="/2018/10/12/%E9%87%8D%E5%AD%A6Docker%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/12/%E9%87%8D%E5%AD%A6Docker%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>重新学习Docker整理，docker版本18.06</p><ul><li><a href="#Docker安装注意事项">Docker安装注意事项</a></li><li><a href="#Docker基础命令集">Docker基础命令集</a></li><li><a href="#Docker核心原理">Docker核心原理</a></li><li><a href="#Docker镜像管理">Docker镜像管理</a></li><li><a href="#Dockerfile">Dockerfile</a></li><li><a href="#Docker监控与安全">Docker监控与安全</a></li></ul><a id="more"></a><h1 id="Docker安装注意事项"><a href="#Docker安装注意事项" class="headerlink" title="Docker安装注意事项"></a>Docker安装注意事项</h1><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">官方安装说明页面</a></p><p>若要使普通用户也能有直接操作Docker命令的权限（不需要sudo），可将该用户添加到docker组内。先要确保<code>/var/run/docker.sock</code>所属组为docker。</p><p><a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud加速</a></p><p>之后<code>systemctl daemon-reload</code>以及重启docker</p><h1 id="Docker基础命令集"><a href="#Docker基础命令集" class="headerlink" title="Docker基础命令集"></a>Docker基础命令集</h1><p>环境信息：</p><ul><li><code>docker info</code>：显示docker配置信息</li><li><code>docker version</code>：显示docker版本号</li></ul><p>容器生命周期管理：</p><ul><li><code>docker create</code>：创建容器</li><li><code>docker exec</code>：对运行的容器执行一条命令</li><li><code>docker kill</code>：杀死容器</li><li><code>docker pause</code>：停止指定容器的所有进程</li><li><code>docker restart</code>：重启容器</li><li><code>docker rm</code>：删除容器</li><li><code>docker run</code>：创建并运行容器。run就是create和start的组合</li><li><code>docker start</code>：启动一个或多个停止的容器</li><li><code>docker stop</code>：停止一个或多个容器</li><li><code>docker unpause</code>：恢复指定容器的所有进程继续运行</li></ul><p>镜像仓库管理：</p><ul><li><code>docker login</code>：登录到Docker仓库</li><li><code>docker logout</code>：登出Docker仓库</li><li><code>docker pull</code>：拉取镜像</li><li><code>docker push</code>：上传镜像</li><li><code>docker search</code>：搜索镜像</li></ul><p>镜像管理：</p><ul><li><code>docker build</code>：用Dockerfile构建一个镜像</li><li><code>docker images</code>：查看镜像</li><li><code>docker import</code>：</li><li><code>docker load</code>：</li><li><code>docker rmi</code>：</li><li><code>docker save</code>：</li><li><code>docker tag</code>：</li><li><code>docker commit</code>：因为容器的变化而构建一个新的镜像</li></ul><p>容器运维管理：</p><ul><li><code>docker attach</code>：连接进入一个容器</li><li><code>docker export</code>：</li><li><code>docker inspect</code>：</li><li><code>docker port</code>：</li><li><code>docker ps</code>：列出容器</li><li><code>docker rename</code>：重命名一个容器</li><li><code>docker stats</code>：</li><li><code>docker top</code>：</li><li><code>docker wait</code>：</li><li><code>docker cp</code>：</li><li><code>docker diff</code>：</li><li><code>docker update</code>：</li></ul><p>容器资源管理：</p><ul><li><code>docker volume</code>：管理数据卷</li><li><code>docker network</code>：管理网络</li></ul><p>系统日志信息：</p><ul><li><code>docker events</code>：获取一个容器的实时信息</li><li><code>docker history</code>：显示一个镜像的构建历史信息</li><li><code>docker logs</code>：获取一个容器的日志</li></ul><p>  config      Manage Docker configs<br>  container   Manage containers<br>  image       Manage images<br>  node        Manage Swarm nodes<br>  plugin      Manage plugins<br>  secret      Manage Docker secrets<br>  service     Manage services<br>  stack       Manage Docker stacks<br>  swarm       Manage Swarm<br>  system      Manage Docker<br>  trust       Manage trust on Docker images<br>  volume      Manage volumes</p><p>Commands:<br>  cp          Copy files/folders between a container and the local filesystem</p><p>  deploy      Deploy a new stack or update an existing stack<br>  diff        Inspect changes to files or directories on a container’s filesystem<br>  export      Export a container’s filesystem as a tar archive<br>  import      Import the contents from a tarball to create a filesystem image<br>  inspect     Return low-level information on Docker objects<br>  load        Load an image from a tar archive or STDIN<br>  login       Log in to a Docker registry<br>  logout      Log out from a Docker registry<br>  logs        Fetch the logs of a container<br>  port        List port mappings or a specific mapping for the container<br>  ps          List containers<br>  pull        Pull an image or a repository from a registry<br>  push        Push an image or a repository to a registry</p><p>  restart     Restart one or more containers<br>  rm          Remove one or more containers<br>  rmi         Remove one or more images<br>  run         Run a command in a new container<br>  save        Save one or more images to a tar archive (streamed to STDOUT by default)<br>  search      Search the Docker Hub for images<br>  stats       Display a live stream of container(s) resource usage statistics<br>  stop        Stop one or more running containers<br>  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE<br>  top         Display the running processes of a container<br>  update      Update configuration of one or more containers<br>  wait        Block until one or more containers stop, then print their exit codes</p><img src="/2018/10/12/重学Docker笔记/0.png"><h1 id="Docker核心原理"><a href="#Docker核心原理" class="headerlink" title="Docker核心原理"></a>Docker核心原理</h1><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><p><strong>Linux内核虚拟化容器技术（LXC Kernel Namespace）</strong>，将某个特定的全局系统资源通过抽象方法使得namespace中的进程看起来拥有自己的隔离的全局系统资源实例。LXC提供以下六种隔离的系统调用。</p><table><thead><tr><th>namespace</th><th>隔离的资源</th></tr></thead><tbody><tr><td>UTS</td><td>主机名和域名</td></tr><tr><td>IPC</td><td>进程间通信资源（信号量、消息队列、共享内存）</td></tr><tr><td>PID</td><td>进程编号</td></tr><tr><td>Network</td><td>网络相关资源（网络设备、网络栈、端口等）</td></tr><tr><td>Mount</td><td>挂载点（文件系统）</td></tr><tr><td>User</td><td>用户与用户组</td></tr></tbody></table><h2 id="cgroups"><a href="#cgroups" class="headerlink" title="cgroups"></a>cgroups</h2><p>cgroups全称<strong>control groups</strong>，是Linux内核的一种机制，可根据需求把一系列系统任务及子任务整合到<strong>按资源划分等级的不同组</strong>内，从而为系统资源管理提供一个统一的框架。即cgroups可以限制、记录任务组所使用的物理资源。</p><p>本质上，cgroups是内核附加在程序上的一系列钩子hook，通过程序运行时对资源的调度，触发相应的hook函数，以达到资源追踪和限制的目的。</p><p>cgroups特点：</p><ul><li>cgroups的API以一个伪文件系统实现，用户态的程序可以通过文件操作实现cgroups的组织管理</li><li>cgroups的组织<strong>操作单元的细粒度可达到线程级别</strong>，用户可创建销毁cgroups，实现资源再分配和管理</li><li>所有资源管理功能都以子系统方式实现，接口统一</li><li>子任务创建之初与父任务处于同一个cgroups控制组</li></ul><p>cgroups功能：</p><ul><li>资源限制：对任务使用的<strong>资源总额</strong>进行限制。一旦超出配额就发出<strong>OOM</strong>（out of memory）的警告</li><li>优先级分配：通过分配的<strong>CPU时间片数量及磁盘IO带宽大小</strong>，实际上就相当于控制了任务运行的优先级</li><li>资源统计：统计系统的资源使用量，适合于计费</li><li>任务控制：可对任务执行挂起、恢复等操作</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Docker开发指南</li><li>Docker容器与容器云</li><li><a href="https://docs.docker.com/" target="_blank" rel="noopener">Docker官方文档 版本18.03</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laogu-Monitor开发日志</title>
      <link href="/2018/10/09/Laogu-Monitor%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
      <url>/2018/10/09/Laogu-Monitor%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<p>记录我的个人项目Laogu-Monitor监控系统的开发过程。</p><a id="more"></a><h1 id="2018-10-9"><a href="#2018-10-9" class="headerlink" title="2018.10.9"></a>2018.10.9</h1><p>开始学习监控系统的开发，基于Django框架。以下是需要考虑的问题：</p><ul><li><p>监控的东西</p><ul><li>网络层面：网络流量、延迟、存活状态</li><li>系统层面：CPU、内存、磁盘分区、负载</li><li>应用层面：mysql、tomcat、nginx、django、HAProxy、Squid等</li><li>业务层面：PV、UV</li><li>硬件层面：磁盘、温度</li></ul></li><li><p>监控的模式</p><ul><li><p>主动监控：监控服务器主动向客户端索取数据</p><p>好处：不需要安装客户端，简单</p><p>坏处：当客户端过多则会出现性能瓶颈，不能灵活定制监控插件</p></li><li><p>被动监控：客户单主动向监控服务器汇报数据</p><p>好处：对服务器端的压力小，能灵活定制监控插件，延迟小</p><p>坏处：需要安装客户端（若通过自动化软件可轻松实现，也不能算坏处）</p></li></ul></li><li><p>监控需求：</p><ul><li>一台主机监控多个不同服务、不同服务间隔可不同</li><li>同一服务在不同主机上监控间隔、报警阈值可不同</li><li>可批量给主机添加、删除、修改服务</li><li>根据不同的服务以及服务的重要程度设置不同的告警级别并通知特定的用户，并且能实现告警升级</li><li>监控数据的存储和优化。实现用最少的空间存储最多的有效数据。在一秒内取出一台主机所有服务的5年记录</li><li>监控服务器的水平扩展</li></ul></li></ul><p>采用的C/S架构：<strong>HTTP</strong></p><p>原因：</p><ol><li>借口设计简单</li><li>容易水平扩展做分布式</li><li>Socket稳定成熟、省去较多的通信维护精力</li></ol><p>监控数据存储：<strong>Redis</strong></p><p>暂时列出以下几项规划：</p><ul><li>主机监控：<ul><li>系统状态</li><li>网络状态</li></ul></li><li>服务监控：<ul><li>web服务</li><li>LB服务（暂不在计划）</li><li>HA服务（暂不在计划）</li><li>HPC服务（暂不在计划）</li></ul></li><li>容器监控：<ul><li>docker容器</li><li>docker镜像</li><li>docker-swarm服务（暂不在计划）</li><li>kubernetes服务（暂不在计划）</li></ul></li><li>数据库监控：<ul><li>数据库状态</li></ul></li><li>日志管理：<ul><li>日志收集</li><li>日志分析</li></ul></li><li>自动化运维：<ul><li>集成ansible功能（暂不在计划）</li><li>告警功能</li><li>服务发现</li><li>网络拓扑</li><li>数据存储</li></ul></li><li>用户管理：<ul><li>权限管理</li><li>告警升级（暂不在计划）</li><li>访问统计</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
            <tag> python </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>信息安全学习笔记（软考）</title>
      <link href="/2018/10/03/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/"/>
      <url>/2018/10/03/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E8%BD%AF%E8%80%83%EF%BC%89/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>KVM学习笔记</title>
      <link href="/2018/10/03/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/03/KVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>OpenVPN学习笔记</title>
      <link href="/2018/10/03/OpenVPN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/03/OpenVPN%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> VPN </tag>
            
            <tag> OpenVPN </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>集群概念及应用笔记</title>
      <link href="/2018/10/01/%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/01/%E9%9B%86%E7%BE%A4%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="#集群概念">集群概念</a></li></ul><a id="more"></a><h1 id="集群概念"><a href="#集群概念" class="headerlink" title="集群概念"></a>集群概念</h1><p>几种服务器性能增强方式：</p><ul><li>Scale on：向上扩展。也称垂直扩展，在服务器硬件上扩展</li><li>Scale out：向外扩展。也称水平扩展，在服务器数量上扩展</li></ul><p>LB集群与HA集群的着眼点：</p><p>LB集群是为了增加请求的并发处理能力，而HA集群是为了增加服务的可用性</p><p>RAID阵列与NFS的区别：</p><p>NFS是文件系统服务器，前端web对数据的请求是文件级别的。属于NAS</p><p>NAS具有锁机制，因为NAS是服务器，是有操作系统的，这样就不会造成数据的不一致了。</p><p>RAID阵列是磁盘，前端web对数据的请求是块级别的。属于DAS</p><p>DAS就是磁盘，无法设置磁盘锁，因为读写操作是在内存中执行的，读取的数据都是在web服务器中执行操作，不同的web服务器读取同一段数据会造成数据的不一致</p><p>但是DAS的速度远高于NAS</p><p>一个文件包含多个数据块</p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Puppet自动化工具笔记</title>
      <link href="/2018/10/01/Puppet%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/01/Puppet%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> Puppet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL高可用笔记</title>
      <link href="/2018/10/01/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/10/01/MySQL%E9%AB%98%E5%8F%AF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="#MySQL高可用概述">MySQL高可用概述</a></li><li><a href="#MySQL主从复制">MySQL主从复制</a></li></ul><a id="more"></a><h1 id="MySQL高可用概述"><a href="#MySQL高可用概述" class="headerlink" title="MySQL高可用概述"></a>MySQL高可用概述</h1><h1 id="MySQL主从复制"><a href="#MySQL主从复制" class="headerlink" title="MySQL主从复制"></a>MySQL主从复制</h1>]]></content>
      
      
        <tags>
            
            <tag> 高可用 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>drbd数据同步笔记</title>
      <link href="/2018/09/30/drbd%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/30/drbd%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Heartbeat笔记</title>
      <link href="/2018/09/30/Heartbeat%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/30/Heartbeat%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="#Heartbeat概念">Heartbeat概念</a></li></ul><a id="more"></a><h1 id="Heartbeat概念"><a href="#Heartbeat概念" class="headerlink" title="Heartbeat概念"></a>Heartbeat概念</h1><p>Heartbeat 项目是 Linux-HA 工程的一个组成部分，它实现了一个高可用集群系统。可以将资源（IP及程序服务等资源）从一台故障计算机快速转移到另一台运转正常的机器继续提供服务。</p><p>通过修改heartbeat的配置文件，可以指定一台heartbeat服务器作为<strong>主服务器</strong>，另一台自动成为<strong>热备服务器</strong>。在<strong>热备服务器</strong>上面配置heartbeat守护程序来<strong>监听来自主服务器的心跳信息</strong>。如果<strong>在规定时间内，无法监听到心跳信息，那么就启动故障转移，取得主服务器上的相关资源的所有权，接替主服务器继续不间断的提供服务</strong>，从而达到资源以及服务高可用的目的。而heartbeat还支持<strong>主主模式</strong>，即两台服务器互为主备，互相监听，发送心跳报文。</p><p>注：heartbeat的业务切换时间大概在5到20秒，所谓的<strong>业务不间断其实是保障业务一致，不会造成数据错误</strong>。heartbeat的高可用是<strong>服务器级别的</strong>，而不是服务级别的。</p><p>业务切换的常见条件为：</p><ul><li>服务器宕机</li><li>心跳线故障</li><li>heartheat服务本身故障</li></ul><p>heartbeat服务器间通信的方法：</p><ul><li>串口线缆。线缆专门进行心跳通信，稳定，且不用配IP地址。缺点：服务器距离不能远。</li><li>两台服务器网卡通过以太网线直连。推荐使用</li><li>两台服务器网卡通过以太网设备连接。不稳定</li></ul><h2 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h2><p>两台正常运行的高可用服务器在心跳超时内无法监听到对方心跳报文，于是各自启动了故障转移，获取了资源的所有权，两台服务器都拥有同一个VIP地址，数据会出现不一致或丢失，这种情况称为脑裂（split brain）。</p><p><strong>发生脑裂的原因：</strong></p><ul><li>高可用服务器对之间的心跳链路故障，导致无法正常通信<ul><li>心跳线故障</li><li>网卡或相关驱动故障</li><li>IP配置冲突</li><li>心跳线间连接的设备故障，如交换机</li><li>仲裁机器故障</li></ul></li><li>高可用服务器上开启了防火墙，过滤掉了心跳报文</li><li>心跳配置不一致，如心跳方式、心跳广播冲突，以及软件BUG等</li></ul><p><strong>防止脑裂的方法：</strong></p><ul><li>同时使用串口线缆和一台线缆，组成<strong>两条心跳线</strong></li><li><strong>检测到脑裂时强行关闭一个节点，若备节点认为主节点故障，则会自动向主节点发送关机命令</strong>（此功能需要特殊设备支持，如STONITH、fencing）</li><li>对脑裂的告警，及时采取措施</li><li>启用磁盘锁，正在提供服务的一方锁住共享磁盘，即使发生脑裂也不会出现数据不一致或丢失情况。</li><li>增加仲裁机制。例如设置参考IP地址，若能ping通的服务器则接管服务，ping不通的服务器主动放弃竞争。</li></ul><blockquote><p>STONITH：Shoot-The-Other-Node-In-The-Head，是heartbeat的一个组件，能够保护数据使其不会因为节点异常或者同时访问而遭到损坏。<strong>用于集群服务无法停下的情况，在这种情况下，集群可以使用STONITH来强制整个节点离线，并让服务在其它节点上安全启用。</strong></p></blockquote><h2 id="heartbeat消息类型"><a href="#heartbeat消息类型" class="headerlink" title="heartbeat消息类型"></a>heartbeat消息类型</h2><p>三种heartbeat消息类型：</p><ul><li><p>心跳消息：控制心跳频率和出现故障后进行故障转换的等待时间。可以单播广播和组播，约150字节。</p></li><li><p>集群转换消息：<code>ip-request</code>和<code>ip-request-resp</code></p><p>当主服务器恢复后，使用<code>ip-request</code>消息要求备机将服务的提供权交还给主服务器。备服务器将服务提供权释放后，通过<code>ip-request-resp</code>通知主服务器，主节点收到后开始正常提供服务</p></li><li><p>重传消息：<code>rexmit-request</code>控制重传心跳请求</p></li></ul><h2 id="heartbeat-IP地址接管及故障转移"><a href="#heartbeat-IP地址接管及故障转移" class="headerlink" title="heartbeat IP地址接管及故障转移"></a>heartbeat IP地址接管及故障转移</h2><p>heartbeat通过IP地址接管和ARP广播进行故障转移。为防止ARP老化时间内，客户端仍请求已故障的服务器，备服务器会进行强制所有客户端进行ARP表项刷新。</p><p>VIP为对外提供服务的IP地址，因此需要在DNS上配置将网站的域名解析到这个VIP。有两种手工配置VIP的方法：</p><ul><li><code>ifconfig eth0:1 [IP地址] netmask [掩码] up</code></li><li><code>ip addr add [IP地址/掩码] broadcast [该网段广播地址] dev eth1</code></li></ul><p>注：<code>ip addr</code>能看到网卡别名和VIP，而<code>ifconfig</code>无法看到。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://blog.csdn.net/zyd_15221378768/article/details/78982353" target="_blank" rel="noopener">Heartbeat介绍</a></li><li><a href="https://www.cnblogs.com/zhangsubai/p/5393447.html" target="_blank" rel="noopener">Heartbeat高可用解决方案</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/8587882.html" target="_blank" rel="noopener">heartbeat单独提供高可用服务</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> heartbeat </tag>
            
            <tag> 高可用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sed与Awk笔记</title>
      <link href="/2018/09/29/Sed%E4%B8%8EAwk%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/29/Sed%E4%B8%8EAwk%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="">Sed</a></li><li><a href="">Awk</a></li></ul><a id="more"></a><h1 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h1><p>sed是一个面向字符流的编辑器，对文本进行过滤和替换操作，sed一次仅读取一行进行操作，适合处理大数据文件。可在一个或多个文件上自动实现编辑，简化对多个文件执行相同的编辑处理工作。</p><p>sed默认不修改源文件，仅仅修改输出信息，sed先将从文件读入的内容放入缓冲区，称为<strong>模式空间</strong>，在模式空间中对文件的副本操作，再输出到屏幕。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sed [选项]...  [输入文件]...</span><br><span class="line">  -n, --quiet, --silent     静默模式，结果不显示到屏幕</span><br><span class="line">  -e 脚本                    添加脚本指令，可添加多个</span><br><span class="line">  -f 脚本文件                添加脚本文件</span><br><span class="line">  --follow-symlinks         直接修改文件时跟随软链接</span><br><span class="line">  -i[SUFFIX]     直接修改源文件，若指定SUFFIX前缀，则进行对源文件的备份</span><br><span class="line">  -l N           指定l命令（输出非打印字符）可输出的行长度</span><br><span class="line">  --posix                   关闭所有 GNU 扩展</span><br><span class="line">  -s, --separate     默认sed将输入的多个文件名当做一个长的输入流，而GNU sed允许看做单独的文件</span><br><span class="line">  -u, --unbuffered   从输入文件读取最少的数据，即最低限度的缓存输入和输出</span><br></pre></td></tr></table></figure><p>sed的指令：<code>[地址]指令 内容</code>，在sed中<code>/</code>称为定界符，也可用其他的符号作为定界符，如<code>:</code>或<code>|</code>等。</p><ul><li><p><code>a</code>：append追加，若不指定行数，则会在每一行<strong>后</strong>都添加一行内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：sed &apos;2a XXXXX&apos; 文件        在文件的第二行后添加一行内容XXXXX</span><br><span class="line">   sed &apos;/XXX/a XXXXX&apos; 文件    在所有包含XXX的行后添加一行XXXXX</span><br><span class="line">   sed &apos;1,4a XXXXX&apos;          在第1到4行后添加一行XXXXX</span><br><span class="line">   sed &apos;$a XXXXX&apos;            在最后一行后添加一行，$表示最后一行</span><br></pre></td></tr></table></figure></li><li><p><code>i</code>：insert插入，是在行<strong>前</strong>添加一行内容，若不指定行数，则在每一行前添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：sed &apos;2i XXXXX&apos; 文件        在第二行前添加一行XXXXX</span><br><span class="line">   sed &apos;/XXX/i XXXXX&apos;         在包含XXX的行前添加一行XXXXX</span><br></pre></td></tr></table></figure></li><li><p><code>d</code>：delete删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例：sed &apos;2d&apos;        删除第二行</span><br><span class="line">   sed &apos;/^$/d&apos;     删除空白行</span><br><span class="line">   sed &apos;1~2d&apos;      ~用于指定从第几行开始的指定步长行的内容</span><br><span class="line">                   1~2用于指定第1行开始的两行，即第1,2行</span><br></pre></td></tr></table></figure></li><li><p><code>s</code>：substitution替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：sed &apos;s/XXX/XXXX/&apos;   将XXX替换为XXXX，会替换第一个匹配的</span><br><span class="line">   sed &apos;s/XXX/XXXX/n&apos;  只替换第n个匹配的XXX，n的范围是1-512</span><br><span class="line">   sed &apos;s/XXX/XXXX/g&apos;  对模式空间的所有匹配都更改</span><br></pre></td></tr></table></figure></li><li><p><code>c</code>：替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例：sed &apos;/XXX/c XXXXX&apos;   将包含XXX的一行替换为XXXXX</span><br></pre></td></tr></table></figure></li><li><p><code>p</code>：打印</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例：sed &apos;s/XXX/XXXX/p&apos;   替换后，打印替换后的句子（会重复打印）以及其他未替换的内容</span><br><span class="line">  若和-n一起使用，则只打印进行处理的行</span><br></pre></td></tr></table></figure></li><li><p><code>n</code>：一遇到匹配的行就立刻移动到下一行</p></li></ul><p>若要执行多个指令，则指令间用逗号分隔，或通过<code>-e 指令1 -e 指令2...</code>指定，最好通过文件添加指令，然后通过<code>-f</code>指定指令文件。</p><p>还可使用<code>/XXX/ {指令/内容}</code>替换：匹配的语句支持正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例：&lt;body&gt;hello&lt;body&gt;</span><br><span class="line">   sed &apos;s/body/\/body/2&apos;    将第二个body换为/body，还可用&#123;&#125;实现</span><br><span class="line">   sed &apos;/body/ &#123;s//\/body/2&#125;&apos;</span><br><span class="line">   就是s/后的要替换的内容提前到前面</span><br><span class="line">   还可以用&amp;替换要替换的部分</span><br><span class="line">   sed &apos;/body/ &#123;s//\/&amp;/2&#125;&apos;</span><br></pre></td></tr></table></figure><p>正则表达式<code>\w\+</code>匹配每一个单词，例：将每个单词都添加一个<code>[]</code>   <code>sed &#39;s/\w\+/[&amp;]&#39;</code>     </p><p><code>\n</code>匹配子串，n表示第n个子串，用<code>\(XXX\)</code> 匹配子串，会将XXX作为主串，将XXX后的字符串作为子串，例：将abcdefg中的efg替换为fff：<code>sed &#39;s/\(abcd\)efg/\1fff&#39;</code></p><p>可通过在匹配的行间添加逗号选定行范围：<code>sed &#39;/efg/,/abc/&#39;</code></p><p>将指定的内容添加到匹配的行下面：使用<code>a\</code>指令，<code>sed &#39;/abc/a\test&#39;</code>，将test字符串插入到匹配包含abc的行的下面。同理，<code>i\</code>将指定内容添加到匹配的行上面</p><p>打印奇数行：<code>sed -n &#39;p;n&#39;</code>或<code>sed -n &#39;1~2p&#39;</code><br>打印偶数行：<code>sed -n &#39;n;p&#39;</code>或<code>sed -n &#39;2~2p&#39;</code></p><h1 id="Awk"><a href="#Awk" class="headerlink" title="Awk"></a>Awk</h1><p>Awk是一种模式匹配的程序设计语言，用于对文本和数据进行扫描和处理，常用操作是将数据转换为格式化的报表。常见的awk编译器版本有awk，gawk，gawk与awk一致。</p><p>awk先逐行扫描文件，寻找匹配特定模式的行，并进行操作。因此，awk基本结构就是由<strong>模式匹配</strong>和<strong>处理动作</strong>组成。</p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> sed </tag>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zabbix搭建笔记</title>
      <link href="/2018/09/28/zabbix%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/28/zabbix%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="">zabbix介绍</a></li><li><a href="">zabbix搭建</a></li><li><a href="">zabbix常用操作</a></li></ul><a id="more"></a><h1 id="zabbix介绍"><a href="#zabbix介绍" class="headerlink" title="zabbix介绍"></a>zabbix介绍</h1><p>Zabbix是一个企业级开源的分布式监控套件，可以监控网络和服务的监控状况。 </p><p><strong>zabbix组成</strong>：<code>zabbix server</code>和<code>zabbix agent</code></p><ul><li><p>Zabbix Server可通过SNMP、Zabbix_agent、ping、端口扫描等方法提供对远程服务器的监视</p></li><li><p>Zabbix Agent安装在需要被监控的目录服务器上收集信息。</p></li></ul><p><strong>zabbix核心组件：</strong></p><ul><li>zabbix server：收集agent的监控信息，对数据统计操作，设置配置。zabbix server可单独监控，也可与agent结合。可轮询agent主动接收监控数据，也可被动接收。</li><li>zabbix databases：存储所有配置信息，以及监控数据</li><li>zabbix web GUI：通常与server运行在同一主机上，用于可视化操作</li></ul><p><strong>zabbix可选组件：</strong></p><ul><li><p>proxy：代理服务器，用于分布式监控环境，代理server接收agent的监控数据</p></li><li><p>agent：被监控主机，收集本地数据</p></li></ul><p>zabbix也可用于监控java应用，可基于JMX组件监控JVM</p><img src="/2018/09/28/zabbix搭建笔记/1.png"><p><strong>常用术语：</strong></p><ul><li><p>监控项item：一个特定的监控指标的数据，<strong>监控项是zabbix数据收集的核心</strong></p></li><li><p>触发器trigger：一个表达式，用于<strong>评估某监控对象的某特定item内所接收的数据是否在合理范围内</strong>，即阈值。当数据量大于阈值时，触发器状态从ok变为problem</p></li><li><p>事件event：发生的事情，如触发器状态的变化，新的agent或agent重新注册</p></li><li><p>动作action：指<strong>对特定事件事先定义的处理方法</strong>，包含操作与条件</p></li><li><p>报警升级escalation：发送警报或执行远程命令的自定义方案</p></li><li><p>媒介media：发送通知的手段或通道，如Email，jabber，SMS</p></li><li><p>通知notification：通过选定的媒介向用户发送的有关某事件的信息</p></li><li><p>远程命令：预定义的命令，可在被监控主机处于某特定条件下自动执行</p></li><li><p>模板template：用于快速定义被监控主机的预设条目集合，包含item，trigger，graph，screen（多个graph），application，low-level discovery rule。模板可以直接链接到单个主机</p></li><li><p>应用程序application：一组item的集合</p></li><li><p>web场景web scennaria：用于检测web站点可用性的一个或多个http请求</p></li></ul><img src="/2018/09/28/zabbix搭建笔记/2.png"><p><strong>Zabbix特点：</strong></p><ul><li>配置简单：可使用模板，直接添加监控设备、可配置组监控、可对模板继承，进行精细设定</li><li>实时绘图，自定义监控图表（面板），支持网络拓扑图</li><li>灵活的告警机制：可自定义告警升级（escalation）、接受者和告警方式，还可通过远程命令实现自动化动作action</li><li>可进行不同类型数据的收集：性能、SNMP、IPMI、JMX，可自定义收集数据的间隔</li><li>数据存储：可将数据存放在数据库中，并内置数据清理机制</li><li>网络自动发现机制：自动发现网络设备、文件系统、网卡等，agent自动注册</li><li>zabbix由C开发，高性能，内存消耗低。web前段由php编写</li><li>提供丰富的API</li><li>可进行权限认证，并进行访问控制</li></ul><h1 id="zabbix搭建"><a href="#zabbix搭建" class="headerlink" title="zabbix搭建"></a>zabbix搭建</h1><p><strong>搭建zabbix监控服务器端</strong></p><p>zabbix需要LAMP或LNMP的环境，先安装以下环境<code>gcc gcc-c++ autoconf automake zlib zlib-devel openssl openssl-devel pcre-devel</code></p><p>安装php环境：<code>yum install php</code></p><p>安装mysql/mariadb环境：<code>yum install mariadb*</code></p><h2 id="LNMP环境搭建Zabbix"><a href="#LNMP环境搭建Zabbix" class="headerlink" title="LNMP环境搭建Zabbix"></a>LNMP环境搭建Zabbix</h2><p>可通过yum安装nginx，但版本不是最新的。通过源码安装nginx版本为1.14。</p><p>首先创建nginx用户及用户组。然后下载源码包并解压，进入目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx \</span><br><span class="line">            --sbin-path=/usr/sbin/nginx \</span><br><span class="line">            --conf-path=/etc/nginx/nginx.conf \</span><br><span class="line">            --error-log-path=/var/log/nginx/error.log \</span><br><span class="line">            --pid-path=/var/run/nginx/nginx.pid \</span><br><span class="line">            --lock-path=/var/lock/nginx.lock \</span><br><span class="line">            --user=nginx \</span><br><span class="line">            --group=nginx \</span><br><span class="line">            --http-log-path=/var/log/nginx/access.log \</span><br><span class="line">            --http-client-body-temp-path=/var/tmp/nginx/client \</span><br><span class="line">            --with-http_ssl_module \</span><br><span class="line">            --with-http_stub_status_module \</span><br><span class="line">            --with-http_gzip_static_module \</span><br><span class="line">            --with-http_dav_module \</span><br><span class="line">            --with-http_stub_status_module \</span><br><span class="line">            --with-http_addition_module \</span><br><span class="line">            --with-http_flv_module \</span><br><span class="line">            --with-http_mp4_module \</span><br><span class="line">            --with-http_sub_module \</span><br><span class="line">            --with-debug</span><br></pre></td></tr></table></figure><p>进入<code>/etc/nginx/nginx.conf</code>添加一行<code>user nginx nginx</code></p><p>安装zabbix，首先去官网选择主机环境版本<a href="https://www.zabbix.com/download" target="_blank" rel="noopener">下载页</a>，安装zabbix的repo源。</p><p>然后安装<code>zabbix-server-mysql zabbix-web-mysql zabbix-agent zabbix-web</code></p><p>若是客户端，不需要搭建LAMP或LNMP环境，只需要安装repo源和<code>zabbix-agent</code>和<code>zabbix-sender</code>，并且<code>zabbix-sender</code>也不是必须安装，若要主动向zabbix服务器发送监控数据时才需要安装。</p><p>zabbix的几个目录：</p><ul><li><code>/etc/zabbix</code>：zabbix配置目录</li><li><code>/var/log/zabbix</code>：zabbix日志目录</li><li><code>/var/run/zabbix</code>：zabbix运行目录</li><li><code>/usr/lib/zabbix</code>：zabbix库文件目录</li><li><code>/usr/share/zabbix</code>：zabbix的web文件目录</li></ul><p>修改nginx配置文件，找到下面配置，修改<code>fastcgi_param</code>后的路径为<code>/usr/share/zabbix</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           html;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  /usr/share/zabbix$fastcgi_script_name;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mysql创建zabbix库，和管理数据库的用户zabbix</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database zabbixdb;</span><br><span class="line">grant all on zabbix.* to zabbix@127.0.0.1 identified by &apos;zabbix&apos;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>导入zabbix的sql文件，sql文件存放在<code>/usr/share/doc/zabbix-server-mysql-3.4.14/create.sql.gz</code>中，用<code>gunzip create.sql.gz</code>解压，然后导入<code>mysql -u root -p zabbixdb &lt; create.sql</code></p><p>修改<code>/etc/zabbix/zabbix_server.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbixdb</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix</span><br></pre></td></tr></table></figure><p>安装zabbix后，会自动创建系统用户zabbix，但这个用户是设置了无法登录，而zabbix不允许。需要重新创建</p><p><code>zabbix</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">zabbix_server</span><br><span class="line">  -c      指定配置文件，默认/etc/zabbix/zabbix_server.conf</span><br><span class="line">  -f      在前台运行zabbix_server</span><br><span class="line">  -R      执行运行时管理功能，功能如下</span><br><span class="line">      config_cache_reload        重新读取配置缓存</span><br><span class="line">      housekeeper_execute        执行housekeeper</span><br><span class="line">      log_level_increase=target  提升日志等级，若不指定target则影响zabbix所有进程</span><br><span class="line">      log_level_decrease=target  降低日志等级，同上</span><br><span class="line">           #target可以是PID，进程类型</span><br><span class="line"></span><br><span class="line">zabbix_agentd</span><br><span class="line">  与zabbix_server参数一致，并多了下面的配置</span><br><span class="line">  -p      显示已知的items</span><br><span class="line">  -t      测试指定的item</span><br></pre></td></tr></table></figure><p>启动zabbix_server服务<code>systemctl start zabbix-server.service</code>或<code>zabbix_server</code>启动</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://www.zabbix.com/documentation/3.4/zh/manual" target="_blank" rel="noopener">zabbix官方中文手册</a></li><li><a href=""></a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lucene与Solr笔记</title>
      <link href="/2018/09/26/Lucene%E4%B8%8ESolr%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/26/Lucene%E4%B8%8ESolr%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>ELK与EFK详细笔记</title>
      <link href="/2018/09/24/ELK%E4%B8%8EEFK%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/24/ELK%E4%B8%8EEFK%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容：</p><ul><li><a href="#ELK">ELK</a><ul><li><a href="#Elasticsearch">Elasticsearch</a></li><li><a href="#Logstash">Logstash</a></li><li><a href="#Kibana">Kibana</a></li><li><a href="#Beats">Beats</a></li><li><a href="#ELK架构">ELK架构</a></li></ul></li><li><a href="#EFK">EFK</a><ul><li><a href="#Fluentd">Fluentd</a></li><li><a href="#EFK架构">EFK架构</a></li></ul></li></ul><a id="more"></a><h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><img src="/2018/09/24/ELK与EFK详细笔记/0.png"><p>Elasticsearch是基于Lucene的搜索框架，使用Java编写，它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口，上手容易，拓展节点方便，可用于存储和检索海量数据，接近实时搜索，海量数据量增加，搜索响应性能几乎不受影响。</p><blockquote><p>Apache Lucene：目前存在的拥有最先进，高性能和全功能搜索引擎功能的库。但仅仅是一个库，Elasticsearch则是提供了Lucene库的RESTful API接口，将所有的功能打包成一个单独的服务，做到”开箱即用“。</p></blockquote><p>Elasticsearch主要特点：</p><ul><li>全文检索，结构化检索</li><li>数据统计、分析，接近实时处理</li><li>分布式搜索（可部署数百台服务器）</li><li>自动发现节点</li><li>副本机制</li><li>处理PB级别的结构化或者非结构化数据</li><li>保障可用性</li><li>搜索纠错，自动完成</li><li>与各种语言基础，与Hadoop、Spark等大数据分析平台集成</li></ul><p>使用场景：日志搜索，数据聚合，数据监控，报表统计分析</p><p>使用Elasticsearch的大企业：维基百科、卫报、StackOverflow、Github、ebay</p><h2 id="Elasticsearch安装"><a href="#Elasticsearch安装" class="headerlink" title="Elasticsearch安装"></a>Elasticsearch安装</h2><ol><li><p>因为Lucene和Elasticsearch都是Java写的，所以首先搭建JDK环境，下载JDK1.8，设置环境变量，并<code>source /etc/profile</code>应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;export JAVA_HOME=/usr/local/jdk1.8&quot;&gt;&gt;/etc/profile</span><br><span class="line">echo &quot;export CLASSPATH=$JAVA_HOME/lib&quot;&gt;&gt;/etc/profile</span><br><span class="line">echo &quot;export PATH=$JAVA_HOME/bin:$PATH&quot;&gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure></li><li><p>下载Elasticsearch，目前版本为6.4.1，解压到<code>/usr/local/elasticsearch-6.4</code></p></li><li><p>不能使用root运行<code>elasticsearch</code>，需要创建一个用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd elastic</span><br><span class="line">chown -R elastic:elastic /usr/local/elasticsearch-6.4</span><br></pre></td></tr></table></figure></li><li><p>切换到该用户，并执行<code>elasticsearch</code>。等待一段时间启动，然后执行<code>curl localhost:9200</code>查看。若看到json对象信息则说明成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;3dcAoxl&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;GNdmHFuXTsK-6B-swVNQag&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;6.4.1&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;tar&quot;,</span><br><span class="line">......</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>运行报错</strong></p><img src="/2018/09/24/ELK与EFK详细笔记/1.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bootstrap checks failed  #bootstrap检查失败</span><br><span class="line">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]  #最大虚拟内存太低</span><br></pre></td></tr></table></figure><p>解决：</p><ol><li>临时解决： <code>sysctl -w vm.max_map_count=262144</code></li><li>永久解决：修改<code>/etc/sysctl.conf</code>文件，添加 <code>vm.max_map_count</code>设置，并执行<code>sysctl -p</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</span><br></pre></td></tr></table></figure><p>解决：修改unix最大同时打开文件数，<code>ulimit -n 65536</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">elasticsearch</span><br><span class="line">  -E &lt;键值对&gt;            设置参数</span><br><span class="line">  -d, --daemonize       后台启动</span><br><span class="line">  -p, --pidfile &lt;Path&gt;  设置PID文件</span><br><span class="line">  -q, --quiet           静默启动</span><br><span class="line">  -s, --silent          显示最少的输出</span><br><span class="line">  -v, --verbose         显示详细输出</span><br></pre></td></tr></table></figure><h2 id="Elasticsearch配置文件"><a href="#Elasticsearch配置文件" class="headerlink" title="Elasticsearch配置文件"></a>Elasticsearch配置文件</h2><p>ES核心配置文件<code>config/elasticsearch.yml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster.name: my-application     #集群名称，若相同，且是同一网段会自动加入</span><br><span class="line">node.name: node-1                #当前节点名称</span><br><span class="line">node.attr.rack: r1               #</span><br><span class="line">network.host: 127.0.0.1          #默认情况下，Elastic只允许本机访问</span><br><span class="line">                                 #若要远程访问，取消注释并修改值为0.0.0.0</span><br></pre></td></tr></table></figure><p>JVM配置文件<code>jvm.option</code>，最好不要调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g     #最小堆内存</span><br><span class="line">-Xmx1g     #最大堆内存</span><br><span class="line">#两个值最好一致，且为机器物理内存的一半到2/3，也不能太小</span><br><span class="line"></span><br><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=75</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">#垃圾回收算法，官方已经优化过了，不用调整</span><br></pre></td></tr></table></figure><h2 id="Elasticsearch概念"><a href="#Elasticsearch概念" class="headerlink" title="Elasticsearch概念"></a>Elasticsearch概念</h2><p>Elasticsearch 是 <strong>面向文档</strong> 的，意味着它存储整个对象或文档。且Elasticsearch不仅存储文档，而且索引每个文档的内容使之可以被检索。在Elasticsearch 中，是对文档进行索引、检索、排序和过滤，而不是对行列数据。这就是ES能支持复杂的全文搜索的原因。</p><p>Elasticsearch使用JSON作为文档的序列化格式。存储数据到 Elasticsearch 的行为叫做<strong>索引</strong>（动词，索引一个文档就是存储一个文档到索引），一个 Elasticsearch 集群可以包含多个索引 ，相应的每个索引可以包含多个<strong>类型</strong> 。这些不同的类型存储着多个文档 ，每个文档又有多个<strong>字段</strong> 。Elasticsearch和Lucene使用<strong>倒排索引（也称反向索引）</strong>结构达到较高的检索速度。倒排索引就是关系型数据库通过增加一个索引到<strong>指定列</strong>上以提高搜索速度。</p><h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>Representational State Transfer表述性状态传递，是一种软件架构风格，提供的是一组设计原则和约束条件，主要用于客户端与服务器交互的软件，使得软件更简洁、有层次，更利于实现缓存等机制。</p><p>REST提供的与资源交互的方法：类似于HTTP，但REST的方法仅仅面向资源，无法对web应用操作。</p><ul><li>GET：列出URI以及资源中详细信息</li><li>PUT：将给定的一组资源替换当前资源</li><li>POST：在指定资源中创建、追加一个新资源</li><li>DELETE：删除资源</li><li>HEAD：获取头信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;first_name&quot; : &quot;John&quot;,</span><br><span class="line">    &quot;last_name&quot; :  &quot;Smith&quot;,</span><br><span class="line">    &quot;age&quot; :        25,</span><br><span class="line">    &quot;about&quot; :      &quot;I love to go rock climbing&quot;,</span><br><span class="line">    &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>megacorp</code>为索引名，<code>employee</code>为类型名，<code>1</code>为雇员ID。Elasticsearch仅需要找到雇员ID文件，就能知道该雇员的所有信息。</p><p>若要与关系型数据库对照，<strong>索引</strong>（indice或index）对应<strong>库</strong>，<strong>类型</strong>（type）对应<strong>表</strong>，<strong>文档</strong>（document）对应<strong>行</strong>，<strong>字段</strong>（field）对应<strong>列</strong></p><p>Elasticsearch通过将数据<strong>分片（shards）</strong>存储以解决数据量大时不能直接存储在一块硬盘中，且无法一次性搜索超大的数据量的情况。创建索引时，只需定义所需的分片数即可。每个分片本身都是一个功能齐全且独立的“索引”，可以托管在集群中的任何节点上。</p><blockquote><p>每个Elasticsearch分片都是Lucene索引。每个Lucene可包含的最大文件数量为Integer.MAX_VALUE - 128个文件可以使用<code>/_cat/shards</code>监视分片大小。</p></blockquote><p>并通过创建分片的<strong>副本（replicas）</strong>，当主分片不可用时，副本就充当主分片使用。Elasticsearch为每个索引分配5个主分片和1个副本，若集群中有两个节点，该索引的分片数会翻倍，即10个分片。</p><h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3><p>一个运行的Elasticsearch实例为一个节点，集群是由一个或多个拥有相同<code>cluster.name</code>的节点构成的，当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。</p><blockquote><p><code>cluster.name</code>默认为<code>elasticsearch</code></p></blockquote><p>主节点：负责管理集群范围内的所有变更（增删索引和节点等），任何节点都可以成为主节点。主节点并不需要涉及到文档级别的变更和搜索等操作，因此流量的增加它也不会成为瓶颈。</p><p>每个节点都知道任意文档所处的位置，并且能够将请求直接转发到存储客户所需文档的节点。</p><h4 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h4><p>可通过<code>curl localhost:9200/_cluster/health</code>或使用<code>telnet 127.0.0.1 9200</code>并输入<code>GET /_cluster/health HTTP/1.1</code>获取集群的健康状况，或通过<code>curl 127.0.0.1 9200/_cat/health?v</code>查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cluster_name&quot;:     &quot;elasticsearch&quot;,</span><br><span class="line">    &quot;status&quot;:           &quot;green&quot;,</span><br><span class="line">    &quot;timed_out&quot;:        false,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中健康状况就是字段<code>status</code>，有三个可能值：</p><ul><li><code>green</code>：所有的主分片和副本分片都正常运行</li><li><code>yellow</code>：所有的主分片都正常运行，但不是所有的副本分片都正常运行</li><li><code>red</code>：有主分片没能正常运行，数据可能丢失，需要紧急修复</li></ul><h4 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h4><p>读操作、搜索和返回数据都可以同时被主分片或副本分片所处理，所以拥有越多的副本分片时，也将拥有越高的吞吐量。在运行中的集群上是可以动态调整副本分片数目的 ，可以按需伸缩集群。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application/json&quot; -X PUT localhost:9200/blogs/_settings -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;number_of_replicas&quot;: 2</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>如果只是<strong>在相同节点数目的集群上增加更多的副本分片并不能提高性能</strong>，因为<strong>每个分片从节点上获得的资源会变少</strong>，需要增加更多的硬件资源来提升吞吐量，但是<strong>更多的副本分片数提高了数据冗余量</strong>。</p><h4 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h4><p>可通过<code>curl</code>添加索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application/json&quot; -X PUT localhost:9200/blogs/article/1 -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:   &quot;article1&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;article1&quot;</span><br><span class="line">&#125;&apos;</span><br><span class="line"># -H设置内容类型，要设为JSON格式</span><br><span class="line"># -X设置请求类型，设为PUT</span><br><span class="line"># -d设置请求数据</span><br></pre></td></tr></table></figure><p>若添加成功就会返回以下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;blogs&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;article&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;result&quot;: &quot;created&quot;,</span><br><span class="line">    &quot;_shards&quot;:&#123;</span><br><span class="line">        &quot;total&quot;: 2,        #目前总共的分片数</span><br><span class="line">        &quot;successful&quot;: 1,   </span><br><span class="line">        &quot;failed&quot;: 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;_seq_no&quot;: 0,</span><br><span class="line">    &quot;_primary_term&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对已存在的记录再进行PUT操作就会更新该记录，同时，该字段的<code>_version</code>和<code>_result</code>都会改变，<code>_version</code>会<code>+1</code>，<code>_result</code>会变为<code>updated</code>。</p><p>再通过<code>curl localhost:9200/blogs/article/1</code>，获取该文章的元数据，以及<code>_source</code>属性，存储的就是文章中定义的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;_index&quot;: &quot;blogs&quot;,</span><br><span class="line">    &quot;_type&quot;: &quot;article&quot;,</span><br><span class="line">    &quot;_id&quot;: &quot;1&quot;,</span><br><span class="line">    &quot;_version&quot;: 1,</span><br><span class="line">    &quot;found&quot;: true,</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &quot;article1&quot;,</span><br><span class="line">        &quot;content&quot;: &quot;article1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过<code>curl localhost:9200/_cat/indices?v</code>获取当前节点的索引信息</p><p>若要删除某个索引或类型或文档，都可通过<code>curl -X DELETE localhost:9200/要删的资源</code>删除。</p><h4 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h4><p><code>curl localhost:9200/_search?pretty</code>获取本节点的所有文档信息，并且返回结果不仅告知匹配了哪些文档，还包含了整个文档本身：显示搜索结果给最终用户所需的全部信息。<code>?pretty</code>会将json重新排版显示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 2,</span><br><span class="line">    &quot;max_score&quot; : 1.0,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;blogs&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;article&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">        &quot;_score&quot; : 1.0,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;title&quot; : &quot;article2&quot;,</span><br><span class="line">          &quot;content&quot; : &quot;article2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      ......</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可通过<code>_all</code>字段进行指定文档或类型中的搜索，例如<code>/_all/employee/_search?</code>进行指定类型中搜索（所有索引的中的<code>employee</code>（如果存在））</p><p><code>?q=字段:值</code>进行<strong>查询字符串（Query-string）</strong>搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200/_search?q=title:article2</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    &quot;hits&quot;:&#123;&quot;total&quot;:1,&quot;max_score&quot;:0.2876821,&quot;hits&quot;:[&#123;&quot;_index&quot;:&quot;blogs&quot;,&quot;_type&quot;:&quot;article&quot;,&quot;_id&quot;:&quot;2&quot;,&quot;_score&quot;:0.2876821,&quot;_source&quot;:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;title&quot;:   &quot;article2&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;article2&quot; &#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="查询表达式搜索"><a href="#查询表达式搜索" class="headerlink" title="查询表达式搜索"></a>查询表达式搜索</h4><p>使用的是Elasticsearch开发的DSL（领域特定语言），基于JSON定义查询，能够构造复杂的查询语句。</p><p>不使用Query-string查询，而是通过请求体查询，请求会通过Json构造。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200/_search -X GET -H &quot;Content-Type: application/json&quot; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;           #使用了match类型查询</span><br><span class="line">            &quot;title&quot;: &quot;article1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>常用请求体搜索规则：</p><p><code>&quot;query&quot;:{}</code>表示开始查询，其中定义许多查询规则，会计算评分数量（相关度）<code>_score</code></p><ul><li><code>&quot;bool&quot;</code>：进行布尔匹配<ul><li><code>&quot;must&quot;</code>：包含</li><li><code>&quot;must_not&quot;</code>：不包含</li></ul></li><li><code>&quot;match&quot;</code>：普通匹配，若用空格隔开多个关键字，则es认为是或的关系，如果要同时满足多个关键词，即与关系，必须用<code>bool</code>查询</li><li><code>&quot;match_phrase&quot;</code>：短语精确匹配</li><li><code>&quot;filter&quot;</code>：过滤器，不会计算评分数量<ul><li><code>&quot;range&quot;</code>：匹配范围，例如：<code>&quot;range&quot;:{age&quot;:{&quot;gt&quot;:30}}</code>匹配age大于30</li></ul></li><li><code>&quot;size&quot;</code>：设置一次返回的结果数量，默认为10条。</li><li><code>&quot;from&quot;</code>：设置移位，默认从位置0开始</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 已经alias curl_lo_g=&apos;curl -X GET -H &apos;Content-Type:application/json&apos;&apos;</span><br><span class="line"># export LO_ES=&apos;localhost:9200&apos;</span><br><span class="line"></span><br><span class="line">curl_lo_g $&#123;LO_ES&#125;/_all/employee/_search -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;           </span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gt&quot;: &quot;30&quot;   #要加上双引号</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,                 #这里有逗号</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;hobby&quot;: &quot;swimming&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>对于filter和query的区别：</p><ul><li>大部分filter的速度<strong>快于</strong>query的速度 </li><li>filter不会计算相关度得分，且结果会<strong>有缓存，效率高</strong></li><li>全文搜索、<strong>评分排序</strong>，使用query</li><li>是非过滤，<strong>精确匹配</strong>，使用filter</li></ul><h4 id="高亮搜索"><a href="#高亮搜索" class="headerlink" title="高亮搜索"></a>高亮搜索</h4><p>能将搜索结果的要搜索的字符串高亮显示，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">curl_lo_g $&#123;LO_ES&#125;/_all/employee/_search -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;hobby&quot;: &quot;climbing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;      #只需要添加highlight搜索即可</span><br><span class="line">    &quot;fields&quot;: &#123;       #fields指定高亮的字段</span><br><span class="line">      &quot;hobby&quot;: &#123;&#125;     #需要高亮搜索的字段</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&apos;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#123;&quot;_index&quot;:&quot;tech&quot;,&quot;_type&quot;:&quot;employee&quot;,&quot;_id&quot;:&quot;3&quot;,&quot;_score&quot;:0.2876821,&quot;_source&quot;:</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;wangwu&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;26&quot;,</span><br><span class="line">  &quot;address&quot;: &quot;yangzhou&quot;,</span><br><span class="line">  &quot;hobby&quot;: [&quot;swimming&quot;, &quot;climbing&quot;]</span><br><span class="line">&#125;,</span><br><span class="line">&quot;highlight&quot;:&#123;             #标出高亮部分</span><br><span class="line">  &quot;hobby&quot;:[</span><br><span class="line">    &quot;&lt;em&gt;climbing&lt;/em&gt;&quot;   #高亮部分由HTML标签&lt;em&gt;封装</span><br><span class="line">                          #告诉浏览器把其中的文本表示为强调的内容</span><br><span class="line">                          #通常为斜体</span><br><span class="line">  ]&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>聚合aggregations用于生成基于数据的精细分析结果，类似SQL的<code>group by</code>。</p><h1 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h1><p>Logstash是一个开源的服务器端数据处理管道（Pipeline），它可以同时从多个源中提取数据，对其进行转换，然后将其发送到数据存储（如Elasticsearch）。支持丰富的 Input 和 Output 类型，能够处理各种应用的日志。</p><p>Logstash对于每一行数据（称为event）按流水线三个部分进行操作：</p><ul><li>input：负责产生事件（即数据），即数据源，如syslog、数据库日志、web日志、文件系统日志、java的log4j、网络日志、防火墙等各类日志，kafka、RabbitMQ等消息队列，移动设备、智能家居、传感器、联网汽车等IoT数据，以及Beats能获取的数据。是必须配置</li><li>filter：负责数据处理与转换，包括过滤，分类等操作。不是必须配置。</li><li>output：负责数据的输出，可输出到数据分析或存储的软件，如Elasticsearch，nagios，kibana等数据处理软件。是必须配置</li></ul><p>Logstash开箱即用，包含许多聚合（aggregation）和突变（mutation），以及模式匹配（pattern matching），地理映射（geo mapping）和动态查找（dynamic lookup）功能。</p><img src="/2018/09/24/ELK与EFK详细笔记/3.png"><h2 id="Logstash安装"><a href="#Logstash安装" class="headerlink" title="Logstash安装"></a>Logstash安装</h2><ol><li><p>下载Logstash包，版本为6.4.1，解压到<code>/usr/local/logstash6.4</code></p></li><li><p>进入logstash的<code>bin</code>目录执行<code>./logstash -e &#39;input{stdin{}} output{stdout{codec=&gt;rubydebug}}&#39;</code>，需要等待一段时间，期间会有信息，直到出现<code>Successfully started Logstash API endpoint {:port=&gt;9600}</code>，然后输入<code>hello world</code>即可看到以下信息。若要退出，按<code>Ctrl+D</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello world</span><br><span class="line">&#123;</span><br><span class="line">       &quot;message&quot; =&gt; &quot;hello world&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;VM_0_7_centos&quot;,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2018-09-26T11:09:10.781Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>docker下载Logstash：直接<code>docker pull logstash</code>即可。</p><p>docker下启动Logstash：首先要确保本地存放pipeline配置文件的目录存在。通过在该目录添加配置文件。或者直接<code>-v ~/config:/usr/share/logstash/config</code>可直接修改所有配置</p><p><code>docker run -it -v ~/pipeline:/usr/share/logstash/pipeline logstash</code></p><p>Logstash配置文件：</p><ul><li><code>logstash.yml</code>：主配置文件</li><li><code>pipelines.yml</code>：管道的配置，包括input，filter，output</li><li><code>jvm.options</code>：JVM配置文件</li><li><code>log4j2.properties</code>：log4j2的配置</li><li><code>startup.options</code>：启动脚本选项文件，包含Logstash的变量。若要让Logstash按修改后的配置运行，需要重新用root运行<code>bin/system-install</code>导入参数。</li><li>自定义的Logstash配置文件，一般以<code>.conf</code>结尾，同样存放在配置文件目录中。</li></ul><p>logstash命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">logstash</span><br><span class="line">    -n NAME          指定logstash的node.name，若不指定默认是当前的主机名</span><br><span class="line">    -f CONFIG_PATH   从特定文件或目录加载logstash配置</span><br><span class="line">    -e CONFIG_STRING 使用给定的字符串作为配置数据（与配置文件的语法相同）</span><br><span class="line">                     默认输入：“input &#123;stdin &#123;type =&gt; stdin&#125;&#125;”</span><br><span class="line">                     默认输出：“output &#123;stdout &#123;codec =&gt; rubydebug&#125;&#125;“</span><br><span class="line">                     若直接使用默认，则-e &quot;&quot; 即可（不能什么都不加）</span><br><span class="line">    --field-reference-parser MODE 在解析字段引用时使用的模式</span><br><span class="line">    字段引用解析器用于扩展管道配置中的字段引用，能更好地处理非法和模糊输入</span><br><span class="line">    可用的MODE值：1. LEGACY：LEGACY解析器，不发出警告</span><br><span class="line">                2. COMPAT：COMPAT解析器，对每个不同的模糊或非法语法输入警告一次（默认使用）</span><br><span class="line">                3.STRICT：STRICT解析器，模糊或非法语法输入会引发插件运行时异常</span><br><span class="line">    --modules MODULES   加载logstash模块，不能与&apos;-e&apos;或&apos;-f&apos;一起使用</span><br><span class="line">                        因为会覆盖在logstash.yml中加载的模块</span><br><span class="line">    两种写法：--modules module1 --modules module2 ...</span><br><span class="line">            --modules=module1,module2</span><br><span class="line">    -M MODULES_VARIABLE Load variables for module template.</span><br><span class="line">                                  Multiple instances of &apos;-M&apos; or</span><br><span class="line">                                  &apos;--modules.variable&apos; are supported.</span><br><span class="line">                                  Ignored if &apos;--modules&apos; flag is not used.</span><br><span class="line">                                  Should be in the format of</span><br><span class="line">                                  &apos;-M &quot;MODULE_NAME.var.PLUGIN_TYPE.PLUGIN_NAME.VARIABLE_NAME=VALUE&quot;&apos;</span><br><span class="line">                                  as in</span><br><span class="line">                                  &apos;-M &quot;example.var.filter.mutate.fieldname=fieldvalue&quot;&apos;</span><br><span class="line">    --setup                       Load index template into Elasticsearch, and saved searches, </span><br><span class="line">                                  index-pattern, visualizations, and dashboards into Kibana when</span><br><span class="line">                                  running modules.</span><br><span class="line">                                   (default: false)</span><br><span class="line">    --cloud.id CLOUD_ID           Sets the elasticsearch and kibana host settings for</span><br><span class="line">                                  module connections in Elastic Cloud.</span><br><span class="line">                                  Your Elastic Cloud User interface or the Cloud support</span><br><span class="line">                                  team should provide this.</span><br><span class="line">                                  Add an optional label prefix &apos;&lt;label&gt;:&apos; to help you</span><br><span class="line">                                  identify multiple cloud.ids.</span><br><span class="line">                                  e.g. &apos;staging:dXMtZWFzdC0xLmF3cy5mb3VuZC5pbyRub3RhcmVhbCRpZGVudGlmaWVy&apos;</span><br><span class="line">    --cloud.auth CLOUD_AUTH       Sets the elasticsearch and kibana username and password</span><br><span class="line">                                  for module connections in Elastic Cloud</span><br><span class="line">                                  e.g. &apos;username:&lt;password&gt;&apos;</span><br><span class="line">    --pipeline.id ID              Sets the ID of the pipeline.</span><br><span class="line">                                   (default: &quot;main&quot;)</span><br><span class="line">    -w COUNT  指定pipeline worker数量（即线程数），默认1</span><br><span class="line">    --experimental-java-execution (Experimental) Use new Java execution engine.</span><br><span class="line">                                   (default: false)</span><br><span class="line">    -b, --pipeline.batch.size SIZE Size of batches the pipeline is to work in.</span><br><span class="line">                                   (default: 125)</span><br><span class="line">    -u, --pipeline.batch.delay DELAY_IN_MS When creating pipeline batches, how long to wait while polling</span><br><span class="line">                                  for the next event.</span><br><span class="line">                                   (default: 50)</span><br><span class="line">    --pipeline.unsafe_shutdown    Force logstash to exit during shutdown even</span><br><span class="line">                                  if there are still inflight events in memory.</span><br><span class="line">                                  By default, logstash will refuse to quit until all</span><br><span class="line">                                  received events have been pushed to the outputs.</span><br><span class="line">                                   (default: false)</span><br><span class="line">    --path.data PATH   数据存储目录。插件需要能访问该目录，默认安装目录下的data/</span><br><span class="line">    -p, --path.plugins PATH   插件目录，可指定多个Plugins are expected to be in a specific directory hierarchy:</span><br><span class="line">                                  &apos;PATH/logstash/TYPE/NAME.rb&apos; where TYPE is &apos;inputs&apos; &apos;filters&apos;, &apos;outputs&apos; or &apos;codecs&apos; and NAME is the name of the plugin.</span><br><span class="line">                                   (default: [])</span><br><span class="line">    -l PATH      指定Logstash的日志目录，默认安装目录下的logs/</span><br><span class="line">    --log.level LEVEL             设置日志等级（fatal/error/warn/info/debug/trace），默认info</span><br><span class="line">    --config.debug                Print the compiled config ruby code out as a debug log (you must also have --log.level=debug enabled).</span><br><span class="line">                                  WARNING: This will include any &apos;password&apos; options passed to plugin configs as plaintext, and may result</span><br><span class="line">                                  in plaintext passwords appearing in your logs!</span><br><span class="line">                                   (default: false)</span><br><span class="line">    -i, --interactive SHELL       Drop to shell instead of running as normal.</span><br><span class="line">                                  Valid shells are &quot;irb&quot; and &quot;pry&quot;</span><br><span class="line"></span><br><span class="line">    -t           检查logstash配置文件语法是否正常</span><br><span class="line">    -r           自动检测配置文件是否变动，若变动自动重载</span><br><span class="line">    --config.reload.interval RELOAD_INTERVAL How frequently to poll the configuration location</span><br><span class="line">                                  for changes, in seconds.</span><br><span class="line">                                   (default: 3000000000)</span><br><span class="line">    --http.host HTTP_HOST         Web API binding host (default: &quot;127.0.0.1&quot;)</span><br><span class="line">    --http.port HTTP_PORT         Web API http port (default: 9600..9700)</span><br><span class="line">    --log.format FORMAT           Specify if Logstash should write its own logs in JSON form (one</span><br><span class="line">                                  event per line) or in plain text (using Ruby&apos;s Object#inspect)</span><br><span class="line">                                   (default: &quot;plain&quot;)</span><br><span class="line">    --path.settings SETTINGS_DIR  包含logstash.yml的目录，可通过LS_SETTINGS_DIR环境变量配置</span><br><span class="line">    默认&quot;/usr/local/logstash6.4/config&quot;</span><br><span class="line">    --verbose 相当于设置日志等级为info</span><br><span class="line">    --debug   相当于设置日志等级为debug</span><br><span class="line">    --quiet   相当于设置日志等级为info</span><br></pre></td></tr></table></figure><h2 id="Logstash如何工作"><a href="#Logstash如何工作" class="headerlink" title="Logstash如何工作"></a>Logstash如何工作</h2><h3 id="关闭Logstash"><a href="#关闭Logstash" class="headerlink" title="关闭Logstash"></a>关闭Logstash</h3><p>可通过<code>systemctl stop logstash</code>或直接<code>kill</code>关闭。Logstash有自己关闭过程，以达到安全地关闭：</p><ul><li>首先停止所有的<code>input</code>、<code>filter</code>、<code>output</code>插件</li><li>处理完所有管道中的事件</li><li>最后关闭Logstash进程</li></ul><p>在处理过程中，以下的状况会影响关闭过程：</p><ul><li><code>input</code>插件以很慢的速度接收数据</li><li>速度慢的<code>filter</code>，如执行<code>sleep(10000)</code>的<code>Ruby filter</code>或执行非常繁重的查询的Elasticsearch过滤器。</li><li>一个断开连接的<code>output</code>插件，等待重新连接以刷新正在进行的事件。</li></ul><p>Logstash有一个停顿检测机制（stall detection），可以在关闭过程中分析管道和插件的行为。此机制会对内部队列中的飞行事件（in-flight events）数量和繁忙的worker线程列表定期生成信息报告。</p><p>若要在Logstash关闭阶段直接强行关闭，可在主配置文件中设置<code>pipeline.unsafe_shutdown</code>值为<code>true</code>，但这样可能造成数据丢失，不安全。</p><h2 id="Logstash配置文件"><a href="#Logstash配置文件" class="headerlink" title="Logstash配置文件"></a>Logstash配置文件</h2><h3 id="logstash-yml"><a href="#logstash-yml" class="headerlink" title="logstash.yml"></a>logstash.yml</h3><p>因为配置文件的语法是YAML，所以有两种写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pipeline:</span> </span><br><span class="line"><span class="attr">  batch:</span> </span><br><span class="line"><span class="attr">    size:</span> <span class="number">125</span></span><br><span class="line"><span class="attr">    delay:</span> <span class="number">50</span></span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line"><span class="string">pipeline.batch.size:</span> <span class="number">125</span></span><br><span class="line"><span class="string">pipeline.batch.delay:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><p>配置文件也支持<code>${}</code>引用变量</p><p>如果使用命令的<code>--modules</code>指定模块，则配置文件中所有配置的模块都会被忽略。</p><p>模块的配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">modules:</span> </span><br><span class="line"><span class="attr">  - name:</span> <span class="string">模块名</span></span><br><span class="line">    <span class="string">var.插件类型.插件名.键:</span> <span class="string">值</span></span><br></pre></td></tr></table></figure><p>所有配置参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">node.name             #节点名，默认为主机名</span><br><span class="line"></span><br><span class="line">#path参数</span><br><span class="line">path.data             #数据存放目录，默认为安装目录的data/</span><br><span class="line">path.config           #logstash.yml路径</span><br><span class="line">path.plugins          #插件的路径</span><br><span class="line">#插件应该位于特定的目录层次结构中：PATH/logstash/TYPE/NAME.rb</span><br><span class="line">#其中TYPE的值可以是inputs，filters，outputs或codecs，NAME是插件的名称</span><br><span class="line"></span><br><span class="line">#http参数</span><br><span class="line">http.port             #监听的http主机端口，默认为9600</span><br><span class="line">http.host             #监听的http主机IP，默认为127.0.0.1</span><br><span class="line"></span><br><span class="line">#日志log参数</span><br><span class="line">log.level             #日志等级（fatal/error/warn/info/debug/trace），默认info</span><br><span class="line">log.format            #日志格式，默认为plain格式</span><br><span class="line">path.logs             #日志的路径，默认安装目录的logs/</span><br><span class="line"></span><br><span class="line">#pipeline参数（关于pipeline的配置可专门存放在一个配置文件中，如pipeline.yml）</span><br><span class="line">pipeline.id           #pipeline的ID，默认为main</span><br><span class="line">pipeline.workers      #管道的worker数量，默认为CPU的核数</span><br><span class="line">pipeline.batch.size   #单个工作线程将从输入收集的最大事件数，默认125。增大此值会加大内存开销，还需调整JVM堆内存参数</span><br><span class="line">pipeline.batch.delay  #event被调度到worker前等待的时间，单位毫秒，默认50</span><br><span class="line">pipeline.unsafe_shutdown  #在关闭时立刻退出，会导致数据丢失。</span><br><span class="line">        #默认为false，完全退出前会将数据处理好并输出到屏幕再退出</span><br><span class="line"></span><br><span class="line">#config参数</span><br><span class="line">config.string         #pipeline配置</span><br><span class="line">config.test_and_exit  #检查配置是否有效，然后退出。默认为false不检查</span><br><span class="line">config.reload.automatic  #定期检查配置是否已更改，并在配置发生更改时重新加载配置。默认false不检查</span><br><span class="line">config.reload.interval  #检查配置是否变动的时间间隔，需要上一条开启。默认3s</span><br><span class="line">config.debug          #是否开启调试日志消息。若开启还需要将log.level的值设为debug。默认false</span><br><span class="line">                      #注：日志消息可能会包含明文密码</span><br><span class="line">config.support_escapes #是否开启转义字符，即启用\转义。默认false</span><br><span class="line"></span><br><span class="line">modules               #设置模块</span><br><span class="line"></span><br><span class="line">#queue参数</span><br><span class="line">queue.type            #用于事件缓冲的队列模型（model to use for event buffering），有以下两种，默认memory。</span><br><span class="line">       memory：传统基于内存的队列  persisted：基于磁盘的响应队列（disk-based ACKed queueing）</span><br><span class="line">path.queue            #启用持久队列（即上一项值为persisted）时存储数据文件的目录。默认data/queue</span><br><span class="line">queue.pagt_capacity   #启用持久队列时使用的页面数据文件的大小。默认64MB</span><br><span class="line">queue.max_events      #启用持久队列时队列中未读事件的最大数量。默认0，不限制</span><br><span class="line">queue.max_bytes       #队列的总容量，以字节数表示。确保磁盘容量大于此值。默认1G</span><br><span class="line">#若与上一项同时配置，则Logstash会加载先配置的一项</span><br><span class="line">queue.checkpoint.acks #启用持久队列时强制检查点之前的最大ACK响应事件数。默认1024，若设为0则不限制</span><br><span class="line">queue.checkpoint.writes #在启用持久队列时强制检查点之前写入事件的最大数量。默认1024，若设为0则不限制</span><br><span class="line">queue.drain           #启用后，Logstash将等待直到持久队列耗尽，然后才能关闭。默认false</span><br><span class="line"></span><br><span class="line">#dead_letter_queue参数</span><br><span class="line">dead_letter_queue.enable  #是否启用dead_letter_queue，简称DLQ功能。默认false不启用</span><br><span class="line">dead_letter_queue.max_bytes #每个DLQ的最大大小。超出就会删除条目，默认1G</span><br><span class="line">path.dead_letter_queue #DLQ目录的位置，默认为安装目录的data/dead_letter_queue</span><br></pre></td></tr></table></figure><h3 id="自定义Logstash配置文件"><a href="#自定义Logstash配置文件" class="headerlink" title="自定义Logstash配置文件"></a>自定义Logstash配置文件</h3><p>自定义的配置文件主要用于指定<code>input</code>、<code>filter</code>、<code>output</code>插件等管道参数。</p><p>配置文件支持的值类型：</p><ul><li><p>列表Lists：<code>[ ]</code>中包含多个值。如<code>path =&gt; [&#39;XXX&#39;,&#39;XXX&#39;]</code></p></li><li><p>布尔值Boolean：指定<code>true</code>或<code>false</code></p></li><li><p>字节Bytes：是字符串字段，表示有效的字节单位。支持<code>SI</code>（k M G T P E Z Y）和二进制（<code>binary</code>）（Ki Mi Gi Ti Pi Ei Zi Yi）单位。二进制单位基数为1024，SI单位基数为1000。此字段不区分大小写，并接受值和单位之间的空格。</p></li><li><p>编解码器codec：表示数据的Logstash编解码器的名称。编解码器可用于输入和输出。例：<code>codec =&gt; json</code></p><ul><li><p>输入编解码器提供了一种在数据<strong>进入输入之前对其进行解码</strong>的便捷方式。</p></li><li><p>输出编解码器提供了一种在数据<strong>离开输出之前对数据进行编码</strong>的便捷方式。</p></li><li><p>使用输入或输出编解码器无需在Logstash管道中使用单独的过滤器。</p></li></ul></li><li><p>哈希Hash：键值对集合，多条键值对间使用空格间隔，而不是逗号</p></li><li><p>数字Number：数字必须为浮点型或整型</p></li><li><p>密码Password：密码必须是一个字符串，且该字符串应未被记录或打印</p></li><li><p>URI：可以是完整的URL，也可以是类似邮件地址，如<code>user:pass@XXX.net</code>，如果URI包含密码，则不会记录或打印URI的密码部分</p></li><li><p>路径Path：表示有效操作系统路径的字符串</p></li><li><p>字符串String：必须用引号括住，可以是单引号或双引号</p></li><li><p>转义序列Escape Sequences：默认不启用转义序列。如果要在字符串中使用转义字符，需要在<code>logstash.yml</code>中设置<code>config.support_escapes：true</code>。</p></li></ul><h2 id="Logstash日志"><a href="#Logstash日志" class="headerlink" title="Logstash日志"></a>Logstash日志</h2><p>Logstash的日志存放在<code>LS_HOME/logs</code>中，默认日志等级为<code>INFO</code>， Logstash的日志框架基于<code>Log4j 2</code>框架，其大部分功能直接暴露给用户。</p><p>在调试问题时，尤其是插件问题时，一般将日志记录级别增加到<code>DEBUG</code>以获取更详细的消息。从5.0版本开始，可以在Logstash中配置特定日志子系统的日志记录。</p><p>Logstash提供一个带有开箱即用设置的<code>log4j2.properties</code>文件，可以更改轮换策略，类型和其他log4j2配置。需要重启Logstash以应用该配置。</p><p>慢日志（Slowlog）用于报告在通过管道（pipeline）时花费不正常时间的事件的日志消息。慢日志同样存放在<code>LS_HOME/logs</code>中。可在主配置文件中添加slowlog的配置，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">slowlog.threshold.warn:</span> <span class="number">2</span><span class="string">s</span></span><br><span class="line"><span class="string">slowlog.threshold.info:</span> <span class="number">1</span><span class="string">s</span></span><br><span class="line"><span class="string">slowlog.threshold.debug:</span> <span class="number">500</span><span class="string">ms</span></span><br><span class="line"><span class="string">slowlog.threshold.trace:</span> <span class="number">100</span><span class="string">ms</span></span><br></pre></td></tr></table></figure><p>以上配置指定了触发慢日志的条件。在过滤器中处理超过100ms的事件会在慢日志中记录为trace等级的事件，超过2秒的事件会记录为等级为warn的事件</p><p>可通过<code>curl -X GET localhost:9600/_node/logging?pretty</code>获取关于日志的信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9600/_node/logging?pretty</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"host"</span> : <span class="string">"VM_0_7_centos"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : <span class="string">"6.4.1"</span>,</span><br><span class="line">  <span class="attr">"http_address"</span> : <span class="string">"127.0.0.1:9600"</span>,</span><br><span class="line">  <span class="attr">"id"</span> : <span class="string">"07b4b966-d732-4263-bc16-1efc6e927e1c"</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"VM_0_7_centos"</span>,</span><br><span class="line">  "loggers" : &#123;             #显示的是日志子系统以及日志等级</span><br><span class="line">    "logstash.agent" : "INFO",</span><br><span class="line">    "logstash.api.service" : "INFO",</span><br><span class="line">    "logstash.codecs.line" : "INFO",</span><br><span class="line">    "logstash.codecs.rubydebug" : "INFO",</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可通过<code>curl -X PUT localhost:9600/_node/logging?pretty -H &#39;Content-Type: application/json&#39; -d &#39;{...}&#39;</code>动态设置指定日志子系统的日志等级。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT &apos;localhost:9600/_node/logging?pretty&apos; -H &apos;Content-Type: application/json&apos; -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;logger.logstash.outputs.elasticsearch&quot; : &quot;DEBUG&quot;</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>则会在<code>log4j2.properties</code>配置中自动添加上该指定配置。若要重置已通过日志记录API动态更改的任何日志记录级别，需要通过将PUT请求发送到<code>_node/logging/reset</code>将所有日志记录级别都恢复为<code>log4j2.properties</code>文件中指定的值</p><p><code>curl -X PUT localhost:9600/_node/logging/reset?pretty</code></p><p>将其他任意日志导入Logstash的操作：编写一个pipeline配置文件<code>test.conf</code>，或直接在<code>pipeline.yml</code>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input &#123;        #设置input参数</span><br><span class="line">  file &#123;</span><br><span class="line">    #通过列表添加两个日志</span><br><span class="line">    path =&gt; [&apos;/var/log/httpd/access_log&apos;,&apos;/var/log/squid/access.log&apos;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;        #标准输出，一定要加，否则无法输出到屏幕</span><br><span class="line">  stdout &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动Logstash，<code>bin/logstash -f config/test.conf</code>。会不断获取httpd和squid的日志消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">          &quot;path&quot; =&gt; &quot;/var/log/httpd/access_log&quot;,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;127.0.0.1 - - [02/Oct/2018:16:11:16 +0800] \&quot;GET / HTTP/1.0\&quot; 200 10 \&quot;-\&quot; \&quot;ApacheBench/2.3\&quot;&quot;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2018-10-02T08:11:20.344Z,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;VM_0_7_centos&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">          &quot;path&quot; =&gt; &quot;/var/log/squid/access.log&quot;,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;1538467887.306    656 180.126.242.119 TCP_TUNNEL/200 33103 CONNECT xui.ptlogin2.qq.com:443 - HIER_DIRECT/xui.ptlogin2.qq.com -&quot;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2018-10-02T08:11:27.355Z,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;VM_0_7_centos&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若要将elasticsearch的日志都再导入elasticsearch，可进行以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  file &#123;</span><br><span class="line">    path =&gt; &apos;/usr/local/es-6.4/logs/elasticsearch.log&apos;</span><br><span class="line">    type =&gt; &apos;elasticsearch&apos;</span><br><span class="line">    start_position =&gt; &apos;beginning&apos;   #从日志的头开始读</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123;          #使用elasticsearch插件</span><br><span class="line">    hosts =&gt; &apos;127.0.0.1:9200&apos;   #指定elasticsearch源</span><br><span class="line">    index =&gt; &apos;es_message-%&#123;+YYYY.MM.dd&#125;&apos;  #指定index</span><br><span class="line">  &#125;</span><br><span class="line">  stdout&#123;</span><br><span class="line">    codec =&gt; rubydebug</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动Logstash就会显示已导入elasticsearch的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">          &quot;type&quot; =&gt; &quot;elasticsearch&quot;,</span><br><span class="line">       &quot;message&quot; =&gt; &quot;[2018-10-03T16:06:50,392][INFO ][o.e.c.m.MetaDataMappingService] [system135] [.kibana/PnIK501cQUydUEIVp0icjw] update_mapping [doc]&quot;,</span><br><span class="line">    &quot;@timestamp&quot; =&gt; 2018-10-03T08:06:50.560Z,</span><br><span class="line">      &quot;@version&quot; =&gt; &quot;1&quot;,</span><br><span class="line">          &quot;host&quot; =&gt; &quot;system5.example.com&quot;,</span><br><span class="line">          &quot;path&quot; =&gt; &quot;/usr/local/es-6.4/logs/elasticsearch.log&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Logstash常用插件"><a href="#Logstash常用插件" class="headerlink" title="Logstash常用插件"></a>Logstash常用插件</h2><p>默认的Logstash安装包括Beats输入插件。 Beats输入插件使Logstash能够从Elastic Beats框架接收事件，任何与Beats框架一起使用的Beat（如Packetbeat和Metricbeat），也可以将事件数据发送到Logstash。</p><ul><li><code>Grok</code>：是Logstash过滤器的基础，用于从非结构化数据中获取结构，具有丰富的集成模式，能快速处理Web，系统，网络和其他类型的事件格式。</li><li><code>Codecs</code>：通常用于简化对JSON和多行事件等常见事件结构的处理。</li></ul><h1 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h1><p>Kibana是一个开源分析和可视化平台，旨在与Elasticsearch协同工作。可使用Kibana搜索，查看以及与存储在Elasticsearch索引中的数据进行交互，可以轻松地执行高级数据分析，并在各种图表（charts），表格（tables）和地图（maps）中可视化数据。</p><p>Kibana是基于JS的WEB界面，在Node.js上运行，而官方在Kibana包中包含了必要的Node.js二进制文件，并且不支持针对单独维护的Node.js版本运行Kibana，因此不需要单独搭建Nodejs环境。</p><p>应将Kibana配置为针对相同版本的Elasticsearch节点运行，即版本要一致。</p><p>注：从V6.0.0开始，Kibana仅支持64位操作系统。</p><h2 id="Kibana安装"><a href="#Kibana安装" class="headerlink" title="Kibana安装"></a>Kibana安装</h2><p>下载Kibana包，版本为6.4.1，解压到<code>/usr/local/kibana6.4</code></p><p>kibana需要elasticsearch的开启才能正常使用，否则启动kibana会不断报错，进入Kibana后也会提示status为red，无法正常使用，因此需要先启动elasticsearch。开启后，进入kibana目录下<code>bin</code>执行<code>kibana</code>命令。需要等待一段时间直到出现信息<code>[info][listening][server][http] Server running at http://localhost:5601</code>。通过浏览器<code>localhost:5601</code>访问kibana。</p><p>注：内存或CPU不足会将Elasticsearch杀死，Kibana也就无法启动</p><p>Kibana的文件结构：除了<code>bin</code>、<code>config</code>、<code>data</code>、<code>plugins</code>，kibana还有以下目录：</p><ul><li><code>node</code>：</li><li><code>node_modules</code></li><li><code>optimize</code>：存放透明的源代码。某些管理操作（例如，插件安装）导致源代码在运行中被重新传输。</li><li><code>src</code></li><li><code>webpackShims</code></li></ul><p>可在浏览器访问<code>localhost:5601/status</code>查看kibana是否启动正常，插件是否加载正常，以及kibana的当前信息。</p><h2 id="启动时Kibana信息处理"><a href="#启动时Kibana信息处理" class="headerlink" title="启动时Kibana信息处理"></a>启动时Kibana信息处理</h2><h3 id="warning消息"><a href="#warning消息" class="headerlink" title="warning消息"></a>warning消息</h3><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[warning][security] Generating a random key for xpack.security.encryptionKey. </span><br><span class="line">To prevent sessions from being invalidated on restart, </span><br><span class="line">please set xpack.security.encryptionKey in kibana.yml</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[warning][security] Session cookies will be transmitted over insecure connections. This is not recommended.</span><br></pre></td></tr></table></figure></li><li></li></ol><h2 id="Kibana配置"><a href="#Kibana配置" class="headerlink" title="Kibana配置"></a>Kibana配置</h2><p>Kibana只有一个配置文件<code>KIBANA_HOME/config/kibana.yml</code>。默认运行在localhost的5601端口。</p><p>常见配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server.port: 5601          #Kibana服务端口</span><br><span class="line">server.host: &quot;localhost&quot;   #向哪些主机开放端口，若要所有主机都能访问，即客户端能远程访问，需要设为0.0.0.0</span><br><span class="line">server.name: &quot;your-hostname&quot; #Kibana实例名，一般为主机名</span><br><span class="line">server.basePath: &quot;&quot;        #</span><br><span class="line">server.maxPayloadBytes: 1048576</span><br><span class="line">server.rewriteBasePath: false</span><br><span class="line"></span><br><span class="line">elasticsearch.url: &quot;http://localhost:9200&quot;  #Elasticsearch的地址，需要设置正确</span><br><span class="line">elasticsearch.preserveHost: true</span><br><span class="line">kibana.index: &quot;.kibana&quot;</span><br><span class="line">kibana.defaultAppId: &quot;home&quot;</span><br><span class="line">#elasticsearch.username: &quot;user&quot;           #设置es授权用户名</span><br><span class="line">#elasticsearch.password: &quot;pass&quot;           #设置es授权用户密码</span><br><span class="line">#server.ssl.enabled: false                #是否开启ssl</span><br><span class="line">#server.ssl.certificate: /path/to/your/server.crt</span><br><span class="line">#server.ssl.key: /path/to/your/server.key</span><br><span class="line">#elasticsearch.ssl.certificate: /path/to/your/client.crt</span><br><span class="line">#elasticsearch.ssl.key: /path/to/your/client.key</span><br></pre></td></tr></table></figure><h2 id="Kibana基本功能"><a href="#Kibana基本功能" class="headerlink" title="Kibana基本功能"></a>Kibana基本功能</h2><h3 id="添加index的管理"><a href="#添加index的管理" class="headerlink" title="添加index的管理"></a>添加index的管理</h3><p>首先要在elasticsearch添加index数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -H &quot;Content-Type: application/json&quot; localhost:9200/tech/employee/1 -d &apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;zhangsan&quot;,</span><br><span class="line">  &quot;age&quot;: &quot;25&quot;,</span><br><span class="line">  &quot;address&quot;: &quot;nanjing&quot;,</span><br><span class="line">  &quot;hobby&quot;: [ &quot;football&quot;, &quot;tennis&quot;, &quot;game&quot; ]</span><br><span class="line">&#125;&apos;</span><br></pre></td></tr></table></figure><p>然后刷新kibana，进入Management中的Kibana，选Index pattern，并创建。</p><img src="/2018/09/24/ELK与EFK详细笔记/5.png"><img src="/2018/09/24/ELK与EFK详细笔记/6.png"><img src="/2018/09/24/ELK与EFK详细笔记/7.png"><p>创建完成后，进入Discover菜单，可查看插入的数据</p><img src="/2018/09/24/ELK与EFK详细笔记/8.png"><h3 id="使用kibana提供的数据进行分析"><a href="#使用kibana提供的数据进行分析" class="headerlink" title="使用kibana提供的数据进行分析"></a>使用kibana提供的数据进行分析</h3><p>从<a href="https://www.elastic.co/guide/en/kibana/current/tutorial-load-dataset.html" target="_blank" rel="noopener">kibana文档</a>中下载数据，可选择银行账户数据account.json，下载以后使用<code>curl -H &#39;Content-Type: application/x-ndjson&#39; -XPOST &#39;localhost:9200/bank/account/_bulk?pretty&#39; --data-binary @accounts.json</code>导入elasticsearch。开启kibana，进入Management添加index pattern，然后进入Discover菜单，选择bank，添加要看的字段。</p><img src="/2018/09/24/ELK与EFK详细笔记/10.png"><p>为数据创建报表，进入Visualize菜单，可根据需要选择报表形式，此处选Pie饼图，然后再选择bank即可进入定制界面。</p><img src="/2018/09/24/ELK与EFK详细笔记/11.png"><img src="/2018/09/24/ELK与EFK详细笔记/12.png"><p>选择split slices，然后在聚合（aggregation）中选择range，然后进行自定义数据范围</p><img src="/2018/09/24/ELK与EFK详细笔记/13.png"><img src="/2018/09/24/ELK与EFK详细笔记/14.png"><h1 id="ELK架构"><a href="#ELK架构" class="headerlink" title="ELK架构"></a>ELK架构</h1><p>若环境的内存少，就在es配置文件添加以下配置</p><p>bootstrap.memory_lock: false      为避免内存与磁盘间的swap，会损耗大量性能</p><p>bootstrap.system_call_filter: false</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">全文搜索引擎 Elasticsearch 入门教程</a></li><li>每天5分中玩转docker容器技术</li><li><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/index.html" target="_blank" rel="noopener">Elasticsearch: 权威指南</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/getting-started.html" target="_blank" rel="noopener">Elasticsearch官方文档</a></li><li><a href="https://blog.csdn.net/chenleiking/article/details/73563930" target="_blank" rel="noopener">Logstash简单介绍</a></li><li><a href="https://blog.csdn.net/iguyue/article/details/77006201" target="_blank" rel="noopener">ELK 之 Logstash</a></li><li><a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">Logstash官方文档</a></li><li><a href="https://www.cnblogs.com/duanxz/p/6528161.html" target="_blank" rel="noopener">ES之五：ElasticSearch聚合</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
            <tag> Elasticsearch </tag>
            
            <tag> ELK </tag>
            
            <tag> EFK </tag>
            
            <tag> Kibana </tag>
            
            <tag> Logstash </tag>
            
            <tag> 搜索 </tag>
            
            <tag> 日志 </tag>
            
            <tag> Fluentd </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>重学数据结构与算法笔记</title>
      <link href="/2018/09/15/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/15/%E9%87%8D%E5%AD%A6%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Neural-style试玩环境搭建</title>
      <link href="/2018/09/15/Neural-style%E8%AF%95%E7%8E%A9%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/09/15/Neural-style%E8%AF%95%E7%8E%A9%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Cacti监控学习</title>
      <link href="/2018/09/15/Cacti%E7%9B%91%E6%8E%A7%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/09/15/Cacti%E7%9B%91%E6%8E%A7%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>本篇笔记包含以下内容：</p><ul><li><a href="#Cacti原理与安装">Cacti原理与安装</a></li><li><a href="#Cacti常用操作">Cacti常用操作</a></li></ul><a id="more"></a><h1 id="Cacti原理与安装"><a href="#Cacti原理与安装" class="headerlink" title="Cacti原理与安装"></a>Cacti原理与安装</h1><p>Cacti是一套基于PHP，MySQL，SNMP及RRDTool开发的网络流量监测图形分析工具。使用SNMP服务获取数据，用rrdtool存储和更新数据，并可以使用rrdtool生成图表。因此SNMP和RRDtool是Cacti的关键。注意，<strong>Cacti仅仅是一个展示工具，是一个PHP网页，真正实现数据收集以及绘图的是SNMP和RRDtool。</strong></p><p>MySQL与PHP用来存储一些变量数据并对变量进行调用，如主机名、主机IP、Snmp团体名、端口号、模板信息等，Snmp抓取的数据并不存放在MySQL中，而是存放在rrdtool生成的RRD文件中，rrdtool对数据的更新和存储就是对RRD文件的处理，RRD文件是大小固定的档案文件，能存储的数据量在创建时就被定义好了。</p><img src="/2018/09/15/Cacti监控学习/1.png"><p><strong>Cacti特点：</strong></p><ul><li>提供图形化页面操作实现<code>rrdtool create</code>命令</li><li>周期性执行能取得数据的命令，并将取回的数据存储在rrd文件中</li><li>通过rrdtool绘图并展示</li><li>强大的用户管理机制</li><li>丰富的插件库，如thold，并提供插件框架允许自定义模板</li></ul><p>Cacti模板分为三类：</p><ul><li>图形模板：定义图形的绘制</li><li>数据模板：定义如何获得数据，如何保存数据</li><li>主机模板：就是分好类的图形模板和数据模板，可直接应用于一个或一类主机</li></ul><p><strong>SNMP简介</strong></p><p>Simple Network Management Protocol简单网络管理协议，由一组网络管理的标准组成，包含一个应用层协议、数据库模型（database schema）和一组资源对象。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</p><p>SNMP管理的网络主要由三部分组成：</p><ul><li>被管理的设备</li><li>SNMP代理（Agent）</li><li>网络管理系统（NMS）</li></ul><p>三部分之间的关系：</p><ul><li>网络中被管理的每一个设备都存在一个管理信息库（MIB）用于收集并储存管理信息。通过SNMP协议，NMS能获取这些信息。被管理设备，又称为网络单元或网络节点，可以是支持SNMP协议的路由器、交换机、服务器或者主机等等。</li><li>SNMP代理是被管理设备上的一个网络管理软件模块，拥有本地设备的相关管理信息，并用于将它们转换成与SNMP兼容的格式，传递给NMS。</li><li>NMS运行应用程序来实现监控被管理设备的功能。另外，NMS还为网络管理提供大量的处理程序及必须的储存资源。</li></ul><blockquote><p>上述资料引用自百度百科snmp</p></blockquote><p><strong>RRDtool简介</strong></p><p>Round Robin Database Tool轮询式数据库工具，是一个强大的绘图的引擎。其中，<code>Round Robin</code>是一种存储数据的方式，使用固定大小的空间来存储数据，并有一个指针指向最新的数据的位置。RRDtool针对处理的是时序型数据(time-series data)，比如网络带宽，温度，CPU负载等等这些和时间相关联的数据或者说指标。</p><blockquote><p> 上述资料引用自百度百科rrdtool和<a href="https://www.cnblogs.com/yaoyao-start/p/5122289.html" target="_blank" rel="noopener">RRDtool入门详解</a></p></blockquote><h2 id="Cacti安装"><a href="#Cacti安装" class="headerlink" title="Cacti安装"></a>Cacti安装</h2><p>首先需要搭建LAMP环境<code>yum install httpd php php-devel php-gd gd gd-devel gcc glibc openssl* mariadb* zlib* php-xml libxml libjpeg libpng freetype cairo-devel pango-devel</code></p><blockquote><p>cairo是一个2D图形库</p><p>Pango是一个用于布局和呈现文本的库</p><p>gd也是一个图形库，用于动态生成图片</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install net-snmp \</span><br><span class="line">            net-snmp-devel \</span><br><span class="line">            net-snmp-utils \</span><br><span class="line">            lm_sensors \</span><br><span class="line">            rrdtool*</span><br></pre></td></tr></table></figure><p>安装snmp主程序及相关监控工具。<code>net-snmp</code>会提供两个命令<code>snmpwalk</code>和<code>snmpget</code></p><blockquote><p> <code>lm_sensors</code>：是一款基于linux系统的硬件监控的软件。可以监控主板，CPU的工作电压，温度等数据。</p></blockquote><p>开启<code>snmpd</code>和<code>snmptrapd</code>服务<code>systemctl start snmpd snmptrapd</code></p><p>修改snmp配置文件<code>/etc/snmp/snmpd.conf</code>，找到<code>com2sec notConfigUser default public</code>一行，复制到下一行并修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com2sec  myuser  127.0.0.1  mycommunity</span><br><span class="line"># 127.0.0.1可配置为要监控的主机或网段</span><br></pre></td></tr></table></figure><p>找到下面的group配置，同样复制一行并修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group  mygroup  v2c  myuser</span><br></pre></td></tr></table></figure><p>再下面，找到view配置，添加一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">view    all     included   .1</span><br></pre></td></tr></table></figure><p>保存并重启snmpd服务。执行<code>snmpwalk -c mycommunity 127.0.0.1 -v2c</code>可看到大量信息。</p><p>注：如果是被监控主机，只需要安装<code>net-snmp</code>和<code>lm_sensors</code>即可。</p><p>cacti安装完成后，会在<code>/etc/httpd/conf.d/</code>中生成一个<code>cacti.conf</code>配置文件，可以不用改动，文件中指定的网页存储位置为<code>/usr/share/cacti/</code>，该目录中存放着所有php网页。</p><p>cacti的sql数据存放在<code>/usr/share/doc/cacti/cacti.sql</code>需要导入数据库。首先要进入mariadb，创建数据库<code>cactidb</code>，退出后，<code>mysql -u root -p cactidb &lt; /usr/share/doc/cacti/cacti.sql</code>导入数据库。</p><p>在数据库中创建用户管理<code>cactidb</code>，进入数据库<code>grant all on cactidb.* to cactiadmin@localhost identified by &quot;cactiadmin&quot;;</code>并<code>flush privileges;</code></p><p>设置httpd虚拟主机，使用户通过<code>cacti.example.com</code>直接访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">  ServerName cacti.example.com</span><br><span class="line">  DocumentRoot &quot;/usr/share/cacti&quot;</span><br><span class="line">  ErrorLog &quot;log/cacti-access.log&quot;</span><br><span class="line">  CustomLog &quot;log/cacti-error.log&quot; common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">&lt;Directory &quot;/usr/share/cacti&quot;&gt;</span><br><span class="line">  Require all granted</span><br><span class="line">  Options Indexes</span><br><span class="line">  AllowOverride None</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>修改管理Cacti的配置文件<code>/usr/share/cacti/include/config.php</code>，修改以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$database_default  = &apos;cactidb&apos;;       设置数据库名</span><br><span class="line">$database_username = &apos;cactiadmin&apos;;    设置数据库中cacti用户名</span><br><span class="line">$database_password = &apos;cactiadmin&apos;;    设置数据库中cacti用户密码</span><br><span class="line">$url_path = &apos;/&apos;;     网页访问的路径，可改可不改，若不改就是通过http://localhost/cacti访问</span><br></pre></td></tr></table></figure><p>创建普通用户用于周期性执行获取数据的php脚本，因为为了安全性，不能让管理员执行。<code>useradd cactiuser</code>，并且将<code>cacti</code>目录中<code>log</code>和<code>rra</code>目录的所属人和所属组都改为<code>cactiuser</code>，<code>chown -R cactiuser:cactiuser /usr/share/cacti/log /usr/share/cacti/rra</code></p><p>至此，安装配置完毕，重启Apache，浏览器输入<code>cacti.example.com</code>访问，开始网页配置。</p><p>若遇到以下报错：</p><img src="/2018/09/15/Cacti监控学习/2.png"><p>说明cacti数据库管理员<code>cactiadmin</code>没有对<code>mysql.time_zone_name</code>表的<code>select</code>权限，需要授权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant select on mysql.time_zone_name to cactiadmin@localhost;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>并且要修改<code>/etc/my.cnf</code>配置，在<code>[mysqld]</code>下添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-time-zone = &apos;+8:00&apos;</span><br></pre></td></tr></table></figure><p>重启并进入mysql，使用命令验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show variables like &apos;%time_zone%&apos;;   </span><br><span class="line">+------------------+--------+</span><br><span class="line">| Variable_name    | Value  |</span><br><span class="line">+------------------+--------+</span><br><span class="line">| system_time_zone | CST    |</span><br><span class="line">| time_zone        | +08:00 |</span><br><span class="line">+------------------+--------+</span><br></pre></td></tr></table></figure><p><strong>退出MySQL，使用命令<code>mysql_tzinfo_to_sql tz_file tz_name | mysql -u root -p mysql</code></strong></p><p><code>tz_file</code>指timezone文件，存放在<code>/usr/share/zoneinfo</code>中</p><p>执行<code>mysql_tzinfo_to_sql /usr/share/zoneinfo/Asia/Shanghai Shanghai | mysql -u root -p mysql</code> </p><img src="/2018/09/15/Cacti监控学习/3.png"><p>说明php的timezone没设置，修改<code>/etc/php.ini</code>，把<code>;date.timezone =</code>注释去除，设置为<code>date.timezone = Asia/Shanghai</code>。<a href="http://www.php.net/manual/zh/timezones.php" target="_blank" rel="noopener">支持的时区表</a></p><img src="/2018/09/15/Cacti监控学习/4.png"><p>网页下拉还有类似的问题，需要修改mysql表中相应参数。修改<code>/etc/my.cnf</code>文件，在<code>[mysqld]</code>下添加报错项，只要满足即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">max_heap_table_size=2048M</span><br><span class="line">tmp_table_size=2048M</span><br><span class="line">join_buffer_size=2048M</span><br><span class="line">innodb_buffer_pool_size=2048M</span><br><span class="line">innodb_doublewrite=off</span><br><span class="line">innodb_flush_log_at_timeout=10</span><br><span class="line">innodb_read_io_threads=32</span><br><span class="line">innodb_write_io_threads=16</span><br></pre></td></tr></table></figure><p>修改完后重启php和mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mariadb.service </span><br><span class="line">systemctl restart php-fpm.service</span><br></pre></td></tr></table></figure><p>重新访问<code>cacti.example.com</code>。进入安装选项页面：</p><img src="/2018/09/15/Cacti监控学习/5.png"><p>有两种选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">New Primary Server：若是主节点就选这项</span><br><span class="line">New Remote Poller：若是用于收集主节点无法访问的服务器的信息，就选这项</span><br></pre></td></tr></table></figure><img src="/2018/09/15/Cacti监控学习/6.png"><p>Cacti的各个路径已自动设置好。由于Spine还没有安装，所以会提示错误，但不影响安装。</p><img src="/2018/09/15/Cacti监控学习/7.png"><p>安装模板，若为Linux或unix主机，必选<code>Local Linux Machine</code>，若为Windows主机，必选<code>Windows Device</code>。</p><img src="/2018/09/15/Cacti监控学习/8.png"><p>用户登录界面，初始的管理员用户名和密码都是<code>admin</code>，登陆后会强制要求更改。</p><p><strong>密码设置有几个条件必须满足：</strong></p><ul><li>大于8位</li><li>含有字母大小写</li><li>至少包含一个数字</li><li>至少包含一个特殊字符</li></ul><blockquote><p><strong>若想绕过这些规则，可直接进入mysql的cactidb库，执行<code>update user_auth set password = md5(&quot;密码&quot;) where username=&quot;admin&quot;;</code></strong></p></blockquote><p>然后就进入了cacti主界面。</p><img src="/2018/09/15/Cacti监控学习/9.png"><p>查看Graph页面，出现以下报错：</p><img src="/2018/09/15/Cacti监控学习/10.png"><p>是因为没有运行<code>/usr/share/cacti/poller.php</code>，这个是cacti自带的脚本，用于收集数据，并生成图表。默认cacti每5分钟收集一次信息，所以要设置定时，每五分钟运行该脚本。而cacti安装后已生成一个文件<code>/etc/cron.d/cacti</code>，内容如下：若带有注释，就将注释去除，并要修改用户名。需要确定<code>crond</code>服务是否启动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * cactiuser /usr/bin/php /usr/share/cacti/poller.php &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>最好通过<code>crontab -e -u cactiuser</code>输入<code>*/5 * * * *  /usr/bin/php /usr/share/cacti/poller.php &gt; /dev/null 2&gt;&amp;1</code>设置cron。</p><p>先手动执行一次<code>php /usr/share/cacti/poller.php &gt; /dev/null 2&gt;&amp;1</code>，可通过查看<code>/var/log/cacti/cacti.log</code>确认是否能获取数据。然后查看<code>/usr/share/cacti/rra/</code>是否有rrd文件。然后重启httpd，访问cacti的Graph。</p><p>有可能没有启动的原因是系统时间和BIOS时间不符，通过<code>hwclock -s</code>同步。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li>Cacti实战</li><li>Linux运维之道（第二版）</li><li>高性能网站构建实战</li><li><a href="https://www.cnblogs.com/nov5026/p/7486091.html" target="_blank" rel="noopener">Cacti完全使用手册 ( 让你快速个性化使用Cacti )</a></li><li><a href="http://blog.51cto.com/13555423/2068654" target="_blank" rel="noopener">服务器监控系统cacti</a></li><li><a href="http://www.tianfeiyu.com/?p=1620" target="_blank" rel="noopener">cacti安装与配置</a></li><li><a href="https://linux.cn/article-5746-1.html" target="_blank" rel="noopener">使用 SNMP 和 Cacti 监控 Linux 服务器 </a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> Cacti </tag>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQLite学习笔记</title>
      <link href="/2018/09/07/SQLite%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/07/SQLite%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容：</p><ul><li><a href="">SQLite介绍与安装</a></li><li>[]</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQLite </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cuda环境搭建</title>
      <link href="/2018/08/16/Cuda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/16/Cuda%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>CUDA为</p><h2 id="CUDA搭建"><a href="#CUDA搭建" class="headerlink" title="CUDA搭建"></a>CUDA搭建</h2><p>CUDA环境搭建大致需要以下步骤：</p><ul><li>Nvidia显卡驱动安装</li><li>CUDA安装</li><li>cuDNN安装</li></ul><a id="more"></a><h3 id="Nvidia驱动安装"><a href="#Nvidia驱动安装" class="headerlink" title="Nvidia驱动安装"></a>Nvidia驱动安装</h3><p>首先卸载现有的驱动（如果不是最新的话）</p><p><code>sudo apt-get remove nvidia*</code></p><p>自动安装Nvidia最新驱动</p><p><code>sudo apt-get install bumblebee-nvidia nvidia-driver nvidia-settings</code></p><p>其中：<code>nvidia-driver</code>对应了最新的Nvidia驱动，<code>bumblebee-nvidia</code>为Nvidia的大黄蜂模式驱动，用于双显卡智能切换。</p><p>安装Nvidia的系统管理界面<code>Nvidia-smi</code></p><p><code>sudo apt-get install nvidia-smi</code></p><p>使用<code>nvidia-smi</code>查看显卡详细信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
            <tag> Nvidia </tag>
            
            <tag> 人工智能 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IS-IS学习笔记</title>
      <link href="/2018/08/05/IS-IS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/05/IS-IS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>基于华三网络学习笔记</strong></p><p>本篇主要包含以下内容：</p><ul><li><a href="OSI地址">OSI地址</a></li><li><a href="IS-IS概述">IS-IS概述</a></li><li><a href="#IS-IS实现">IS-IS实现</a></li></ul><a id="more"></a><h2 id="OSI地址"><a href="#OSI地址" class="headerlink" title="OSI地址"></a>OSI地址</h2><p>在OSI协议体系中，OSI地址标识了一台支持OSI协议的设备。IS-IS的报文封装在数据链路层，采用OSI报文格式，包含OSI地址。IS-IS协议将ISO网络层地址称NSAP。IS-IS用OSI地址标识不同IS，并构建网络拓扑数据库，计算到达各节点的最短路径树。</p><p>OSI地址使用的是NASP（Network Service Access Point网络服务接入点）地址格式，是IP地址和上层协议号的组合，用于标识设备和设备启用的服务。</p><p>NASP由IDP（Initial Domian Part初始域部分）和DSP（Domain Specific Part域指定部分），IDP表示IP地址的主网络号，DSP表示IP地址的子网号和主机地址。IDP和DSP长度是可变的，但NASP的总长最多为20字节，最少8字节。</p><p>在IS-IS中，NASP地址被分为3部分：可变长区域地址，System ID，NSEL。</p><img src="/2018/08/05/IS-IS学习笔记/1.png"><p>System ID用于在区域中唯一表示主机或服务器，一般会由Router ID转换得出。</p><blockquote><p> 转换方法：Router ID的每部分都扩展为3位数字，不足则在前补零，将扩展后的地址重新划分为3部分，每部分4个数字，得到System ID</p></blockquote><p>NSEL类似于协议标识符，当协议为IP时，NSEL均为00。</p><p>路由器只需配置一个区域地址，但最多可以配置3个，同一区域中所有节点的区域地址都相同。</p><p>NET（Network Entity Title网络实体名称）指示的是IS本身的网络层信息，不包括传输层信息，可看做NSEL为0的特殊的NASP。一台路由器只需配置一个NET，最多3个，若配置多个NET，则必须保证System ID相同。NET除了可以通过Router ID转换变得，也可通过MAC地址转换变得，但MAC地址由于具有全局性，一个区域内的路由器的MAC没有规律，管理不方便，所以一般还是用Router ID映射。</p><h2 id="IS-IS概述"><a href="#IS-IS概述" class="headerlink" title="IS-IS概述"></a>IS-IS概述</h2><p>IS-IS（Intermediate System-to-Intermediate System，中间系统到中间系统）是ISO为CLNP（Connection Less Network Protocol，无连接网络协议）设计的一种动态路由协议。IS-IS能够同时应用在TCP/IP和OSI环境中，形成了集成化IS-IS。采用TLV架构，易于扩展。</p><p>IS-IS属于内部网关路由协议，用于自治系统内部。IS-IS是一种链路状态协议，与TCP/IP网络中的OSPF协议非常相似，使用最短路径优先算法SPF进行路由计算。</p><h3 id="IS-IS常见术语："><a href="#IS-IS常见术语：" class="headerlink" title="IS-IS常见术语："></a>IS-IS常见术语：</h3><p>区域（Area）：路由域的细分单元，IS-IS允许将整个路由域分为多个区域</p><p>路由域（Routing  Domain）：较大的区域，可包含多个区域</p><p>中间系统Intermediate System（IS）：即路由器</p><p>终端系统End  System（ES）：即主机</p><p>ES-IS：主机和路由器之间运行的协议</p><p>IS-IS：路由器与路由器之间运行的协议，就是用来提供路由域内或一个区域内的路由</p><p>IS-IS路由器有三种角色：</p><ol><li>Level-1：负责区域内的路由，只与属于<strong>同一区域的Level-1和Level-1-2路由器形成邻居关系</strong>，维护一个Level-1的链路状态数据库，该链路状态数据库包含<strong>本区域的路由信息</strong>，到区域外的报文转发给最近的Level-1-2路由器。</li><li>Level-2：负责区域间的路由，可以与<strong>同一区域或者其它区域的Level-2和Level-1-2路由器形成邻居关系</strong>，维护一个Level-2的链路状态数据库，该链路状态数据库包含<strong>区域间的路由信息</strong>。所有<strong>Level-2</strong>路由器和<strong>Level-1-2</strong>路由器组成路由域的<strong>骨干网</strong>，负责在不同区域间通信，路由域中的Level-2路由器必须是物理连续的，以保证骨干网的连续性。</li><li>Level-1-2：同时属于Level-1和Level-2的路由器，可以与<strong>同一区域的Level-1和Level-1-2路由器形成Level-1邻居关系</strong>，也可以与<strong>同一区域或者其他区域的Level-2和Level-1-2路由器形成Level-2的邻居关系</strong>。Level-1路由器必须通过Level-1-2路由器才能连接至其他区域。Level-1-2路由器维护两个链路状态数据库，Level-1的链路状态数据库用于区域内路由，Level-2的链路状态数据库用于区域间路由。</li></ol><p>每台路由器只能属于一个区域，区域边界在链路上。</p><h3 id="IS-IS协议报文"><a href="#IS-IS协议报文" class="headerlink" title="IS-IS协议报文"></a>IS-IS协议报文</h3><p>IS-IS使用协议数据单元PDU进行通讯。PDU有以下类型：</p><ul><li>IS-IS Hello PDU：简称IIH，负责路由间的邻居关系建立和维护</li><li>链路状态PDU：简称LSP，描述路由器中的所有链路状态信息</li><li>时序报文SNP：用于确认邻居间最新接收的LSP，类似于确认报文。包括两种报文：CSNP和PSNP</li><li>全时序报文CSNP：包含网络中每个LSP的摘要信息。当路由器收到一个CSNP时，它会将该CSNP与其链路状态数据库LSDB进行比较，如果该路由器丢失了一个在CSNP中存在的LSP时， 它会发送一个组播PSNP，向网络中其它路由器索要其需要的LSP。</li><li>部分时序报文PSNP：在点对点链路中用于确认接收的LSP和请求最新或者丢失的LSP；在广播链路中仅用于请求最新或者丢失的LSP。</li></ul><p>IS-IS报文直接封装在链路层数据中。报头包含通用报头Common Header和专用报头Specific Header。</p><h3 id="IS-IS网络类型"><a href="#IS-IS网络类型" class="headerlink" title="IS-IS网络类型"></a>IS-IS网络类型</h3><p>点对点：主要用于PPP、HDLC</p><p>广播：主要用于以太网</p><h2 id="IS-IS实现"><a href="#IS-IS实现" class="headerlink" title="IS-IS实现"></a>IS-IS实现</h2><h3 id="邻接关系"><a href="#邻接关系" class="headerlink" title="邻接关系"></a>邻接关系</h3><ol><li><p>邻居关系建立</p><p>若在点对点网络，只要IS能接收到对端的P2P IIH报文，则邻居能建立，状态变为UP</p><p>若在广播网络，邻居建立需要三次握手。</p></li><li><p>邻接关系建立</p><p>若在点对点网络：</p><p>若在同一区域Area，L1间只建立L1邻接关系，L1和L1/2只建立L1邻接关系，L1/2间建立L1和L2邻接关系。</p><p>若在不同区域，L1间不建立邻接关系（邻居关系都不是），L2间建立L2邻接关系，L1/2间建立L2邻接关系。</p><p>若在广播网络：会选举DIS（Desginated IS，指定IS），类似DR，相同角色的IS间会选举一个，例如L1的路由器间选出一个，与L2间选出的并不冲突。</p></li></ol><p><strong>DIS的作用：</strong></p><p><strong>一旦一个设备选举为DIS以后，DIS发送HELLO数据包的时间间隔是普通路由器的1/3，这样可以保证DIS失效的时候可以被快速检测到</strong>。</p><p><strong>DIS的选举是抢占的, 不能不参加选举，IS-IS中不存在备份DIS,当一个DIS不能工作的时候，直接选举另外一个</strong>。</p><ul><li>在广播子网中创建并向所有的路由器通告伪节点LSP(Link State Protocol Data unit 链路状态数据单元).</li><li>在LAN中通过每10s周期性发送CSNP（完全数据库描述）来泛洪LSP(Link State Protocol Data unit 链路状态数据单元).</li></ul><p><strong>DIS的选举过程：</strong></p><ol><li>比较接口优先级，高的优</li><li>具有最大的(SNPA子网接入点)的路由器将当选DIS。广播网络中SNPA是指MAC地址</li></ol><table><thead><tr><th></th><th>点到点</th><th>广播</th></tr></thead><tbody><tr><td>Hello报文</td><td>P2P IIH</td><td>Level-1/2 LAN IIH</td></tr><tr><td>Hello报文形式</td><td>单播</td><td>组播</td></tr><tr><td>Hello定时器</td><td>10s</td><td>10s，DIS为3.3s</td></tr><tr><td>邻接关系数量</td><td>1</td><td>多个</td></tr></tbody></table><h3 id="LSDB同步"><a href="#LSDB同步" class="headerlink" title="LSDB同步"></a>LSDB同步</h3><p>同步相关报文：</p><ol><li><p>LSP报文：用于描述链路状态信息</p><p>Level-1 LSP仅在区域内传播，Level-2 LSP在骨干网传播</p></li><li><p>SNP报文：用于描述LSDB中LSP摘要，并对邻居之间最新接收的LSP进行确认</p></li><li><p>CSNP报文：包含所有LSP的摘要信息，在广播网络中周期发送，在点对点网络中只在第一次发送</p></li><li><p>PSNP报文：列举最近收到的一个或多个LSP序号，用于LSP确认</p></li></ol><p><strong>在广播网络中：</strong></p><img src="/2018/08/05/IS-IS学习笔记/2.png"><ol><li>所有同类路由器向DIS发送自己的所有LSP</li><li>DIS周期发送LSP摘要信息</li><li>IS向DIS发送PSNP响应</li><li>DIS回复LSP_K</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://baike.baidu.com/item/is-is/930474" target="_blank" rel="noopener">百度百科IS-IS</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> IS-IS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件系统学习笔记</title>
      <link href="/2018/08/01/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Postfix邮件服务器学习笔记</title>
      <link href="/2018/08/01/Postfix%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/Postfix%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Tomcat学习笔记</title>
      <link href="/2018/08/01/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/Tomcat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH与SSL协议学习笔记</title>
      <link href="/2018/08/01/SSH%E4%B8%8ESSL%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/SSH%E4%B8%8ESSL%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="#SSL/TLS概念">SSL/TLS概念</a></li><li><a href="#OpenSSL简介">OpenSSL简介</a></li><li><a href="#SSH协议">SSH协议</a></li></ul><a id="more"></a><h1 id="SSL-TLS概念"><a href="#SSL-TLS概念" class="headerlink" title="SSL/TLS概念"></a>SSL/TLS概念</h1><p>SSL（Secure Socket Layer，安全套接字层）是一种标准安全协议，由美国网景（Netscape）开发，用于在在线通信中建立Web服务器和浏览器之间的加密链接。SSL技术的使用确保了Web服务器和浏览器之间传输的所有数据都保持加密状态。TLS（transport Layer Security，安全传输层协议）是SSL标准化后的版本，与SSL基本没有区别。</p><p>SSL/TLS的主要功能：</p><ul><li>认证用户与服务器，确保数据发送到正确的客户端和服务器，即可靠性</li><li>加密数据，即机密性</li><li>维护数据的完整性</li></ul><h2 id="SSL协议架构"><a href="#SSL协议架构" class="headerlink" title="SSL协议架构"></a>SSL协议架构</h2><p>SSL基于TCP，且分为两个子层：<strong>握手层</strong>和<strong>记录层</strong>，其中<strong>握手层负责建立SSL连接，记录层负责对报文的加解密</strong>。</p><img src="/2018/08/01/SSH与SSL协议学习笔记/1.png"><ul><li><p>握手层：</p><ul><li>协商加密能力</li><li>协商密钥参数</li><li>验证对方身份</li><li>建立并维护SSL会话</li></ul><p>握手层协议报文格式：</p><ul><li>消息类型Type</li><li>消息长度Length</li><li>消息相关参数Content</li></ul><p>SSL提供三种握手过程，分别为：</p><ul><li><p>无客户端身份认证的全握手</p><ol><li>客户端向服务器发送以下信息：支持的SSL最高版本、加密套件列表、压缩算法列表、客户端随机数（32位）、会话ID</li><li>服务器端回应客户端以下信息：服务器同意的SSL版本、加密套件、压缩算法、会话ID、服务器端随机数。并且还会发送服务器的证书、服务器端密钥交换的信息，最后通知对端握手信息已发完</li><li>客户端再向服务器端发送密钥参数和握手过程的验证报文，并通知对端开始启用加密参数</li><li>服务器再向客户端发送自己的握手过程验证报文，并通知对端开始启用加密参数</li></ol></li><li><p>有客户端身份认证的全握手</p><p>与上面类似，但在第2步后，服务器端还会向客户端请求客户端的证书，然后客户端回应自己的证书，并会附加上数字签名</p></li><li><p>会话恢复</p><p>当SSL连接因某些原因不正常断开后，可在超时时间内进行会话恢复。</p><p>客户端向服务器发送的消息与第1条一致，其中会话ID为上一次SSL连接的会话ID。其余过程也基本一致。</p></li></ul></li><li><p>记录层：</p><ul><li>保护传输数据的<strong>机密性</strong>，对数据进行加密和解密</li><li>验证传输数据的<strong>完整性</strong>，计算报文摘要</li><li>对报文<strong>压缩</strong></li><li>保证数据传输的<strong>可靠有序</strong></li></ul><p><strong>记录层对数据包的三个操作：分片、压缩、加密</strong></p><p>记录层协议报文格式：</p><ul><li>报文类型：1个字节，密钥改变协议（20）、告警协议（21）、握手协议（22）、应用层数据（23）</li><li>版本：2字节，TLS1.0（3,1）、SSL3.0（3,0）</li><li>长度：2字节记录层报文的长度，包括加密数据和MAC值</li><li>MAC：消息验证码</li></ul></li></ul><p><strong>SSL会话与连接</strong></p><p>SSL会话是指客户端与服务器间的关联关系，通过握手协议创建。而SSL连接是用于点对点数据的传输，连接的维持时间比较短暂，且一定与一个会话关联。</p><p>一次会话过程通常会发起多个SSL连接来完成任务，这些连接共享会话定义的安全参数，这样可以避免为每个SSL连接单独进行安全参数的协商，而只需在会话建立时进行一次协商，提高了效率。</p><p>HTTPS与HTTP连接的建立耗时也因为SSL层而出现3倍的差距。可通过<code>curl -w &quot;TCP handshake: %{time_connect}, SSL handshake: %{time_appconnect}&quot; -so /dev/null 网址</code>测试。</p><h1 id="OpenSSL概念"><a href="#OpenSSL概念" class="headerlink" title="OpenSSL概念"></a>OpenSSL概念</h1><p>OpenSSL是一个SSL的密码库，是对SSL协议的实现，包含了主要的密码算法，常用的密钥和证书封装管理功能。</p><p>OpenSSL提供八种对称加密算法（DES、AES、Blowfish、CAST、IDEA、RC2、RC5），支持四种非对称加密算法（DH、RSA、DSA、椭圆曲线EC），实现五种信息摘要算法（MD2、MD5、MDC2、SHA（SHA+SHA1）、RIPEMD）</p><p><strong>Heartblood漏洞简介</strong></p><p>心脏出血漏洞，于2014年被公开。受害者的内存内容就会以每次64KB的速度进行泄露，通过读取网络服务器内存，攻击者可以访问敏感数据，从而危及服务器及用户的安全。</p><h1 id="SSH协议"><a href="#SSH协议" class="headerlink" title="SSH协议"></a>SSH协议</h1><p>Secure Shell安全壳协议，是建立在TCP上的安全协议，端口号22。可以防止中间人攻击、DNS和IP欺骗，并可加快数据的传输速度，且通过ssh传输的数据都是经过压缩的。</p><p>目前SSH有两个版本SSH1和SSH2，这两个版本互不兼容。SSH有以下特点：</p><ul><li>支持DES、3DES加密</li><li>支持公钥（密钥）验证方式、密码（口令）验证方式、不验证</li><li>支持RSA认证</li></ul><p>SSH连接建立过程：</p><ol><li>版本号协商：客户端与服务器协商出双方使用的SSH版本</li><li>密钥与算法协商：客户端与服务器交换算法协商报文，协商出使用的算法，并且生成会话密钥和ID</li><li>认证：客户端向服务器发送认证请求，服务器端对客户端认证</li><li>会话请求：客户端向服务器发送会话请求，服务器等待并处理客户端请求</li><li>交互会话：数据加密传输</li></ol><h2 id="sshd服务"><a href="#sshd服务" class="headerlink" title="sshd服务"></a>sshd服务</h2><p>通过openssh软件实现sshd服务，sshd正是使用ssh协议进行远程访问或传输文件的服务。</p><p>sshd主要要有三个软件：</p><ul><li>openssh：包含openssh服务器与客户端需要的核心文件</li><li>openssh-clients：openssh客户端软件</li><li>openssh-server：openssh服务器软件</li></ul><p>Openssh的配置文件</p><ul><li><code>/etc/ssh/ssh_config</code>：客户端配置文件</li><li><code>/etc/ssh/sshd_config</code>：服务器端配置文件</li></ul><p>ssh命令常见选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssh [username@]host [options] [command]</span><br><span class="line">  -p 指定连接的远程主机端口，默认22</span><br><span class="line">  -v 显示详细信息，一般用于拍错</span><br><span class="line">  -C 压缩所有数据</span><br><span class="line">  可直接通过ssh在远端执行命令</span><br><span class="line">  -l 指定登录用户名</span><br></pre></td></tr></table></figure><h3 id="sshd-config配置"><a href="#sshd-config配置" class="headerlink" title="sshd_config配置"></a>sshd_config配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Port  22              #端口号</span><br><span class="line">#为安全起见，在实际生产环境中，最好将端口改为非22，减小ssh暴露的危险</span><br><span class="line">Protocol 2            #SSH版本，默认2，SSH1已淘汰</span><br><span class="line">AddressFamily         #</span><br><span class="line">ListenAddress 0.0.0.0 #设置sshd服务器监听的本地IP地址。0.0.0.0表示监听本地所有IP地址（如果有多个）</span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key  #服务器秘钥文件的路径（还有dsa等密钥）</span><br><span class="line">Compression yes       #是否可使用压缩指令</span><br><span class="line">KeyRegenerationInterval 1h  #服务器重新生成密钥的周期</span><br><span class="line">ServerKeyBits 1024    #服务器密钥的长度</span><br><span class="line">LogLevel INFO         #日志等级</span><br><span class="line">LoginGraceTime 2m     #输入密码后，若2分钟内未连接成功，则断开</span><br><span class="line">PermitRootLogin yes   #是否允许使用root登录远程主机，若为生产环境需要设为no</span><br><span class="line">StrictModes yes       #ssh在接收登录请求之前是否检查用户根目录和rhosts文件的权限和所有权，默认开启</span><br><span class="line">SyslogFacility AUTHPRIV  #日志类型</span><br><span class="line">PubkeyAuthentication yes #是否开启公钥验证，如果使用公钥验证的方式登录时，则设置为yes</span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys #公钥验证文件的路径</span><br><span class="line">PasswordAuthentication yes  #是否开启密码验证</span><br><span class="line">PermitEmptyPasswords no  #是否允许空密码登录</span><br><span class="line">PrintMotd yes         #登录后是否打印信息（上次登录时间和地点等），信息内容可在/etc/motd中编辑</span><br><span class="line">PrintLastLog yes      #显示上次登录的信息，默认允许</span><br><span class="line">UsePrivilegeSeparation sandbox  #是否允许权限较低的程序一共用户操作，会让sshd在远程用户登入后产生一个属于该用户的sshd程序，使系统较安全</span><br><span class="line">UseDNS yes  #为了判断客户端是否合法，会使用DNS反查客户端主机名。</span><br><span class="line">            #若是内网，则no可以让连接更快。</span><br><span class="line">MaxAuthTries 6        #最多密码尝试次数</span><br><span class="line">MaxSessions 10        #最多终端数</span><br><span class="line">ClientAliveInterval 0 #向客户端发送keepalive报文的间隔</span><br><span class="line">ClientAliveCountMax 3 #若三次收不到keepalive消息，则认为连接断开</span><br><span class="line">TCPKeepAlive          #是否持续连接，设置yes可以防止死连接</span><br><span class="line">#SSH Server会传送KeepAlive的讯息给Client端，以确保两者的联机正常</span><br></pre></td></tr></table></figure><p>最好将ssh的日志文件<code>/var/log/secure</code>的路径改掉，减小入侵后ssh日志文件被删除的风险。可修改<code>/etc/rsyslog.conf</code>的<code>authpriv</code>参数，包括特权信息如用户名在内的认证活动。</p><p>默认：<code>authpriv.* /var/log/secure</code> ，修改此项即可改变ssh日志路径</p><h3 id="密钥分发命令"><a href="#密钥分发命令" class="headerlink" title="密钥分发命令"></a>密钥分发命令</h3><p><code>ssh-keygen</code>用于生成密钥对。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="https://baike.baidu.com/item/ssl" target="_blank" rel="noopener">百度百科-ssl</a></li><li><a href="https://baike.baidu.com/item/ssh/10407" target="_blank" rel="noopener">百度百科-ssh</a></li><li></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> OpenSSL </tag>
            
            <tag> SSL </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Xinted学习笔记</title>
      <link href="/2018/08/01/Xinted%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/Xinted%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>无人值守学习笔记</title>
      <link href="/2018/08/01/%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/%E6%97%A0%E4%BA%BA%E5%80%BC%E5%AE%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇主要包含以下内容：</p><ul><li><a href="#PXE概述">PXE概述</a></li><li><a href="#Kickstart">Kickstart</a><ul><li><a href="#网络安装试验">网络安装试验</a></li><li><a href="#Kickstart配置">Kickstart配置</a></li></ul></li><li><a href="#Cobbler">Cobbler</a><a id="more"></a></li></ul><h1 id="PXE概述"><a href="#PXE概述" class="headerlink" title="PXE概述"></a>PXE概述</h1><p>Preboot Execution Environment远程预启动执行环境，就是使计算机通过网络启动。</p><p>要达成PXE必须要有两个环节：</p><ul><li>客户端的网卡必须要支持PXE用户端功能，并且开机时选择从网卡启动，这样系统才会以网卡进入PXE客户端的程序</li><li>PXE服务器必须要提供至少含有DHCP以及TFTP的服务<ul><li>DHCP服务必须要能够提供客户端的网络参数，还要告知客户端TFTP所在的位置；</li><li>TFTP则提供客户端的<code>boot loader</code>及<code>kernel file</code>下载路径。</li></ul></li></ul><p>可选的其他服务：NFS、FTP、HTTP等<br><img src="/2018/08/01/无人值守学习笔记/0.png"></p><p>完整的PXE交互过程：</p><ol><li>Client向DHCP发送IP地址请求消息，DHCP检测Client是否合法（主要是检测Client的网卡MAC地址），如果合法则返回Client的IP地址，同时将启动文件pxelinux.0的位置信息一并传送给Client</li><li>Client向TFTP发送获取pxelinux.0请求消息，TFTP接收到消息之后再向Client发送pxelinux.0大小信息，试探Client是否满意，当TFTP收到Client发回的同意大小信息之后，正式向Client发送pxelinux.0，Client接收并执行pxelinux.0文件</li><li>Client向TFTP Server发送获取针对本机的配置信息文件的请求（在TFTP服务的pxelinux.cfg目录下，这是系统菜单文件，格式和isolinux.cfg格式一样，功能也是类似），TFTP将配置文件发回Client，继而Client根据配置文件执行后续操作。</li><li>Client向TFTP发送Linux内核请求信息，TFTP接收到消息之后将内核文件发送给Client</li><li>Client向TFTP发送根文件请求信息，TFTP接收到消息之后返回Linux根文件系统Client启动Linux内核</li><li>Client从FTP或HTTP下载安装源文件，读取自动化安装脚本</li></ol><blockquote><p>引用自<a href="http://baijiahao.baidu.com/s?id=1601105969236933071&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Cobbler原理解析</a></p></blockquote><h1 id="Kickstart"><a href="#Kickstart" class="headerlink" title="Kickstart"></a>Kickstart</h1><h2 id="Kickstart概述"><a href="#Kickstart概述" class="headerlink" title="Kickstart概述"></a>Kickstart概述</h2><p>Kickstart是通过自动应答文件，将安装系统过程中手动设置的语言、密码、网络等参数自动设置。</p><p>Kickstart文件有三种生成方式：</p><ul><li>手动书写</li><li><code>system-config-kickstart</code>图形化配置</li><li>红帽系系统自带的<code>Anaconda</code>生成</li></ul><h2 id="Kickstart准备"><a href="#Kickstart准备" class="headerlink" title="Kickstart准备"></a>Kickstart准备</h2><p>服务分工介绍：</p><ul><li>DHCP：为安装的新主机分配IP地址</li><li>TFTP：仅仅提供引导文件</li><li>VSFTP|HTTP|NFS：提供系统镜像中所有文件，然后会根据Kickstart文件自动选择要安装的软件，并配置</li></ul><p>防止访问出现错误，先将selinux设为Permissive。<code>setenforce 0</code></p><h3 id="DHCP配置"><a href="#DHCP配置" class="headerlink" title="DHCP配置"></a>DHCP配置</h3><p>首先配置DHCP服务。<br><code>yum install dhcp</code><br>修改配置文件<code>/etc/dhcp/dhcpd.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 日志级别</span><br><span class="line">log-facility local7;</span><br><span class="line"># DNS服务器域名</span><br><span class="line">option domain-name-servers system1.example.com;</span><br><span class="line"># 网关</span><br><span class="line">option routers 192.168.10.2;</span><br><span class="line"># 默认分配时间</span><br><span class="line">default-lease-time 600;</span><br><span class="line"># 最大分配时间</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"></span><br><span class="line">subnet 192.168.10.0 netmask 255.255.255.0 &#123;</span><br><span class="line">  # 地址分配范围</span><br><span class="line">  range 192.168.10.101 192.168.10.110;</span><br><span class="line">  # TFTP服务器（重要）</span><br><span class="line">  next-server 192.168.10.100;</span><br><span class="line">  # TFTP服务器上的共享启动文件名（重要）</span><br><span class="line">  filename &quot;pxelinux.0&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重新加载并设置开机自启<br><code>systemctl restart dhcpd</code><br><code>systemctl enable dhcpd</code><br>若开启了防火墙应该放行服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=dhcp</span><br><span class="line">firewall-cmd --permanent --add-port=67/tcp --add-port=67/udp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><h3 id="TFTP配置"><a href="#TFTP配置" class="headerlink" title="TFTP配置"></a>TFTP配置</h3><p>配置TFTP服务，首先需要安装<code>xinetd</code>服务，因为TFTP是被Xinetd动态管理的服务。<br><code>yum install xinetd tftp-server</code><br>修改配置文件<code>/etc/xinetd.d/tftp</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service tftp</span><br><span class="line">&#123;</span><br><span class="line">        socket_type             = dgram</span><br><span class="line">        protocol                = udp</span><br><span class="line">        wait                    = yes</span><br><span class="line">        user                    = root</span><br><span class="line">        server                  = /usr/sbin/in.tftpd</span><br><span class="line">        # server_args指定共享目录路径</span><br><span class="line">        server_args             = -s /tftpboot</span><br><span class="line">        disable                 = no</span><br><span class="line">        per_source              = 11</span><br><span class="line">        cps                     = 100 2</span><br><span class="line">        flags                   = IPv4</span><br><span class="line">&#125;</span><br><span class="line">disable的值默认为yes，表示禁用tftp，因此要改为no，开启tftp</span><br></pre></td></tr></table></figure></p><p>重启Xinted服务<code>systemctl restart xinetd.service</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过查看服务是否开启</span><br><span class="line"># ss -aupt | grep xinetd</span><br><span class="line">udp    UNCONN     0      0       *:tftp                  *:*                     users:((&quot;xinetd&quot;,pid=3490,fd=5))</span><br></pre></td></tr></table></figure></p><p>若开启了防火墙，需要放行服务和端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=tftp</span><br><span class="line">firewall-cmd --permanent --add-port=69/udp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><h3 id="使用VSFTP搭建镜像源"><a href="#使用VSFTP搭建镜像源" class="headerlink" title="使用VSFTP搭建镜像源"></a>使用VSFTP搭建镜像源</h3><p>安装VSFTPD服务<code>yum install vsftpd</code><br><code>systemctl start vsftpd</code><br><code>systemctl enable vsftpd</code></p><p>将光盘镜像挂载在<code>/var/ftp/pub</code>中。<code>mount /dev/cdrom /var/ftp/pub</code></p><p>若开启了防火墙，应该放行端口和服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=20/tcp --add-port=21/tcp</span><br><span class="line">firewall-cmd --permanent --add-service=ftp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>在浏览器中输入<code>ftp://192.168.10.100</code>访问成功。</p><h3 id="使用HTTP搭建镜像源"><a href="#使用HTTP搭建镜像源" class="headerlink" title="使用HTTP搭建镜像源"></a>使用HTTP搭建镜像源</h3><p>安装HTTPD服务<code>yum install httpd</code><br><code>systemctl start httpd</code><br><code>systemctl enable httpd</code></p><p>将光盘镜像挂载在<code>/var/www/html/centos7</code>上。<code>mount /dev/cdrom /var/www/html/centos7</code></p><p>若开启了防火墙，应该放行端口和服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line">firewall-cmd --permanent --add-service=http</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>在浏览器中输入<code>192.168.10.100/centos7</code>访问成功。</p><h3 id="Syslinux配置"><a href="#Syslinux配置" class="headerlink" title="Syslinux配置"></a>Syslinux配置</h3><p>安装syslinux服务<br>syslinux是一个功能强大的引导加载程序，用于获取引导文件。<br><code>yum install syslinux</code><br>将引导文件复制到TFTP主目录<code>cp /usr/share/syslinux/pxelinux.0 /tftpboot</code><br>若要图形化菜单功能（仅仅是可以上下键切换，最好一起复制了），可将<code>/usr/share/syslinux</code>中的<code>menu.32</code>或<code>vesamenu.c32</code>复制到<code>/tftpboot</code>。这里就复制<code>vesamenu.c32</code>，比<code>menu.32</code>更好。<br>并在<code>/tftpboot</code>中创建目录<code>pxelinux.cfg</code>用于存放默认开机选项，并在该目录中创建<code>default</code>文件</p><p>创建存放CentOS7内核文件的目录<code>mkdir /tftpboot/centos7</code>，并将挂载镜像目录<code>/var/ftp/pub/isolinux/</code>中<code>vmlinuz</code>和<code>initrd.img</code>两个内核文件复制到该目录中。<code>cp /var/ftp/pub/isolinux/{vmlinuz,initrd.img} /tftpboot/centos7/</code><br>最好将<code>isolinux</code>目录下的<code>isolinux.cfg</code>也复制过去，该文件提供了开机选项，可以以它作为修改开机选项和菜单的模板。可以直接将内容拷贝过去，<code>cat /var/ftp/pub/isolinux/isolinux.cfg &gt; /tftpboot/pxelinux.cfg/default</code>。</p><p><code>default</code>即<code>isolinux.cfg</code>简单解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">default vesamenu.c32    # 必须指定，填/tftpboot中复制的图形化文件</span><br><span class="line">timeout 10              # 在选择界面停留的时间（若未操作）</span><br><span class="line">display boot.msg   　　　# 选项的说明文件</span><br><span class="line"></span><br><span class="line">菜单的一些显示设置，不用改</span><br><span class="line">menu clear</span><br><span class="line">menu background splash.png</span><br><span class="line">menu title CentOS 7    # 引导是显示的标题</span><br><span class="line">menu vshift 8</span><br><span class="line">menu rows 18</span><br><span class="line">menu margin 8</span><br><span class="line">#menu hidden</span><br><span class="line">menu helpmsgrow 15</span><br><span class="line">menu tabmsgrow 13</span><br><span class="line">.....</span><br><span class="line">在引导界面上显示的选项</span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS 7</span><br><span class="line">  kernel ./centos7/vmlinuz   # vmlinuz是可引导的、压缩的内核，路径要设为相对路径（相对于tftp根目录）</span><br><span class="line">  append initrd=./centos7/initrd.img ks=ftp://192.168.10.100/ks_config/ks.cfg quiet</span><br><span class="line">  # 设置内核文件，要设置initrd.img的相对路径</span><br><span class="line">  # initrd.img全称boot loader initialized RAM disk， boot loader初始化的内存盘。在linux内核启动前，boot loader会将存储介质中的initrd文件加载到内存，内核启动时会在访问真正的根文件系统前先访问该内存中的initrd文件系统</span><br><span class="line">  # 后面跟着ks=ks.cfg文件的路径，http或ftp都行</span><br><span class="line">  # 后面还可以跟上ksdevice=eth0，当客户端有多块网卡时，此项就会让系统不提示要选择哪块网卡</span><br><span class="line"></span><br><span class="line">label check</span><br><span class="line">  menu label Test this ^media &amp; install CentOS 7</span><br><span class="line">  menu default     # 默认光标停留在此标签（选项）上</span><br><span class="line">  kernel ./centos7/vmlinuz</span><br><span class="line">  append initrd=./centos7/initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 rd.live.check quiet</span><br></pre></td></tr></table></figure></p><p>整个<code>/tftpboot</code>的目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/tftpboot/</span><br><span class="line">├── centos7</span><br><span class="line">│   ├── initrd.img</span><br><span class="line">│   └── vmlinuz</span><br><span class="line">├── pxelinux.0</span><br><span class="line">├── pxelinux.cfg</span><br><span class="line">│   └── default</span><br><span class="line">└── vesamenu.c32</span><br></pre></td></tr></table></figure></p><h2 id="网络安装试验"><a href="#网络安装试验" class="headerlink" title="网络安装试验"></a>网络安装试验</h2><p>做这个实验时，要先修改<code>/tftpboot/pxelinux.cfg/default</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">找到以下内容</span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS 7</span><br><span class="line">  menu default</span><br><span class="line">  kernel ./centos7/vmlinuz</span><br><span class="line">  append initrd=./centos7/initrd.img inst.stage2=ftp://192.168.10.100/pub quiet</span><br><span class="line">net.ifnames=0 biosdevname=0</span><br><span class="line"></span><br><span class="line">inst.stage2设置FTP镜像源</span><br><span class="line">在quiet后再加上net.ifnames=0 biosdevname=0</span><br><span class="line">让网卡名称为ethN，而不是默认的eno16777728这样的随机名称</span><br></pre></td></tr></table></figure></p><p>创建一个新的虚拟机，不指定镜像。<br><img src="/2018/08/01/无人值守学习笔记/1.png"><br>进入虚拟机的BIOS设置<br><img src="/2018/08/01/无人值守学习笔记/2.png"><br>进入Boot菜单，通过<code>-</code>或<code>+</code>改变启动顺序，将<code>Network boot from Intel E1000</code>移到最上面。<br><img src="/2018/08/01/无人值守学习笔记/4.png"><br>保存退出，会自动启动主机，通过网络读取FTP镜像源。<br><img src="/2018/08/01/无人值守学习笔记/5.png"><br>最后进入图形化安装界面<br><img src="/2018/08/01/无人值守学习笔记/6.png"></p><h2 id="Kickstart配置"><a href="#Kickstart配置" class="headerlink" title="Kickstart配置"></a>Kickstart配置</h2><h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><p>首先创建<code>ks.cfg</code>，存放在<code>/var/ftp/ks_config</code>（FTP源）或<code>/var/www/html/centos/ks_config</code>（HTTP源）。<br>修改<code>/tftpboot/pxelinux.cfg/default</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">仍然找到这段内容，修改initrid后的内容</span><br><span class="line">删除原来的inst.stage2，改为ks=fs.cfg路径，HTTP同理</span><br><span class="line">label linux</span><br><span class="line">  menu label ^Install CentOS 7</span><br><span class="line">  menu default</span><br><span class="line">  kernel ./centos7/vmlinuz</span><br><span class="line">  append initrd=./centos7/initrd.img ks=ftp://192.168.10.100/ks_config/ks.cfg quiet</span><br><span class="line">net.ifnames=0 biosdevname=0</span><br></pre></td></tr></table></figure></p><p>在主目录中有系统自动创建的<code>anaconda-ks.cfg</code>，可以此为模板。在图像化配置安装时就是向该文件中添加配置，直到点击安装时，安装程序就会根据该配置文件安装。</p><p><code>anaconda-ks.cfg</code>简单解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">分为三个部分：</span><br><span class="line">1. 选项指令段，用于图形化安装时除包选择外的所有手动操作</span><br><span class="line">2. %packages段，用于选择软件包</span><br><span class="line">3. 脚本段，可选。分为两种：</span><br><span class="line">  %pre：预安装脚本段，在安装系统之前就执行的脚本。很少使用</span><br><span class="line">  %post：后安装脚本段，在系统安装完成后执行的脚本。</span><br><span class="line"></span><br><span class="line">必选选项：</span><br><span class="line"># auth验证选项</span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line">  --enableshadow|--useshadow   开启shadow文件验证</span><br><span class="line">  --passalgo　　指定密码加密算法</span><br><span class="line"></span><br><span class="line"># bootloader指定如何安装引导程序</span><br><span class="line">bootloader --append=&quot;crashkernel=auto&quot; --location=mbr --boot-drive=sda</span><br><span class="line">  --append      指定内核参数</span><br><span class="line">  --location    指定引导程序的位置，默认为MBR</span><br><span class="line">  --boot-drive  指定grub安装的分区</span><br><span class="line"></span><br><span class="line"># keyboard键盘类型</span><br><span class="line">keyboard --vckeymap=us --xlayouts=&apos;us&apos;</span><br><span class="line">  --vckeymap指定键盘分布，默认为us美式</span><br><span class="line"></span><br><span class="line"># lang指定语言</span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"></span><br><span class="line"># rootpw指定root密码</span><br><span class="line">rootpw --iscrypted $6$D2fmDfXJI30ZbG0x$lenXfD98spplf7jHTmfiJ0m7CgQqJM.ddQ5hu07qiU3A5fJcRhSQA5KZolrWoSfGm2oIwJUglnRwoXth9rDGc0</span><br><span class="line">  --iscrypted 使用加密密码</span><br><span class="line"></span><br><span class="line">可选选项：</span><br><span class="line">install   表示是安装系统，若为install还需指定安装方式：</span><br><span class="line">  cdrom      表示从光盘安装</span><br><span class="line">  harddrive  硬盘安装，硬盘必须是VFAT或EXT文件系统</span><br><span class="line">    --dir    指定从包含安装树（install-tree）的目录安装</span><br><span class="line">    --partition  指定从哪个分区安装</span><br><span class="line">  nfs </span><br><span class="line">    --server   指定NFS服务器主机名或IP地址</span><br><span class="line">    --dir      指定安装树目录</span><br><span class="line">    --opts     指定NFS的挂载选项</span><br><span class="line">  url </span><br><span class="line">    --url 后面跟上地址</span><br><span class="line">update    表示是升级系统</span><br><span class="line"></span><br><span class="line">graphical 表示图形模式下执行kickstart安装，默认</span><br><span class="line">text　　 文本模式下根据kickstart执行安装（手动创建一定是text）</span><br><span class="line">firstboot 安装后第一次启动默认会有需要手动配置的界面，应该禁用</span><br><span class="line">  --enable|--disable  启用|禁用</span><br><span class="line">ignoredisk 指定忽略的磁盘</span><br><span class="line">  --only-use=sda</span><br><span class="line">network  配置网络</span><br><span class="line">  --bootproto      地址协议，dhcp或static。若为static需要配置IP、掩码、网关、DNS</span><br><span class="line">  --device=ens33   设置网卡名</span><br><span class="line">  --onboot=off     是否在引导系统时启用设备</span><br><span class="line">  --ipv6=auto 　　　开启IPv6</span><br><span class="line">  --no-activate    </span><br><span class="line">  --hostname=localhost.localdomain　主机名</span><br><span class="line">若协议为static，则需要以下选项：</span><br><span class="line">  --ip=</span><br><span class="line">  --netmask=</span><br><span class="line">  --gateway=</span><br><span class="line">  --nameserver=</span><br><span class="line"></span><br><span class="line">repo    设置repo源</span><br><span class="line">  --name=</span><br><span class="line">  --baseurl=</span><br><span class="line">services      设置服务是否启用</span><br><span class="line">  --disabled=</span><br><span class="line">  --enabled=</span><br><span class="line">timezone Asia/Shanghai --isUtc --nontp  指定时区</span><br><span class="line">selinux     设置selinux</span><br><span class="line">  --enforcing</span><br><span class="line">  --permissive</span><br><span class="line">  --disabled</span><br><span class="line">firewall  是否开启防火墙</span><br><span class="line">  --disable|--enable</span><br><span class="line">xconfig  --startxonboot</span><br><span class="line">autostep     交互式，和interactive类似</span><br><span class="line">interactive  使用kickstart文件指定的参数交互式安装，但仍会给出每一步的选择项，如果直接下一步就使用kickstart参数</span><br><span class="line">cmdline      在完全非交互的命令行模式下进行安装</span><br><span class="line">driverdisk   指定驱动程序所在位置</span><br><span class="line">  --source=</span><br><span class="line">autopart     自动分区</span><br><span class="line">  --type=lvm</span><br><span class="line">zerombr      清除磁盘的MBR</span><br><span class="line">clearpart    在安装系统前清除分区</span><br><span class="line">  --all      清除所有分区</span><br><span class="line">  --initlabel   创建标签，对于没有MBR或者GPT的新硬盘，该选项是必须的</span><br><span class="line">  --drives=sda  清除指定的分区</span><br><span class="line">  --Linux    清除Linux分区</span><br><span class="line">  --none     不清除分区</span><br><span class="line">  常用cleanpart --all --initlabel</span><br><span class="line"></span><br><span class="line">part [分区]  　创建分区</span><br><span class="line">  --fstype    文件系统类型</span><br><span class="line">  --asprimary 强制为主分区</span><br><span class="line">  --size      设置大小（单位Mb）</span><br><span class="line">  --grow      使用所有可用空间，即为其分配所有剩余空间。</span><br><span class="line">  对于根分区至少需要3G空间（即使是--grow，也还是需要指定--size）</span><br><span class="line"></span><br><span class="line">user    在系统中生成一个新用户</span><br><span class="line">  --name      指定用户名</span><br><span class="line">  --groups    指定辅助组，非默认组</span><br><span class="line">  --homedir   用户家目录，如果不指定则默认为/home/&lt;username&gt;</span><br><span class="line">  --password  该用户的密码，如果不指定或省略则创建后该用户处于锁定状态</span><br><span class="line">  --shell     用户的shell，不指定则默认</span><br><span class="line">  --uid       用户UID，不指定则自动分配一个非系统用户的UID</span><br><span class="line">loggin      指定安装过程中的错误日志位置</span><br><span class="line">  --host    指定日志将发送到那台主机上</span><br><span class="line">  --port    如果远程主机的rsyslog使用非默认端口，则应该指定该端口选项</span><br><span class="line">  --level   指定日志级别</span><br><span class="line">halt|reboot   安装完成后操作，halt为关机，reboot为重启，默认是halt</span><br><span class="line"></span><br><span class="line"># 软件包或软件包组</span><br><span class="line"># @表示包组，@base和@core默认包含</span><br><span class="line">%packages</span><br><span class="line">@^graphical-server-environment</span><br><span class="line">@base</span><br><span class="line">@core</span><br><span class="line">@desktop-debugging</span><br><span class="line">@dial-up</span><br><span class="line">@fonts</span><br><span class="line">@gnome-desktop</span><br><span class="line">@guest-agents</span><br><span class="line">@guest-desktop-agents</span><br><span class="line">@hardware-monitoring</span><br><span class="line">@input-methods</span><br><span class="line">@internet-browser</span><br><span class="line">@multimedia</span><br><span class="line">@print-client</span><br><span class="line">@x11</span><br><span class="line">kexec-tools</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%addon com_redhat_kdump --enable --reserve-mb=&apos;auto&apos;</span><br><span class="line">%end</span><br><span class="line"></span><br><span class="line">%anaconda</span><br><span class="line">pwpolicy root --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line">pwpolicy user --minlen=6 --minquality=1 --notstrict --nochanges --emptyok</span><br><span class="line">pwpolicy luks --minlen=6 --minquality=1 --notstrict --nochanges --notempty</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注：<code>%addon</code>、<code>%anaconda</code>、<code>%packages</code>、<code>%onerror</code>、<code>%pre</code>、<code>%post</code>必须以<code>%end</code>结尾</strong></p></blockquote><p>官方并不建议手工创建kickstart文件，因为太过复杂，且容易出错。因此，可通过<code>system-config-kickstart</code>图形化工具快速生成kickstart文件。</p><h3 id="system-config-kickstart配置"><a href="#system-config-kickstart配置" class="headerlink" title="system-config-kickstart配置"></a>system-config-kickstart配置</h3><p>需要安装该工具<code>yum install system-config-kickstart</code><br>打开工具后，按照以下界面配置即可。<br><img src="/2018/08/01/无人值守学习笔记/10.png"><br><img src="/2018/08/01/无人值守学习笔记/11.png"><br><img src="/2018/08/01/无人值守学习笔记/12.png"><br><img src="/2018/08/01/无人值守学习笔记/13.png"><br><img src="/2018/08/01/无人值守学习笔记/14.png"><br><img src="/2018/08/01/无人值守学习笔记/15.png"><br><img src="/2018/08/01/无人值守学习笔记/16.png"><br><img src="/2018/08/01/无人值守学习笔记/17.png"><br><img src="/2018/08/01/无人值守学习笔记/18.png"></p><p>若需要修改，则直接打开修改即可。若图形化无法添加安装软件包，就在生成的<code>ks.cfg</code>中添加。最终修改后的<code>ks.cfg</code>文件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">install</span><br><span class="line">keyboard &apos;us&apos;</span><br><span class="line">rootpw --iscrypted $1$8.DdzSgf$UIjrFmFh/4Mavb/4q7z8U.</span><br><span class="line">url --url=&quot;ftp://192.168.10.100/pub&quot;</span><br><span class="line">lang en_US</span><br><span class="line">firewall --disabled</span><br><span class="line">auth  --useshadow  --passalgo=sha512</span><br><span class="line">graphical</span><br><span class="line">selinux --disabled</span><br><span class="line">skipx</span><br><span class="line"></span><br><span class="line">network  --bootproto=dhcp --device=eth0</span><br><span class="line">network  --hostname=system10.example.com</span><br><span class="line">reboot</span><br><span class="line">timezone Asia/Shanghai</span><br><span class="line">bootloader --location=mbr</span><br><span class="line">zerombr</span><br><span class="line">clearpart --all --initlabel</span><br><span class="line">part /boot --fstype=&quot;xfs&quot; --size=200</span><br><span class="line">part / --fstype=&quot;xfs&quot; --size=5</span><br><span class="line">part /var --fstype=&quot;xfs&quot; --size=10</span><br><span class="line">services --enabled=httpd</span><br><span class="line"></span><br><span class="line">%packages</span><br><span class="line">@base</span><br><span class="line">@core</span><br><span class="line">tree</span><br><span class="line">nmap</span><br><span class="line">wget</span><br><span class="line">httpd</span><br><span class="line">%end</span><br></pre></td></tr></table></figure></p><p>再次进行安装，进入下面画面时，发现配置已根据kickstart文件填写完成。<br><img src="/2018/08/01/无人值守学习笔记/19.png"></p><h1 id="Cobbler"><a href="#Cobbler" class="headerlink" title="Cobbler"></a>Cobbler</h1><p>Cobbler与Kickstart类似，是一个Linux服务器快速网络安装的服务，可以通过PXE快速安装、重装物理服务器和虚拟机。基于Python开发，支持命令行管理、<strong>web界面管理</strong>、提供API接口。可以管理DHCP，DNS，TFTP、RSYNC以及yum仓库、构造系统ISO镜像。</p><p>Cobbler会在请求内核文件后，再请求Kickstart文件（即ks.cfg）和OS镜像。然后Cobbler加载Kickstart文件并接收安装OS镜像。</p><p>Cobbler常见术语：</p><ul><li>distro：发行版，相当于一个操作系统镜像，包含内核和initrd信息以及软件包等</li><li>repository：保存一个yum或rsync存储库的镜像信息</li><li>profile：配置文件，包含distro、kickstart文件和repository等信息，作用为了修改<code>/tftpboot/pxelinux.cfg/default</code>文件，每生成或修改一次profile，都会在default文件中修改或追加对应的label</li><li>system：目标系统，即要安装的主机，包含配置文件或镜像，IP地址等信息</li><li>image：系统镜像</li></ul><blockquote><p>system、image、repository用的很少，主要用distro和profile。</p></blockquote><h2 id="Cobbler安装"><a href="#Cobbler安装" class="headerlink" title="Cobbler安装"></a>Cobbler安装</h2><p>仍然使用之前Kickstart的环境。<strong>必须关闭selinux</strong>。<br>首先安装<code>epel-release</code>，因为Cobbler位于epel源中。<br>然后安装Cobbler及其他工具程序<br><code>yum install cobbler cobbler-web pykickstart</code><br>其中cobbler-web是cobbler的网页端配置工具，可不用安装。<br>pykickstart是用于检查kickstart文件语法的工具<br>cobbler的运行依赖于dhcp、tftp、rsync及dns服务，因此在现有环境下还要安装rsync。<code>yum install rsync</code><br><code>systemctl enable rsyncd</code><br><code>systemctl start rsyncd</code><br><code>systemctl enable cobblerd.service</code><br><code>systemctl start cobblerd.service</code></p><p>使用命令<code>cobbler check</code>进行检查，对查出的错误一一解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 : The &apos;server&apos; field in /etc/cobbler/settings must be set to something other than localhost, </span><br><span class="line">or kickstarting features will not work.  </span><br><span class="line">This should be a resolvable hostname </span><br><span class="line">or IP for the boot server as reachable by all machines that will use it.</span><br><span class="line">2 : For PXE to be functional, the &apos;next_server&apos; field in /etc/cobbler/settings </span><br><span class="line">must be set to something other than 127.0.0.1, </span><br><span class="line">and should match the IP of the boot server on the PXE network.</span><br></pre></td></tr></table></figure></p><p>这两个问题需要设置<code>/etc/cobbler/settings</code>，修改以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将127.0.0.1修改为本机的IP地址</span><br><span class="line">next_server: 192.168.10.100</span><br><span class="line">server: 192.168.10.100</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 : Some network boot-loaders are missing from /var/lib/cobbler/loaders, you may run &apos;cobbler get-loaders&apos; to download them, or, if you only want to handle x86/x86_64 netbooting, you may ensure that you have installed a *recent* version of the syslinux package installed and can ignore this message entirely.  Files in this directory, should you want to support all architectures, should include pxelinux.0, menu.c32, elilo.efi, and yaboot. The &apos;cobbler get-loaders&apos; command is the easiest way to resolve these requirements.</span><br></pre></td></tr></table></figure><p>问题是需要获取bootloaders文件，执行<code>cobbler get-loaders</code>自动下载，但要求联网。也可复制，但需要的文件很多，有的不好找，最好直接执行命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 : debmirror package is not installed, it will be required to manage debian deployments and repositories</span><br></pre></td></tr></table></figure><p>安装<code>debmirror</code>软件包并将<code>/etc/debmirror.conf</code>中的<code>dists</code>和<code>arches</code>注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#@dists=&quot;sid&quot;;</span><br><span class="line">#@arches=&quot;i386&quot;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 : The default password used by the sample templates for newly installed machines (default_password_crypted in /etc/cobbler/settings) is still set to &apos;cobbler&apos; and should be changed, try: &quot;openssl passwd -1 -salt &apos;random-phrase-here&apos; &apos;your-password-here&apos;&quot; to generate new one</span><br></pre></td></tr></table></figure><p>需要使用openssl生成加密密码来取代默认的密码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd -1 -salt &apos;cobbler&apos; &apos;123456&apos;</span><br><span class="line">  passwd  表示生成密码</span><br><span class="line">  -1      表示使用MD5加密</span><br><span class="line">  -salt   表示使用后面提供的参数生成，后面跟上用户名和密码</span><br><span class="line">会生成一个加密密码，将这串字符替换掉原来的默认密码</span><br><span class="line">default_password_crypted: &quot;$1$cobbler$52QDrGSqGlT9d5qbjg7QY/&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 : fencing tools were not found, and are required to use the (optional) power management features. install cman or fence-agents to use them</span><br></pre></td></tr></table></figure><p>安装<code>cman</code>和<code>fence-agents</code>，<code>cman</code>可能会找不到这个包，但只安装<code>fence-agents</code>就够了。</p><p>最后使用命令<code>cobbler sync</code>应用调整的参数或重启<code>cobblerd</code>服务，再执行一次<code>cobbler check</code>检查，若还有错就继续排错，若没有错误就会显示<code>No configuration problems found.  All systems go.</code></p><p>Cobbler默认管理tftp服务，默认不管理dhcp，因此tftp的根目录变为<code>/var/lib/tftpboot</code>。如果让Cobbler管理DHCP，则Cobbler管理DHCP的模板文件<code>/etc/cobbler/dhcp.template</code>会覆盖<code>/etc/dhcp/dhcpd.conf</code>。</p><p>将光盘挂载到本地，<code>mount /dev/cdrom /mnt/mirror</code>，然后执行<code>cobbler import --name=CentOS7 --path=/mnt/mirror</code>生成distro，从本地导入的过程实际上是将系统镜像中的文件复制到<code>/var/www/cobbler/ks_mirror/CentOS7</code>中。在<code>/var/www/cobbler/images</code>中也会生成一个<code>CentOS7-x86_64</code>的目录，其中存放了<code>initrd.img</code>和<code>vmlinuz</code>文件。</p><p>然后，需要提供kickstart文件，这里继续使用Kickstart实验用的<code>ks.cfg</code>文件，将文件移动到<code>/var/lib/cobbler/kickstarts</code>中，并改名为<code>CentOS7.ks</code>，需要修改以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#如果存在ignoredisk设置，一定要注释掉，cobbler编译时不支持此语法</span><br><span class="line">修改镜像安装源</span><br><span class="line">url  --url=&quot;http://http://192.168.10.100/cobbler/ks_mirror/CentOS7/&quot;</span><br></pre></td></tr></table></figure><p>在导入镜像生成distro的过程中，会自动生成一个profile。使用<code>cobbler profile list</code>查看。使用<code>cobbler profile report --name=CentOS7-x86_64</code>查看profile信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cobbler profile report --name=CentOS7-x86_64</span><br><span class="line">其中profile默认使用的kickstart文件有误</span><br><span class="line">Kickstart                      : /var/lib/cobbler/kickstarts/sample_end.ks</span><br></pre></td></tr></table></figure><p>需要通过<code>cobbler profile edit --name=CentOS7-x86_64 --kickstart=/var/lib/cobbler/kickstarts/CentOS7.ks</code>修改。</p><p>最好再修改内核启动参数<code>net.ifnames</code>和<code>biosdevname</code>使网卡名为<code>ethN</code>系列而不是用<code>enoXXXXXX</code>随机名。<code>cobbler profile edit --name=CentOS7-x86_64 --kopts=&quot;net.ifnames=0 biosdevname=0&quot;</code></p><p>若要手动添加一个profile，可使用<code>cobbler profile add --name=XXX --distro=distro名 --kickstart=ks文件路径</code>。每添加一个profile，就是在<code>/var/lib/tftpboot/pxelinux.cfg/default</code>中添加一个label，一个label就是开机启动时的引导选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LABEL CentOS7-x86_64</span><br><span class="line">        kernel /images/CentOS7-x86_64/vmlinuz</span><br><span class="line">        MENU LABEL CentOS7-x86_64</span><br><span class="line">        append initrd=/images/CentOS7-x86_64/initrd.img ksdevice=bootif lang=  text net.ifnames=0 biosdevname=0 kssendmac  ks=http://192.168.10.100/cblr/svc/op/ks/profile/CentOS7-x86_64</span><br><span class="line">        ipappend 2</span><br></pre></td></tr></table></figure><p>在配置完成后，执行<code>cobbler sync</code>同步设置。</p><p>通过浏览器访问<code>default</code>文件中<code>ks</code>参数指定的ks文件路径，看是否能访问，若能显示文件内容，则配置没有问题。</p><p>重启<code>xinetd</code>、<code>cobblerd</code>、<code>dhcpd</code>服务，以防配置未刷新。</p><p>仍然使用一台裸机进行安装，会自动进入安装界面。</p><img src="/2018/08/01/无人值守学习笔记/20.png"><h3 id="使用cobbler-web图形化配置"><a href="#使用cobbler-web图形化配置" class="headerlink" title="使用cobbler-web图形化配置"></a>使用cobbler-web图形化配置</h3><p>如果开启了防火墙，需要放行443端口和https服务，因为Cobbler在CentOS7只支持https。</p><p>在浏览器访问<code>https://IP地址/cobbler_web</code>即可，输入账号密码，均为<code>cobbler</code>。</p><p>首先进行镜像的导入，左侧菜单的<code>Import DVD</code>选项配置。</p><img src="/2018/08/01/无人值守学习笔记/21.png"><p>菜单的<code>Events</code>查看事件日志。</p><img src="/2018/08/01/无人值守学习笔记/22.png"><p>进入<code>distros</code>配置，添加内核选项。也可以通过<code>profiles</code>配置。</p><img src="/2018/08/01/无人值守学习笔记/23.png"><p>设置网卡名为ethN系列</p><img src="/2018/08/01/无人值守学习笔记/24.png"><p>修改或编写ks文件</p><img src="/2018/08/01/无人值守学习笔记/25.png"><p>也可进入菜单<code>system</code>进行system配置。</p><img src="/2018/08/01/无人值守学习笔记/26.png"><img src="/2018/08/01/无人值守学习笔记/27.png"><img src="/2018/08/01/无人值守学习笔记/28.png"><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><blockquote><p><a href="http://www.cnblogs.com/f-ck-need-u/p/7342919.html" target="_blank" rel="noopener">骏马金龙–无人值守CentOS7</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/7342022.html" target="_blank" rel="noopener">kickstart文件详解</a><br><a href="http://www.zyops.com/autoinstall-kickstart/" target="_blank" rel="noopener">KICKSTART无人值守安装</a><br><a href="http://blog.51cto.com/1767340368/2045496" target="_blank" rel="noopener">Cobbler-自动化部署神器</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/7347883.html" target="_blank" rel="noopener">cobbler无人值守批量安装Linux系统</a><br><a href="http://baijiahao.baidu.com/s?id=1601105969236933071&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Cobbler原理解析</a><br>Linux就该这么学<br>Linux运维之道（第二版）</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 无人值守 </tag>
            
            <tag> PXE </tag>
            
            <tag> Kickstart </tag>
            
            <tag> Cobbler </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rsync文件同步服务器学习笔记</title>
      <link href="/2018/08/01/Rsync%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/Rsync%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容</p><ul><li><p><a href="#Rsync介绍与搭建">Rsync介绍与搭建</a></p><ul><li><a href="#quick check算法介绍">quick check算法介绍</a></li><li><a href="#rsync的工作方式">rsync的工作方式</a></li><li><a href="#rsync命令使用">rsync命令使用</a></li><li><a href="#规则解析">规则解析</a></li><li><a href="#Rsync服务器搭建">Rsync服务器搭建</a></li><li><a href="#Rsync部分报错解决">Rsync部分报错解决</a></li></ul></li><li><p><a href="#Rsync+Inotify文件自动同步">Rsync+Inotify文件自动同步</a></p></li><li><a href="#Mutt+Msmtp实现邮件监控">Mutt+Msmtp实现邮件监控</a></li></ul><a id="more"></a><h1 id="Rsync介绍与搭建"><a href="#Rsync介绍与搭建" class="headerlink" title="Rsync介绍与搭建"></a>Rsync介绍与搭建</h1><p>Rsync（Remote Synchronize）是一个远程数据同步工具，可使本地主机不同分区或目录之间及本地和远程两台主机之间的数据快速同步镜像，远程备份等功能。</p><p>Rsync特点：</p><ul><li>使用TCP 873端口</li><li>可根据数据变化进行差异备份或增量备份，减少数据流量</li><li>传输可以通过ssh协议加密数据</li><li>支持拷贝特殊文件如链接，设备等</li><li>可以镜像保存整个目录树和文件系统</li><li>可以保持原来文件或目录的所有属性均不改变</li><li>可使用rsh、ssh，或直接通过socket连接</li><li>支持匿名的或认证的进程模式传输</li><li>使用Rsync自己的<strong><code>quick check</code></strong>算法</li><li>rsync传输大文件时速度大概是scp的20倍以上</li></ul><p>rsync同步过程由两部分模式组成：<strong>决定哪些文件需要同步的检查模式</strong>，<strong>文件同步时的同步模式。</strong></p><ul><li><p>检查模式是指按照指定规则来检查哪些文件需要被同步。</p><blockquote><p>默认情况下，rsync使用<code>quick check</code>算法。可以通过<code>rsync</code>命令选项设置指定的检查模式。</p></blockquote></li><li><p>同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作。</p></li></ul><h2 id="quick-check算法介绍"><a href="#quick-check算法介绍" class="headerlink" title="quick check算法介绍"></a>quick check算法介绍</h2><p>比较源文件和目标文件的文件大小和修改时间mtime（修改时间），只要存在不同，就发送端会传输该文件，如果目标路径下没有文件，则rsync会直接传输文件。若存在差异，并不会传送整个文件，而是只传源文件和目标文件所不同的部分，实现真正的增量同步。</p><p>rsync的增量传输体现在两个方面：<strong>文件级别</strong>的增量传输和<strong>数据块级别</strong>的增量传输。</p><ul><li><strong>文件级别</strong>的增量传输是指源主机上有，但目标主机上没有将直接传输该文件</li><li><strong>数据块级别</strong>的增量传输是指只传输两文件所不同的那一部分数据。</li></ul><p>两台计算机<code>Host-A</code>与<code>Host-B</code>，其中<code>Host-A</code>是源主机，即数据的发送端<code>Sender</code>，<code>Host-B</code>是目标主机，即数据的接收端<code>Receiver</code>。<code>Host-A</code>上存在文件<code>file-A</code>，<code>Host-B</code>上存在<code>file-B</code>。注：<strong><code>file-A</code>与<code>file-B</code>是同名文件。</strong>rsync的实现有以下过程：</p><ol><li><p><code>Host-A</code>告诉<code>Host-B</code>有文件<code>file-A</code>要传输。</p></li><li><p><code>Host-B</code>收到信息后，将文件<code>file-B</code>划分为一系列大小固定的数据块(大小在500-1000字节之间)，并以chunk号码对数据块进行编号，同时还会记录数据块的起始偏移地址以及数据块长度。</p></li><li><p><code>Host-B</code>对每一个分割好的数据块执行两种校验：一种是 32 位的滚动弱校验（rolling checksum），另一种是 128 位的 MD5 强校验。将<code>file-B</code>计算出的所有滚动弱校验和强校验码跟随在对应数据块<code>chunk[N]</code>后形成校验码集合，然后发送给主机<code>Host-A</code></p><blockquote><p>不同数据块的滚动弱校验值有可能相同，但几率非常小。</p></blockquote></li><li><p><code>Host-A</code>通过搜索<code>file-A</code> 的所有该固定大小的数据块（偏移量可以任选），并计算它的校验码和校验码集合中的校验码进行匹配。</p><ul><li>如果能匹配上校验码集合中的某个数据块条目，则表示该数据块和<code>file-B</code>中数据块相同，不需要传输。</li><li>如果不能匹配校验码集合中的数据块条目，则表示该数据块是<strong>非匹配数据块</strong>，它需要传输给<code>Host-B</code>，于是<code>Host-A</code>将跳转到<strong>下一个字节</strong>，从此字节处继续取数据块进行匹配。</li></ul><blockquote><p>数据匹配过程有三个层次：首先比较hash值，然后比较弱滚动校验，最后比较强校验。</p></blockquote></li><li><p>当<code>Host-A</code>发现是匹配数据块时，将只发送这个匹配块的附加信息给<code>Host-B</code>。同时，如果两个匹配数据块之间有非匹配数据，则还会发送这些非匹配数据。</p></li><li>当<code>Host-B</code>陆陆续续收到这些数据后，会创建一个临时文件，并通过这些数据重组这个临时文件，使其内容和<code>file-A</code> 相同。临时文件重组完成后，修改该临时文件的属性信息(如权限、所有者、mtime等)，然后重命名该临时文件替换掉<code>file-B</code>。</li></ol><h2 id="rsync的工作方式"><a href="#rsync的工作方式" class="headerlink" title="rsync的工作方式"></a>rsync的工作方式</h2><ul><li>本地传输方式：首先rsync命令执行时，会有一个rsync进程，然后根据此进程fork另一个rsync进程作为连接的对端，连接建立之后，后续所有的通信将采用管道的方式。</li><li>远程shell连接方式：本地敲下rsync命令后，将请求和远程主机建立远程shell连接（如ssh连接），连接建立成功后，在远程主机上将fork远程shell进程调用远程rsync程序，并将rsync所需的选项通过远程shell命令（如ssh）传递给远程rsync。这样两端就都启动了rsync，之后它们将通过管道的方式进行通信。</li><li>网络套接字连接远程主机上的rsync daemon：当通过网络套接字和远程已运行好的rsync建立连接时，rsync daemon进程会创建一个子进程来响应该连接并负责后续该连接的所有通信。这样两端也都启动了连接所需的rsync，此后通信方式是通过网络套接字来完成的。</li><li>远程shell临时启动一个rsync daemon：不要求远程主机上事先启动rsync服务，而是临时派生出rsync daemon，它是单用途的一次性daemon，仅用于临时读取daemon的配置文件，当此次rsync同步完成，远程shell启动的rsync daemon进程也会自动停止。</li></ul><p>发起连接的一端称为Client端，就是执行rsync命令的一端，连接的另一端称为Server端。</p><blockquote><p>注：当Client端和Server端都启动好rsync进程并建立好了rsync连接(管道、网络套接字)后，将使用Sender端和Receiver端来代替Client端和Server端的概念。</p></blockquote><p>当两端的rsync连接建立后，Sender端的rsync进程称为<code>Sender</code>进程，该进程负责Sender端所有的工作。Receiver端的rsync进程称为<code>Receiver</code>进程，负责接收sender端发送的数据，以及完成文件重组的工作。Receiver端还有一个核心进程<strong><code>Generator</code></strong>进程，该进程负责在Receiver端执行<code>--delete</code>动作、比较文件大小和mtime以决定文件是否跳过、对每个文件划分数据块、计算校验码以及生成校验码集合，然后将校验码集合发送给Sender端。</p><p>三个进程的作业流程：<code>Generator</code>进程的输出结果作为<code>Sender</code>端的输入，<code>Sender</code>端的输出结果作为<code>Recevier</code>端的输入。并且，<strong>这三个进程是完全独立、并行工作的。</strong></p><p><strong>数据同步方式</strong></p><ul><li><strong>推 push</strong>：一台主机负责把数据传送给其他主机，服务器开销很大，比较适合后端服务器少的情况</li><li><strong>拉 pull</strong>：所有主机定时去找一主机拉数据，可能就会导致数据缓慢</li></ul><h2 id="rsync命令使用"><a href="#rsync命令使用" class="headerlink" title="rsync命令使用"></a>rsync命令使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">本地传输方式:  rsync [OPTION...] SRC... [DEST]</span><br><span class="line"></span><br><span class="line">远程shell连接方式:</span><br><span class="line">    Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]</span><br><span class="line">    Push: rsync [OPTION...] SRC... [USER@]HOST:DEST</span><br><span class="line"></span><br><span class="line">连接远程主机上的rsync daemon:</span><br><span class="line">    Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]</span><br><span class="line">          rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]</span><br><span class="line">    Push: rsync [OPTION...] SRC... [USER@]HOST::DEST</span><br><span class="line">          rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST</span><br></pre></td></tr></table></figure><p>若主机与路径用<code>:</code>分隔，则为shell连接，若为<code>::</code>，则为daemon连接。</p><p><strong>注：</strong>源路径如果是一个目录的话，带上尾随斜线和不带尾随斜线是不一样的，<strong>不带尾随斜线表示的是整个目录包括目录本身</strong>，<strong>带上尾随斜线表示的是目录中的文件，不包括目录本身。</strong></p><p>若只有源路径或只有目的路径，则相当于<code>ls -l</code>查看指定文件或目录属性。</p><p><strong>常用选项：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-a        归档模式，表示递归传输并保持文件属性。等同于&quot;-rtopgDl&quot;。</span><br><span class="line">-P        显示文件传输的进度信息</span><br><span class="line">-v        显示rsync过程中详细信息(最多支持-vvvv)</span><br><span class="line">-r        递归</span><br><span class="line">-t        保持mtime属性(最好加上，否则时间会设置为当前系统时间，在增量备份时会因为时间出错)</span><br><span class="line">-o 　　　　保持owner属性</span><br><span class="line">-g 　　　　保持group属性(属组)。</span><br><span class="line">-p 　　　　保持perms属性(权限，不包括特殊权限)。</span><br><span class="line">-D　　　　 拷贝设备文件和特殊文件。</span><br><span class="line">-l　　　　 如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。</span><br><span class="line">-z 　　　　传输时进行压缩提高效率。</span><br><span class="line">-R        使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性</span><br><span class="line">-u      　仅在源mtime比目标已存在文件的mtime新时才拷贝。接收端判断，不会影响删除行为。</span><br><span class="line">--size-only　　只检查文件大小（默认算法是检查文件大小和mtime不同的文件）</span><br><span class="line">--max-size　　 限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：&quot;--max-size=1.5m&quot;)</span><br><span class="line">--min-size 　　限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。</span><br><span class="line">--exclude   　指定排除规则来排除不需要传输的文件。一个exclude只能指定一条规则，若有多条规则，就要写多个exclude</span><br><span class="line">--exclude-from  若规则有多条，可以写在文件中，并使用此选项加载规则文件</span><br><span class="line">--include     指定传输规则，只传输符合该规则的文件，与exclude相反</span><br><span class="line">--delete    　接收端的rsync会先删除目标目录下已经存在，但发送端目录不存在的文件，以SRC为主，对DEST进行同步。多则删之，少则补之。注意&quot;--delete&quot;是在接收端执行的，所以它是在exclude/include规则生效之后才执行的。</span><br><span class="line">-b --backup   对目标上已存在的文件做一个备份，备份的文件名后默认使用&quot;~&quot;做后缀。</span><br><span class="line">--backup-dir  指定备份文件的保存路径，若指定，保存路径必须存在。</span><br><span class="line">              不指定时默认和待备份文件保存在同一目录下。</span><br><span class="line">              默认没有后缀，可通过&quot;--suffix=&quot;指定</span><br><span class="line">-e          　指定所要使用的远程shell程序，默认为ssh。</span><br><span class="line">--port      　连接daemon时使用的端口号，默认为873端口。</span><br><span class="line">--password-file　　daemon模式时的密码文件，是rsync模块认证的密码。</span><br><span class="line">-W --whole-file　　rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。</span><br><span class="line">--existing  　　        要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。</span><br><span class="line">--ignore-existing      要求只更新目标端不存在的文件。和&quot;--existing&quot;结合使用有特殊功能。</span><br><span class="line">--remove-source-files  要求删除源端已经成功传输的文件。</span><br></pre></td></tr></table></figure><blockquote><p><strong>最常用组合<code>-avz</code>。</strong></p></blockquote><p><strong>命令示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rsync -r -R  /etc/dir-1  /tmp         将/etc/dir-1目录复制到/tmp目录下，tmp目录下将会有etc/dir-1子目录</span><br><span class="line">rsync -r -R  /etc/./dir-1  /tmp 将/etc/dir-1目录复制到/tmp目录下，但在/etc/和dir-1目录间加上了“.”</span><br><span class="line">                                       因此仅仅将dir-1目录复制过去作为子目录，tmp目录下将有dir-1子目录</span><br><span class="line">rsync -r -b --backup-dir --suffix=&apos;.bak&apos; /etc/dir-1 /tmp   备份文件，若不存在就直接复制，若已存在就添加后缀以区分</span><br><span class="line"></span><br><span class="line">rsync -r --exclude=&quot;*.txt&quot; /etc/dir-1 /tmp   将/etc/dir-1目录下的以&quot;.txt&quot;结尾的文件排除</span><br><span class="line">rsync -r -v --delete --exclude=&quot;*.txt&quot; /etc/dir-1 /tmp   将/tmp/dir-1中存在而/etc/dir-1不存在的文件删除，并且不删除&quot;.txt&quot;结尾的文件（即使源中不存在）</span><br><span class="line">sending incremental file list</span><br><span class="line">deleting dir-1/a3.log</span><br><span class="line">deleting dir-1/a2.log</span><br><span class="line">deleting dir-1/a1.log</span><br></pre></td></tr></table></figure><h2 id="规则解析"><a href="#规则解析" class="headerlink" title="规则解析"></a>规则解析</h2><p><strong>规则作用时间：</strong>当发送端敲出rsync命令后，rsync将立即<strong>扫描命令行中给定的文件和目录</strong>(扫描过程中还会按照目录进行排序，将同一个目录的文件放在相邻的位置)，这称为<strong>拷贝树</strong>(copy tree)，扫描完成后将待传输的文件或目录<strong>记录到文件列表中</strong>，然后将文件列表传输给接收端。<strong>筛选规则的作用时刻是在扫描拷贝树时，所以会根据规则来匹配并决定文件是否记录到文件列表中</strong>(严格地说是会记录到文件列表中的，只不过<strong>排除的文件会被标记为hide隐藏起来</strong>)，只有记录到了文件列表中的文件或目录才是真正需要传输的内容。<strong>筛选规则的生效时间在rsync整个同步过程中是非常靠前的，它会影响很多选项的操作对象，最典型的如<code>--delete</code></strong>，<code>--delete</code>是在generator进程处理每个文件列表时、生成校验码之前进行的，这样就无需为多余的文件生成校验码。</p><p><strong>rsync规则</strong>：通过选项<code>--filter</code>指定规则</p><ul><li><code>exclude</code>规则：即排除规则，只作用于发送端，被排除的文件不会进入文件列表(实际上是加上隐藏规则进行隐藏)。</li><li><code>include</code>规则：即包含规则，也称为传输规则，只作用于发送端，被包含的文件将明确记录到文件列表中。</li><li><code>hide</code>规则：即隐藏规则，只作用于发送端，隐藏后的文件对于接收端来说是看不见的，也就是说接收端会认为它不存在于源端。</li><li><code>show</code>规则：即显示规则，只作用于发送端，是隐藏规则的反向规则。</li><li><code>protect</code>规则：即保护规则，该规则只作用于接收端，被保护的文件不会被删除掉。</li><li><code>risk</code>规则：即取消保护规则。是<code>protect</code>的反向规则。</li><li><code>clear</code>规则：删除<code>include</code>/<code>exclude</code>规则列表。</li></ul><blockquote><p>上述内容都引用自<a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">骏马金龙－rsync介绍与用法</a></p></blockquote><h2 id="Rsync服务器搭建"><a href="#Rsync服务器搭建" class="headerlink" title="Rsync服务器搭建"></a>Rsync服务器搭建</h2><p>实验环境：</p><ul><li>Rsync服务器：192.168.205.135</li><li>Rsync客户端：192.168.205.134</li></ul><p>首先，两台主机都需要安装rsync，<code>yum/dnf install rsync</code>，fedora已默认安装。</p><p>由于rsync的配置文件默认不存在，所以需要手动创建。Rsync有三个配置文件：</p><ul><li>rsyncd.conf：主配置文件</li><li>rsyncd.secrets：密码文件</li><li>rsyncd.motd：服务器信息文件</li></ul><p>创建<code>/etc/rsyncd.conf</code>文件，具体参数可通过<code>man rsyncd.conf</code>查看</p><p>配置文件分为两部分：全局参数，模块参数<br>全局参数：对 rsync 服务器生效，如果模块参数和全局参数冲突，冲突的地方模块参数生效<br>模块参数：定义需要通过 rsync 输出的目录定义的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 常见全局参数：</span><br><span class="line">port = 873                     监听端口</span><br><span class="line">address = 192.168.205.135      监听服务器地址</span><br><span class="line">uid = nobody                   数据传输时使用的用户ID，默认nobody</span><br><span class="line">gid = nobody                   数据传输时使用的组ID，默认nobody</span><br><span class="line">read only = yes                是否只读</span><br><span class="line">max connections = 10           并发连接数，0表示无限制。超出并发连接数时若再访问，会收到稍后重试的消息</span><br><span class="line">use chroot = no                是否开启chroot，若设为yes，rsync会首先进行chroot设置，将根映射到模块中path指定目录</span><br><span class="line">                               需要root权限，在同步符号连接资料时仅同步文件名，不同步文件内容</span><br><span class="line">transfer logging = yes           开启Rsync数据传输日志功能</span><br><span class="line">#log format =                    设置日志格式，默认log格式为：&quot;%o %h [%a] %m (%u) %f %l&quot;</span><br><span class="line"># 默认log格式表达的是：&quot;操作类型 远程主机名[远程IP地址] 模块名 (认证的用户名) 文件名 文件长度字符数&quot;</span><br><span class="line">#syslog facility =               指定rsync发送日志消息给syslog时的消息级别，默认值是daemon</span><br><span class="line">lock file = /var/run/rsync.lock  设置锁文件</span><br><span class="line">log file = /var/log/rsyncd.log   设置日志文件</span><br><span class="line">pid file = /var/run/rsyncd.pid   设置进程号文件</span><br><span class="line">motd file = /etc/rsyncd.motd     设置服务器信息提示文件</span><br><span class="line">hosts allow = 192.168.205.134    设置允许访问服务器的主机</span><br><span class="line"></span><br><span class="line"># 模块配置</span><br><span class="line">[rsync_test]</span><br><span class="line">comment = rsync test   添加注释</span><br><span class="line">path = /root/rsync_test     同步文件或目录路径</span><br><span class="line">ignore errors                忽略一些IO错误</span><br><span class="line"># exclude =                    可以指定不同步的目录或文件，使用相对路径</span><br><span class="line">auth users = tom,jack        允许连接的用户，可以是系统中不存在的</span><br><span class="line">secrets file = /etc/rsyncd.secrets   设置密码验证文件，该文件的权限要求为只读（600），该文件仅在设置了auth users才有效</span><br><span class="line">list = false      是否允许查看模块信息</span><br><span class="line">timeout = 600     可以覆盖客户指定的 IP 超时时间。确保rsync服务器不会永远等待一个崩溃的客户端。</span><br><span class="line">                  超时单位为秒钟，0表示没有超时定义，这也是默认值。</span><br><span class="line">                  对于匿名rsync服务器来说，一个理想的数字是600</span><br></pre></td></tr></table></figure><p>相关系统操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd tom &amp;&amp; echo &quot;redhat&quot; | passwd tom --stdin</span><br><span class="line">echo &quot;tom:redhat&quot; &gt;&gt; /etc/rsyncd.secrets</span><br><span class="line">echo &quot;jack:redhat&quot; &gt;&gt; /etc/rsyncd.secrets      添加用户到密码文件</span><br><span class="line">chmod 600 /etc/rsyncd.secrets                  修改密码文件权限</span><br><span class="line">echo &quot;Welcome to Rsync&quot; &gt;&gt; /etc/rsyncd.motd</span><br><span class="line"># firewall-cmd --permanent --add-port=873/tcp  若开启了防火墙，就放行端口</span><br><span class="line">rsync --daemon --config=/etc/rsyncd.conf         启动rsyncd服务</span><br></pre></td></tr></table></figure><p>客户端同步文件：<code>rsync -r tom@192.168.205.135::rsync_test /root/rsync_test</code></p><p>自动备份脚本，可配合crond使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 本脚本是将服务器端的文件定期同步到本端</span><br><span class="line"># 设置服务器端模块和本端目录</span><br><span class="line">SRC=rsync_test</span><br><span class="line">DEST=/root/rsync_test</span><br><span class="line">Server=192.168.205.135</span><br><span class="line"># 设置验证用户名和密码</span><br><span class="line">User=tom</span><br><span class="line">Password=redhat</span><br><span class="line"># 若本地同步目录不存在，就创建目录。同步时会删除目录中本端存在，但服务器端不存在的文件</span><br><span class="line">[ ! -d $DEST ] &amp;&amp; mkdir $DEST</span><br><span class="line">rsync -az --delete $&#123;User&#125;@$&#123;Server&#125;::$SRC $DEST/$(date +%Y%m%d)</span><br></pre></td></tr></table></figure><p>若使用Xinetd服务管理Rsync，需要先安装xinetd。创建文件<code>/etc/xinetd.d/rsync</code>，添加以下内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service rsync &#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    wait = no</span><br><span class="line">    user = root</span><br><span class="line">    server = /usr/bin/rsync</span><br><span class="line">    server_args = --daemon --config=/etc/rsyncd.conf</span><br><span class="line">    log_on_failure += USERID</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启xinetd服务即可。</p><h2 id="Rsync部分报错解决"><a href="#Rsync部分报错解决" class="headerlink" title="Rsync部分报错解决"></a>Rsync部分报错解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync: failed to connect to 192.168.205.135 (192.168.205.135): No route to host (113)</span><br><span class="line">rsync error: error in socket IO (code 10) at clientserver.c(125) [Receiver=3.1.2]</span><br></pre></td></tr></table></figure><p>解决：防火墙问题，放行端口或直接关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ERROR: auth failed on module rsync_test</span><br><span class="line">rsync error: error starting client-server protocol (code 5) at main.c(1648) [Receiver=3.1.2]</span><br></pre></td></tr></table></figure><p>解决：用户名与密码问题或模块问题，检查用户名与密码是否匹配，服务器端模块是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync: read error: Connection reset by peer (104)</span><br><span class="line">rsync error: error in rsync protocol data stream (code 12) at io.c(759) [Receiver=3.1.2]</span><br></pre></td></tr></table></figure><p>解决：服务器端配置文件/etc/rsyncd.conf问题，检查配置文件参数是否出错</p><h1 id="Rsync-Inotify文件自动同步"><a href="#Rsync-Inotify文件自动同步" class="headerlink" title="Rsync+Inotify文件自动同步"></a>Rsync+Inotify文件自动同步</h1><h2 id="Inotify介绍"><a href="#Inotify介绍" class="headerlink" title="Inotify介绍"></a>Inotify介绍</h2><p><strong>Inotify</strong>是一个 Linux特性，是<code>inode notify</code>的简写，能监控文件系统操作，反应灵敏，异步传输信息，比cron高效，通过Inotify能试试了解文件系统发生的所有变化。</p><p>注：Linux内核需要大于2.6才集成了Inotify，先要通过uname -r查看内核版本</p><p>Inotify一些特点：</p><ul><li>允许程序员使用标准 <code>select</code> 或者 <code>poll</code> 函数来监视事件</li><li>使用一个独立的文件描述符，可以通过系统调用获得</li></ul><p>使用rsync工具与inotify机制相结合，可以实现触发式备份（实时同步）。</p><p>在系统<code>/proc/sys/fs/inotify/</code>目录中有三个文件：</p><ul><li><code>max_queued_events</code>：inotify实例事件队列可容纳的事件个数，默认16384</li><li><code>max_user_instances</code>：每个用户可以运行的inotifywait或inotifywatch命令的进程数，默认128</li><li><code>max_user_watches</code>：每个进程最多监控文件数，默认8192</li></ul><blockquote><p>若要监控的文件量较大时，需要适当增大这三个值</p></blockquote><p>可以在<code>/etc/sysctl.conf</code>中添加以下内容修改这三个值，或通过<code>sysctl -w</code>直接设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.inotify.max_queued_events =</span><br><span class="line">fs.inotify.max_user_instances =</span><br><span class="line">fs.inotify.max_user_watches =</span><br></pre></td></tr></table></figure><p>Inotify常用的文件系统事件：</p><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>IN_ACCESS</td><td>文件访问事件</td></tr><tr><td>IN_MODIFY</td><td>文件修改事件</td></tr><tr><td>IN_ATTRIB</td><td>文件属性修改事件</td></tr><tr><td>IN_OPEN</td><td>文件打开事件</td></tr><tr><td>IN_CLOSE_WRITE</td><td>可写文件被关闭事件</td></tr><tr><td>IN_CLOSE_NOWRITE</td><td>不可写文件被关闭事件</td></tr><tr><td>IN_MOVED_FROM    IN_MOVED_TO</td><td>文件移动或重命名事件</td></tr><tr><td>IN_DELETE</td><td>文件或目录删除事件</td></tr><tr><td>IN_CREATE</td><td>文件或目录创建事件</td></tr><tr><td>IN_DELETE_SELF</td><td>自删除事件</td></tr></tbody></table><p>若系统为fedora，可直接安装<code>dnf install inotify-tools</code>，若系统为CentOS，则需要先安装<code>epel-release</code>再安装<code>yum install inotify-tools</code></p><p>inotify-tools提供两个应用程序：<code>inotifywait</code>和<code>inotifywatch</code></p><p><code>inotifywait</code>命令用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">inotifywait [options] file...</span><br><span class="line">    @&lt;file&gt;        排除监控指定文件</span><br><span class="line">    --exclude &lt;pattern&gt;    使用正则表达式匹配例外文件，区分大小写</span><br><span class="line">    --excludei &lt;pattern&gt;   使用正则表达式匹配例外文件，不区分大小写</span><br><span class="line">-m|--monitor  一直监听，不退出。若不加此项，监听到一个事件后就退出</span><br><span class="line">-d|--daemon   相当于-m，但是是在后台运行，需要-o或--outfile指定输出文件，或者通过再指定--syslog将错误信息输出至syslog系统日志</span><br><span class="line">-r|--recursive递归监控目录</span><br><span class="line">--fromfile &lt;file&gt;   从文件中读取需要监控与例外的文件名，每行一个文件，若文件名以@开头，表示例外文件</span><br><span class="line">-o|--outfile &lt;file&gt; 将事件信息输出到文件，默认输出到标准输出</span><br><span class="line">-s|--syslog   将错误事件日志发送到syslog，而不是stderr</span><br><span class="line">-q|--quiet    静默模式，只输出事件</span><br><span class="line">-qq           静默模式，什么都不输出（包括事件）</span><br><span class="line">--format &lt;fmt&gt;指定输出信息格式</span><br><span class="line">--timefmt &lt;fmt&gt;设置时间格式</span><br><span class="line">-c|--csv      使用CSV格式输出</span><br><span class="line">-t|--timeout &lt;seconds&gt; 在指定时间内若监听到事件，就退出</span><br><span class="line">-e|--event &lt;event1&gt; [ -e|--event &lt;event2&gt; ... ] 只监控指定事件</span><br></pre></td></tr></table></figure><p>实例：<code>inotifywait -m -d -r -o /var/log/html_monitor /var/www/html</code></p><p>然后进入<code>/var/www/html</code>进行以下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">touch a.html</span><br><span class="line">vim a.html </span><br><span class="line">cp a.html b.html</span><br><span class="line">rm a.html </span><br><span class="line">chmod -r b.html </span><br><span class="line">mv b.html a.html</span><br></pre></td></tr></table></figure><p>在<code>/var/log/html_monitor</code>中就有以下信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/var/www/html/ CREATE a.html</span><br><span class="line">/var/www/html/ OPEN a.html</span><br><span class="line">/var/www/html/ ATTRIB a.html</span><br><span class="line">/var/www/html/ CLOSE_WRITE,CLOSE a.html</span><br><span class="line">/var/www/html/ OPEN,ISDIR </span><br><span class="line">/var/www/html/ ACCESS,ISDIR </span><br><span class="line">.....</span><br><span class="line">/var/www/html/ MOVED_FROM b.html</span><br><span class="line">/var/www/html/ MOVED_TO a.html</span><br></pre></td></tr></table></figure><p>仅仅几步操作，就生成了170多行事件信息。</p><p>##　Inotify与Rsync实时同步数据</p><p>要求分析：数据发布服务器既是Rsync服务器同时也是Inotify监控服务器，该服务器是用于发布数据的，将数据同步到Web服务器，实现Web服务器与此数据发布服务器的同步。</p><p>实验环境：</p><ul><li>数据发布服务器：192.168.205.135</li><li>Web服务器：192.168.205.134</li></ul><p>首先需要在Web服务器上编写<code>rsyncd.conf</code>，添加模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[www]</span><br><span class="line">comment = web file dictionary</span><br><span class="line">path = /var/www/html</span><br><span class="line">auth users = www</span><br><span class="line">secrets file = /etc/rsyncd.secrets</span><br><span class="line">hosts allow = 192.168.205.135</span><br></pre></td></tr></table></figure><p>进行系统准备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在Web服务器上创建用户www</span><br><span class="line">useradd www &amp;&amp; echo &quot;redhat&quot; | passwd www --stdin</span><br><span class="line">echo &quot;www:redhat&quot; &gt;&gt; /etc/rsyncd.secrets</span><br><span class="line">chmod 600 /etc/rsyncd.secrets</span><br><span class="line">查看/var/www是否所属于www，若不是就chown -R www:www /var/www</span><br><span class="line"></span><br><span class="line"># 在数据发布服务器上</span><br><span class="line">ssh-keygen</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub www@192.168.205.134</span><br><span class="line"># 在Web服务器上，同理，双向交换ssh公钥</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@192.168.205.135</span><br></pre></td></tr></table></figure><p>数据发布服务器上触发同步脚本示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">SRC=/var/www/web_html/</span><br><span class="line">DST=www@192.168.205.134::www</span><br><span class="line">/usr/bin/inotifywait -d -r -o var/log/inotify_web -e modify,delete,create,attrib $&#123;SRC&#125; | while read line</span><br><span class="line">do</span><br><span class="line">    /usr/bin/rsync -az --delete $&#123;SRC&#125; $&#123;DST&#125; 2&gt;&amp;1</span><br><span class="line">done &amp;</span><br></pre></td></tr></table></figure><p>加上执行权限<code>chmod a+x</code>并写入<code>/etc/rc.local</code>，<code>echo &quot;脚本名&quot; &gt;&gt; /etc/rc.local</code></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.cnblogs.com/george-guo/p/7718515.html" target="_blank" rel="noopener">rsync</a></li><li><a href="http://blog.51cto.com/atong/1344829" target="_blank" rel="noopener">Rsync原理详解及部署</a></li><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7220009.html" target="_blank" rel="noopener">Rsync完全手册</a></li><li><a href="http://blog.51cto.com/chenhao6/1298375" target="_blank" rel="noopener">inotify+rsync+mutt+msmtp 实现linux文件或者目录自动更新并且实现发邮件给管理员</a></li><li>Linux运维之道（第二版）</li><li><a href="http://www.ttlsa.com/web/let-infotify-rsync-fast/" target="_blank" rel="noopener">真正的inotify+rsync实时同步 彻底告别同步慢</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> Rsync </tag>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux性能监控常用命令</title>
      <link href="/2018/08/01/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/08/01/Linux%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<ul><li><a href="">top与htop</a></li><li><a href="">uptime,free和vmstat</a></li><li><a href="">mpstat与iostat</a></li><li><a href="">ps和pstree</a></li><li></li></ul><a id="more"></a><h1 id="top与htop"><a href="#top与htop" class="headerlink" title="top与htop"></a>top与htop</h1><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>查看动态进程状态，默认每5秒刷新一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line">-d：指定top刷新的时间间隔，默认是5 秒</span><br><span class="line">-b：批处理模式，每次刷新分批显示</span><br><span class="line">-n：指定top刷新几次就退出，可以配合-b使用</span><br><span class="line">-p：指定监控的pid，指定方式为-pN1 -pN2 ...或-pN1, N2 [,...]</span><br><span class="line">-u：指定要监控的用户的进程，可指定UID或用户名</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">top - 02:20:36 up  6:48,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">Tasks: 145 total,   2 running, 143 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  2029396 total,  1600964 free,   161512 used,   266920 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2097148 free,        0 used.  1670652 avail Mem </span><br><span class="line"># Tasks为进程数</span><br><span class="line"># us：用户占用cpu百分比</span><br><span class="line">  sy：系统占用cpu百分比</span><br><span class="line">  ni：进程空间内改变过优先级的进程占cpu百分比</span><br><span class="line">  id：空闲cpu百分比</span><br><span class="line">  wa：I/O等待时间比率</span><br><span class="line">  hi：不可中断睡眠时间比率</span><br><span class="line">  si：可中断睡眠时间比率</span><br><span class="line">  st：被偷走时间比率，一般为虚拟机占用</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND    </span><br><span class="line"># PR：优先级</span><br><span class="line"># NI：nice值，负数为高优先级，正数为低优先级</span><br><span class="line"># VIRT：虚拟内存总量    </span><br><span class="line"># RES：进程实际使用内存    </span><br><span class="line"># SHR：共享内存  </span><br><span class="line"># S：进程状态。有五种状态：D-不可中断的睡眠态  R-运行态  S-睡眠态  T-停止  Z-僵尸态</span><br><span class="line"># TIME+：进程使用CPU的时间总计（单位1/100秒）</span><br></pre></td></tr></table></figure><p>进入top视图后的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1：查看每个逻辑CPU的状况</span><br><span class="line">P：按cpu使用率排序（默认） </span><br><span class="line">M：按内存使用率排序 </span><br><span class="line">N：按PID排序 </span><br><span class="line">T：根据TIME+进行排序</span><br><span class="line">H：切换为线程</span><br><span class="line">l：切换负载信息</span><br><span class="line">m：切换显示内存信息（只是将数字改为类似进度条）</span><br><span class="line">t：切换显示进程和CPU状态信息（只是将数字改为类似进度条）</span><br><span class="line">k：指定要杀死的进程号</span><br><span class="line">A：切换显示模式。有四个窗口，在左上角显示，按a（后一个）或w（前一个）进行窗口切换</span><br><span class="line">    Def：默认字段组  Job：任务字段组  Mem：内存字段组  Usr：用户字段组</span><br><span class="line">d或s：修改刷新间隔</span><br><span class="line">f：选择要添加显示的字段，标上*为已选的</span><br><span class="line">R：反向排序</span><br><span class="line">c：显示进程的完整命令路径名</span><br><span class="line">V：树视图，命令会按进程的父子关系显示</span><br><span class="line">u：显示指定用户的进程</span><br><span class="line">n或#：设置最多显示的进程量</span><br><span class="line">r：设置指定进程的nice优先级</span><br></pre></td></tr></table></figure><h2 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h2><p>默认没有安装，需要<code>dnf install htop</code></p><p>可通过鼠标点击操作，<code>h</code>查看帮助</p><h1 id="uptime-free和vmstat"><a href="#uptime-free和vmstat" class="headerlink" title="uptime,free和vmstat"></a>uptime,free和vmstat</h1><h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>获取主机运行时间，查询系统负载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">09:05:53 up 12 days,13:33,2 users,load average: 0.01,0.02,0.05</span><br><span class="line">09:05:53--当前时间</span><br><span class="line">up 12 days, 13:33--系统启动时长</span><br><span class="line">2 users--当前登录系统的用户数</span><br><span class="line">load average: 0.01,0.02,0.05--系统在最近的1,5,15分钟的平均负载</span><br></pre></td></tr></table></figure><blockquote><p>负载率(load)，即特定时间长度内，cpu运行队列中的平均进程数(包括线程)，一般平均每分钟每核的进程数小于3都认为正常，大于5时负载已经非常高。Linux运行队列包括正在运行的、在等待的、处于可中断睡眠态（IO等待）的进程。若为多核CPU，还需要除以核数。</p><p>平均负载最佳值为1，意味着每个进程都能立刻访问CPU，并且没有丢失CPU周期</p></blockquote><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>查看内存与swap分区使用状况，实际是从<code>/proc/meminfo</code>中读取数据的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">free</span><br><span class="line"> -b         单位b</span><br><span class="line"> -k         单位kb（默认）</span><br><span class="line"> -m         单位mb</span><br><span class="line"> -g         单位gb</span><br><span class="line"> -h         自动选择单位</span><br><span class="line"> -l         显示高内存、低内存详细统计数据</span><br><span class="line"> -t         显示内存与swap的总和</span><br><span class="line"> -s N       设置刷新周期（单位秒），ctrl+C退出</span><br><span class="line"> -c N       设置刷新次数</span><br><span class="line"> -w         分开显示buffers和cache</span><br><span class="line"></span><br><span class="line">total  used  free  shared  buff/cache  available</span><br><span class="line"># cache为缓存：把读取的数据放在内存中，再次读的话就直接从内存中读了，加快读取</span><br><span class="line"># buffer为缓冲：写入数据时，把分散的写入操作保存到内存中，然后集中写入硬盘，减少磁盘碎片与硬盘反复寻道，加快写入</span><br></pre></td></tr></table></figure><h2 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h2><p>报告进程、内存、分页、块IO、中断、CPU活动信息，能够显示平均数据和实时样本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vmstat [options] [delay [count]]</span><br><span class="line"> -a      显示内存信息</span><br><span class="line"> -f      显示自从系统启动以来产生的子进程数量</span><br><span class="line"> -m      显示slab信息</span><br><span class="line"> -n      与-a类似</span><br><span class="line"> -s      事件计数器和内存状态</span><br><span class="line"> -d      磁盘状态</span><br><span class="line"> -D      磁盘状态概述</span><br><span class="line"> -p 分区  磁盘分区统计信息</span><br><span class="line"> -S 单位  输出与-n一致，但可指定单位</span><br><span class="line"> -t      显示时间戳，输出比-n增加了一项CST时间戳</span><br><span class="line"> 刷新间隔 [次数]  设置持续刷新间隔及刷新次数</span><br></pre></td></tr></table></figure><ul><li>虚拟内存模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vmstat      </span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line">Proc：</span><br><span class="line">  r：可运行进程的数量（正在运行+等待运行）</span><br><span class="line">  b：不可中断睡眠进程的数量</span><br><span class="line">memory：</span><br><span class="line">  swpd：虚拟内存使用量</span><br><span class="line">  free：空闲内存</span><br><span class="line">  buff：缓冲区内存</span><br><span class="line">  cache：用作缓存的内存</span><br><span class="line">swap：</span><br><span class="line">  si：swap in,从磁盘换入的内存数量/s</span><br><span class="line">  so：swap out,交换到磁盘的内存数量/s</span><br><span class="line">io：</span><br><span class="line">  bi：block in,从块设备收到的块数/s</span><br><span class="line">  bo：block out,发送到块设备的块数/s</span><br><span class="line">system：</span><br><span class="line">  in：interrupt,每秒中断数量</span><br><span class="line">  cs：context switch,每秒上下文切换数量</span><br><span class="line">cpu：</span><br><span class="line">  us：非内核代码运行时间</span><br><span class="line">  sy：内核代码运行时间</span><br><span class="line">  id：idle,空闲花费时间，包含IOwait时间</span><br><span class="line">  wa：wait,IO等待花费时间</span><br><span class="line">  st：steal,虚拟软件花费时间</span><br></pre></td></tr></table></figure><ul><li>磁盘模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vmstat -d</span><br><span class="line">disk- ------------reads------------ ------------writes----------- -----IO------</span><br><span class="line">       total merged sectors      ms  total merged sectors      ms    cur    sec</span><br><span class="line">disk：磁盘名</span><br><span class="line">reads：</span><br><span class="line">  total：成功读取的总量</span><br><span class="line">  merged：合并后分组的读</span><br><span class="line">  sectors：成功读取的扇区</span><br><span class="line">  ms：读取花费时间（单位毫秒）</span><br><span class="line">writes：</span><br><span class="line">  total：成功写入的总量</span><br><span class="line">  merged：合并后分组的写</span><br><span class="line">  sectors：成功写入的扇区</span><br><span class="line">  ms：写入花费时间（单位毫秒）</span><br><span class="line">IO：</span><br><span class="line">  cur：正在进行的IO</span><br><span class="line">  sec：IO花费时间（单位秒）</span><br></pre></td></tr></table></figure><h1 id="mpstat与iostat"><a href="#mpstat与iostat" class="headerlink" title="mpstat与iostat"></a>mpstat与iostat</h1><p><code>mpstat</code>与<code>iostat</code>都在<code>sysstat</code>包中，若没有这两个命令，则需要安装<code>dnf install sysstat</code></p><h2 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h2><p>用于报告在多处理器服务器上每个可用CPU的统计数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mpstat [ 选项 ] [ &lt;时间间隔&gt; [ &lt;次数&gt; ] ]</span><br><span class="line">  -A     相当于-u -I ALL -P ALL</span><br><span class="line">  -I &#123;SUM|CPU|SCPU|ALL&#125;  报告中断统计数据</span><br><span class="line">    SUM  报告每个处理器中断的总数量，显示CPU编号和intr/s一个或多个CPU每秒接收每个独特中断的个数</span><br><span class="line">    CPU  显示intr/s，但排列难以阅读</span><br><span class="line">    SCPU 显示intr/s，排版容易阅读</span><br><span class="line">    ALL  显示所有中断统计信息</span><br><span class="line">  -P &#123;cpu编号|ON|ALL&#125; </span><br><span class="line">    cpu  指明统计的cpu编号（0开始）</span><br><span class="line">    ON   每个在线CPU的统计数据</span><br><span class="line">    ALL  所有CPU的统计数据</span><br><span class="line">  -u  统计CPU使用率，输出与-P一致</span><br><span class="line">  时间间隔interval [次数times]   指定报告时间间隔及次数，最后会生成平均值</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mpstat -u</span><br><span class="line">CPU  %usr  %nice  %sys  %iowait  %irq  %soft  %steal  %guest  %gnice  %idle</span><br><span class="line">CPU：CPU编号</span><br><span class="line">%usr：用户级别（应用）执行时CPU使用率</span><br><span class="line">%nice：用户级别使用nice优先级执行时CPU使用率</span><br><span class="line">%sys：系统级别（内核）执行时CPU使用率（不包括硬件软件中断服务的时间）</span><br><span class="line">%iowait：系统未完成磁盘I/O请求期间，CPU空闲时间百分比</span><br><span class="line">%irq：CPU硬件中断时间百分比</span><br><span class="line">%soft：CPU软件中断时间百分比</span><br><span class="line">%steal：虚拟化软件为其他虚拟CPU服务时，虚拟CPU非主动等待时间百分比</span><br><span class="line">%guest：CPU运行虚拟处理器花费时间百分比</span><br><span class="line">%idle：CPU空闲时间百分比</span><br></pre></td></tr></table></figure><h2 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h2><h1 id="ps和pstree"><a href="#ps和pstree" class="headerlink" title="ps和pstree"></a>ps和pstree</h1><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>ps命令有两种风格：BSD和Unix。BSD格式的参数前不加<code>-</code>，Unix格式会在参数前加<code>-</code></p><ul><li>查看所有进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ps ax    # a表示此tty下的所有程序（不区分用户），x表示所有程序（不区分tty终端机），若增加u参数，可以用户为主的格式来显示程序状况</span><br><span class="line">ps -ef   # -e显示所有程序，只显示PID、TTY、TIME、CMD，-f增加显示UID、PPID、C、STIME</span><br><span class="line"></span><br><span class="line">ps aux</span><br><span class="line">USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br><span class="line">USER：进程发起用户 </span><br><span class="line">PID：进程号 </span><br><span class="line">%CPU，%MEM：CPU，内存占用率</span><br><span class="line">VSZ：虚拟内存（单位kb） </span><br><span class="line">RSS：常驻内存（实际物理内存）（单位kb） </span><br><span class="line">TTY：该进程在哪个终端运行</span><br><span class="line">STAT：进程状态</span><br><span class="line">S：可中断睡眠</span><br><span class="line">&lt;：高优先级</span><br><span class="line">s：子进程</span><br><span class="line">+：位于后台</span><br><span class="line">R：运行（Running）</span><br><span class="line">T：停止状态（Terminate）</span><br><span class="line">Z：僵尸进程（Zombie）</span><br><span class="line">START————进程开启时间</span><br><span class="line">TIME：进程已启动时间</span><br><span class="line">COMMAND：产生进程的命令名</span><br><span class="line"></span><br><span class="line">ps -ef中不同的几个</span><br><span class="line">PPID：父进程ID</span><br><span class="line">C：CPU占用率</span><br><span class="line">STIME：进程启动时间</span><br></pre></td></tr></table></figure><ul><li>显示用户进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -f -u [用户名1,用户名2...]   #-u指定用户，可指定多个，不能加-e，不然等于没指定</span><br><span class="line">例：ps -f -u apache</span><br></pre></td></tr></table></figure><ul><li>显示指定进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -f -C [进程]    # -C指定进程名，进程名必须是精确的，不能用通配符。同样不能指定-e</span><br><span class="line">例：ps -f -C httpd</span><br><span class="line">ps -f -p [进程号]  # -p指定进程号</span><br></pre></td></tr></table></figure><ul><li>通过cpu或内存占用对进程排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef --sort=[+|-]pcpu,[+|-]pmem</span><br><span class="line">--sort用于指定多个字段，pcpu为按CPU排序，pmem为按内存排序，+为升序，-为降序</span><br><span class="line">例：ps -ef --sort=-pcpu | head -6 显示CPU占用排名前五的进程</span><br></pre></td></tr></table></figure><ul><li>以树显示进程层级关系</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -f --forest</span><br><span class="line">例：ps -f --forest -C httpd</span><br></pre></td></tr></table></figure><ul><li>查看指定父进程下的所有子进程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps --ppid [PPID]</span><br></pre></td></tr></table></figure><ul><li>显示进程的线程</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -f -L -C [进程]或-p [进程号]   #显示指定进程的线程</span><br><span class="line">例：ps -f -L -C httpd</span><br></pre></td></tr></table></figure><ul><li>指定要显示的列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,uname,pcpu,pmem,comm,etime</span><br><span class="line">其中：uname为用户名，etime为进程已运行时间</span><br></pre></td></tr></table></figure><ul><li>通过<code>watch</code>命令将ps变为实时查看器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watch</span><br><span class="line">  -n 指定指令执行间隔</span><br><span class="line">  -d 高亮显示指令输出信息不同之处</span><br><span class="line">例：watch -n 1 &apos;ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pcpu,-pmem | head -11&apos;</span><br></pre></td></tr></table></figure><h2 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h2><p>查看进程树，常用选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-p          显示进程PID</span><br><span class="line">-g          显示进程组ID，即PGID</span><br><span class="line">-u          显示进程所属用户</span><br><span class="line">-a          显示进程的命令及参数</span><br><span class="line">-H PID      高亮显示指定进程及它的所有父进程</span><br><span class="line">-T          只显示进程，不显示线程</span><br><span class="line">-t          显示完整的线程名</span><br><span class="line">-s          显示进程的父进程</span><br><span class="line">-n          按PID排序输出</span><br><span class="line">-Z          显示selinux上下文（需要开启selinux）</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://www.binarytides.com/linux-ps-command/" target="_blank" rel="noopener">10 basic examples of Linux ps command</a></li><li><a href="https://linux.cn/article-2358-1.html" target="_blank" rel="noopener">ps命令的10个例子</a></li><li>Linux性能优化大师</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
            <tag> 性能 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LVM逻辑卷与RAID磁盘阵列学习笔记</title>
      <link href="/2018/08/01/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E4%B8%8ERAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/01/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E4%B8%8ERAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容</p><ul><li><a href="#LVM逻辑卷">LVM逻辑卷</a><ul><li><a href="#LVM概述">LVM概述</a></li><li><a href="#LVM创建与调整">LVM创建与调整</a></li><li><a href="#LVM快照">LVM快照</a></li></ul></li><li><a href="#RAID磁盘阵列">RAID磁盘阵列</a><ul><li><a href="#RAID概述">RAID概述</a></li><li><a href="#RAID基础搭建">RAID基础搭建</a><a id="more"></a></li></ul></li></ul><h1 id="LVM逻辑卷"><a href="#LVM逻辑卷" class="headerlink" title="LVM逻辑卷"></a>LVM逻辑卷</h1><h2 id="LVM概述"><a href="#LVM概述" class="headerlink" title="LVM概述"></a>LVM概述</h2><p>LVM(<code>Logical Volume Manager</code>)逻辑卷管理器，可以灵活调整存储空间大小，并不会对现有数据造成任何损坏。红帽系的系统全部默认开启了LVM。</p><p>几个关键术语：</p><ul><li>PV(<code>Physical Volume</code>，物理卷)：最低层的存储设备（硬盘，分区）</li><li>VG(<code>Volume Group</code>，卷组)：单个或多个PV构成的存储资源池，不能直接存放数据</li><li>LV(<code>Logical Volume</code>，逻辑卷)：从VG中划分出的存储空间，可直接存放数据</li><li>PE(<code>Physical Extend</code>，物理扩展单元)：逻辑层面上最小的存储单元（类似block），一个PE大小4MB，是告诉PV，表明存储单元位于PV的哪个位置。PE大小必须满足2的指数幂</li><li>LE(<code>Logical Extend</code>，逻辑扩展单元)：与PE类似，默认情况下，PE与LE一样大。LE告诉LV，表明存储单元处于VG的哪个位置</li></ul><p>LVM创建流程：</p><ol><li>使用几块硬盘或分区（未创建文件系统）创建物理卷，并将分区的识别号设置为LVM，即<code>8e</code></li><li>将多个物理卷组合成一个卷组，卷组会根据指定的PE大小将空间划分为多个PE，在LVM中存储以PE为单元</li><li>在卷组中分出逻辑卷，这些逻辑卷在外界看来就是多个独立的硬盘分区</li><li>对逻辑卷制作文件系统，并挂载</li></ol><img src="/2018/08/01/LVM逻辑卷与RAID磁盘阵列学习笔记/1.png"><p>LVM写入机制：<br>LV是从VG中划分出来的，LV中的PE很可能来自于多个PV。在向LV存储数据时，有多种存储机制，其中两种是：</p><ul><li>线性模式(<code>linear</code>)：先写完来自于同一个PV的PE，再写来自于下一个PV的PE。</li><li>条带模式(<code>striped</code>)：一份数据拆分成多份，分别写入该LV对应的每个PV中，所以读写性能较好，类似于RAID 0。</li></ul><p>尽管<code>striped</code>读写性能较好也不建议使用该模式，因为lvm的着重点在于弹性容量扩展而非性能，要实现性能应该使用RAID来实现，而且使用<code>striped</code>模式时要进行容量的扩展和收缩将比较麻烦。默认的是使用线性模式。</p><blockquote><p>引用自<a href="http://www.cnblogs.com/f-ck-need-u/p/7049233.html#auto_id_1" target="_blank" rel="noopener">骏马金龙的LVM详解</a></p></blockquote><h2 id="LVM创建与调整"><a href="#LVM创建与调整" class="headerlink" title="LVM创建与调整"></a>LVM创建与调整</h2><p>实验环境：</p><ul><li>CentOS7</li><li><code>/dev/sdb</code>　大小20G</li><li>将<code>/dev/sdb</code>分为4个分区，每个分区5G，并将磁盘标识号设为<code>8e</code>，表示LVM</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l /dev/sdb</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0xde948938</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048    10487807     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdb2        10487808    20973567     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdb3        20973568    31459327     5242880   8e  Linux LVM</span><br><span class="line">/dev/sdb4        31459328    41943039     5241856   8e  Linux LVM</span><br></pre></td></tr></table></figure><ol><li>准备裸磁盘与裸分区，制作PV<br>使用<code>pvcreate [裸磁盘/裸分区]</code>创建PV</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pvcreate /dev/sdb1 /dev/sdb2 /dev/sdb3 /dev/sdb4</span><br><span class="line">  Physical volume &quot;/dev/sdb1&quot; successfully created.</span><br><span class="line">  Physical volume &quot;/dev/sdb2&quot; successfully created.</span><br><span class="line">  Physical volume &quot;/dev/sdb3&quot; successfully created.</span><br><span class="line">  Physical volume &quot;/dev/sdb4&quot; successfully created.</span><br></pre></td></tr></table></figure><p>可使用<code>pvdisplay [磁盘/分区]</code>查看pv信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pvdisplay选项列表</span><br><span class="line">  若不指定磁盘或分区，就是查看所有PV</span><br><span class="line">  -m    # 查看该设备中PE的使用分布图</span><br><span class="line">  -s    # 查看pv简短信息</span><br></pre></td></tr></table></figure></p><p><code>pvs</code>或<code>pvscan</code>也可查看所有PV信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># pvscan </span><br><span class="line">  PV /dev/sda2   VG centos          lvm2 [&lt;19.00 GiB / 0    free]</span><br><span class="line">  PV /dev/sdb4                      lvm2 [&lt;5.00 GiB]</span><br><span class="line">  PV /dev/sdb2                      lvm2 [5.00 GiB]</span><br><span class="line">  PV /dev/sdb1                      lvm2 [5.00 GiB]</span><br><span class="line">  PV /dev/sdb3                      lvm2 [5.00 GiB]</span><br><span class="line">  Total: 5 [&lt;39.00 GiB] / in use: 1 [&lt;19.00 GiB] / in no VG: 4 [&lt;20.00 GiB]</span><br><span class="line">  最后一行显示的是&quot;pv的总容量/已使用的pv容量/空闲的pv容量&quot;</span><br></pre></td></tr></table></figure></p><p><code>pvremove [分区]</code>删除PV<br><code>pvmove [分区]</code>删除PV中的所有数据</p><ol><li>制作VG<br><code>vgcreate [VG名][多个裸磁盘]</code>制作卷组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vgcreate选项列表</span><br><span class="line">  -s    # 指定PE大小。不指定默认大小4M</span><br><span class="line">  -l    # 卷组上允许创建的最大逻辑卷数</span><br><span class="line">  -p    # 卷组中允许添加的最大物理卷数</span><br><span class="line">  在创建VG后，只有VG没有数据时才能修改属性，如PE大小</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vgcreate -s 8M my_vg1 /dev/sdb1 /dev/sdb2</span><br><span class="line">  Volume group &quot;my_vg1&quot; successfully created</span><br><span class="line"># vgcreate -s 8M my_vg2 /dev/sdb3 /dev/sdb4</span><br><span class="line">  Volume group &quot;my_vg2&quot; successfully created</span><br></pre></td></tr></table></figure><p><code>vgdisplay [VG名]</code>查看VG信息<br><code>vgs</code>和<code>vgscan</code>也可显示所有VG信息</p><p><code>vgreduce [VG名] [PV名]</code>从VG中删除指定PV<br><code>vgextend [VG名] [PV名]</code>添加PV到VG中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vgreduce my_vg1 /dev/sdb2</span><br><span class="line">  Removed &quot;/dev/sdb2&quot; from volume group &quot;my_vg1&quot;</span><br><span class="line"># vgextend my_vg1 /dev/sdb2</span><br><span class="line">  Volume group &quot;my_vg1&quot; successfully extended</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vgchange [选项] [VG名]  修改卷组的属性</span><br><span class="line">经常被用来设置卷组是处于活动状态或非活动状态。</span><br><span class="line">处于活动状态的卷组无法被删除，必须使用vgchange命令将卷组设置为非活动状态后才能删除。</span><br><span class="line">  -a y|n 设置卷组的活跃|非活跃状态</span><br></pre></td></tr></table></figure><p><code>vgremove [VG名]</code>删除VG</p><ol><li>创建逻辑卷LV<br><code>lvcreate -L N -n [LV名][VG名]</code>创建逻辑卷<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lvcreate选项列表</span><br><span class="line">  -L N    # 指定逻辑卷大小N，若N不是PE的整数倍，系统会自动将LV大小变大为PE整数倍</span><br><span class="line">  -n      # 指定LV名</span><br><span class="line">  -l n    # 指定PE个数，即通过PE个数指定逻辑卷大小</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># lvcreate -L 6G -n my_lv1 my_vg1</span><br><span class="line">  Logical volume &quot;my_lv1&quot; created.</span><br><span class="line"># lvcreate -l 1000 -n my_lv2 my_vg2</span><br><span class="line">  Logical volume &quot;my_lv2&quot; created.</span><br><span class="line"></span><br><span class="line"># lvscan </span><br><span class="line">  ACTIVE            &apos;/dev/centos/swap&apos; [2.00 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/centos/root&apos; [&lt;17.00 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/my_vg2/my_lv2&apos; [7.81 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/my_vg1/my_lv1&apos; [6.00 GiB] inherit</span><br></pre></td></tr></table></figure><p><code>lvdisplay [LV名]</code>查看指定或所有LV详细信息<br><code>lvs</code>和<code>lvscan</code>可查看全部LV信息</p><p><code>lvextend [选项] +[扩容大小] [LV]</code>用于扩展逻辑卷的空间大小，而不中断应用程序对逻辑卷的访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lvextend选项</span><br><span class="line">  -L 指定逻辑卷的大小</span><br><span class="line">  -l 指定逻辑卷的大小（LE数）</span><br><span class="line">  若不添加加号，则要指定扩容后的大小（一定要比增容前大）</span><br><span class="line">  若添加加号，则要指定要扩容的大小</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lvextend -L +100M /dev/my_vg1/my_lv1 </span><br><span class="line">  Rounding size to boundary between physical extents: 104.00 MiB.</span><br><span class="line">  Size of logical volume my_vg1/my_lv1 changed from 6.00 GiB (768 extents) to 6.10 GiB (781 extents).</span><br><span class="line">  Logical volume my_vg1/my_lv1 successfully resized.</span><br><span class="line"></span><br><span class="line"># lvextend -l +10 /dev/my_vg2/my_lv2 </span><br><span class="line">  Size of logical volume my_vg2/my_lv2 changed from 7.81 GiB (1000 extents) to 7.89 GiB (1010 extents).</span><br><span class="line">  Logical volume my_vg2/my_lv2 successfully resized.</span><br></pre></td></tr></table></figure><p><code>lvreduce [选项] -[缩小大小] [LV]</code>减少LVM逻辑卷占用的空间大小。有可能会删除逻辑卷上已有的数据<br>参数与用法与<code>lvextend</code>一致<br><code>lvresize [选项] [+|-][扩大或缩小大小] [LV]</code>调整LVM逻辑卷的空间大小，可以增大空间和缩小空间，可能会使逻辑卷上已有的数据丢失<br>参数与用法与<code>lvextend</code>与<code>lvreduce</code>一致。</p><p>若该LV已制作完文件系统并挂载完成，而要对该LV进行容量的改变操作，首先需要<code>umount</code>将挂载取消，然后使用上述命令进行容量改变操作，然后再制作文件系统并挂载。<br><strong>然而，通过任何查看命令都会发现LV大小并没有改变。因此，在改变大小后，还要继续以下操作。</strong></p><ul><li>若文件系统为<code>ext4</code>，则需要执行<code>resize2fs [LV路径]</code></li><li>若文件系统为<code>xfs</code>，则需要执行<code>xfs_growfs [LV路径]</code><br><strong>xfs文件系统只支持增大分区空间的情况，不支持减小的情况</strong>。硬要减小的话，只能在减小后将逻辑分区重新通过mkfs.xfs命令重新格式化才能挂载上，这样的话这个逻辑分区上原来的数据就丢失了。<br><code>xfs</code>是不支持裁剪的，<code>ext</code>是支持裁剪的，所以<code>xfs</code>尽量不要缩小LV</li></ul><p>建议在修改容量后执行<code>e2fsck -f [LV路径]</code>检查是否修改后的大小会影响数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># e2fsck -f /dev/my_vg1/my_lv1 </span><br><span class="line">e2fsck 1.42.9 (28-Dec-2013)</span><br><span class="line">Pass 1: Checking inodes, blocks, and sizes</span><br><span class="line">Pass 2: Checking directory structure</span><br><span class="line">Pass 3: Checking directory connectivity</span><br><span class="line">Pass 4: Checking reference counts</span><br><span class="line">Pass 5: Checking group summary information</span><br><span class="line">/dev/my_vg1/my_lv1: 11/400624 files (0.0% non-contiguous), 64167/1599488 blocks</span><br></pre></td></tr></table></figure></p><p><code>lvremove　[LV名]</code>删除指定LV</p><h2 id="LVM快照"><a href="#LVM快照" class="headerlink" title="LVM快照"></a>LVM快照</h2><p>LVM提供快照功能，可将逻辑卷的数据进行备份，并可快速恢复</p><p>实验选用<code>/dev/my_vg1/my_lv1</code>，并将该LV挂载在<code>/my_lv1</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># lvdisplay /dev/my_vg1/my_lv1 </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/my_vg1/my_lv1</span><br><span class="line">  LV Name                my_lv1</span><br><span class="line">  VG Name                my_vg1</span><br><span class="line">......</span><br><span class="line">  LV Size                6.10 GiB</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p><code>lvcreate -s -n [快照名] -L [快照大小] [LV路径]</code>创建快照<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s 创建快照</span><br><span class="line">-n 指定快照名</span><br><span class="line">-L 快照大小</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># lvcreate -s -L 1G -n my_snapshot /dev/my_vg1/my_lv1</span><br><span class="line">  Using default stripesize 64.00 KiB.</span><br><span class="line">  Logical volume &quot;my_snapshot&quot; created.</span><br><span class="line"></span><br><span class="line">可通过lvscan查看，最后多了一条快照信息</span><br><span class="line"># lvscan </span><br><span class="line">  ACTIVE            &apos;/dev/centos/swap&apos; [2.00 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/centos/root&apos; [&lt;17.00 GiB] inherit</span><br><span class="line">  ACTIVE            &apos;/dev/my_vg2/my_lv2&apos; [7.89 GiB] inherit</span><br><span class="line">  ACTIVE   Original &apos;/dev/my_vg1/my_lv1&apos; [6.10 GiB] inherit</span><br><span class="line">  ACTIVE   Snapshot &apos;/dev/my_vg1/my_snapshot&apos; [1.00 GiB] inherit</span><br></pre></td></tr></table></figure><p>在<code>/my_lv1</code>中创建文件<code>dd if=/dev/zero of=/my_lv1/files count=1 bs=100M</code><br>然后将该LV卸载<code>umount /my_lv1</code><br>最后将快照恢复<code>lvconvert --merge /dev/my_vg1/my_snapshot</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># lvconvert --merge /dev/my_vg1/my_snapshot</span><br><span class="line">  Merging of volume my_vg1/my_snapshot started.</span><br><span class="line">  my_lv1: Merged: 69.90%</span><br><span class="line">  my_lv1: Merged: 100.00%</span><br><span class="line">快照恢复过后会自动删除</span><br></pre></td></tr></table></figure></p><p>将LV重新挂载到<code>/my_lv1</code>，发现文件夹中已经没有任何文件了，说明快照恢复成功。</p><h1 id="RAID磁盘阵列"><a href="#RAID磁盘阵列" class="headerlink" title="RAID磁盘阵列"></a>RAID磁盘阵列</h1><h2 id="RAID概述"><a href="#RAID概述" class="headerlink" title="RAID概述"></a>RAID概述</h2><p>Redundant Array of Independent Disks独立硬盘组，作用是防止硬盘物理损坏以及增加存储设备的吞吐量。<br>常见的RAID形式有：<code>RAID 0</code>、<code>RAID 1</code>、<code>RAID 3</code>、<code>RAID 5</code>、<code>RAID 6</code>、<code>RAID 10</code>、<code>RAID 01</code>、<code>RAID 50</code>。</p><ul><li><code>RAID 0</code>：将多个磁盘合并为1个大磁盘，读写速度极大提高，但不具冗余，因为通过硬件或软件串联，数据是依次被写入各个硬盘，所以任何一块损坏都会导致数据丢失。</li><li><code>RAID 1</code>：两组以上的N个硬盘相互做镜像，让数据被多块硬盘同时写入。一块损坏可立刻通过热交换恢复数据。由于做备份，硬盘空间只有50%。</li><li><code>RAID 3</code>：将数据条块化分布于不同的硬盘上，使用简单的奇偶校验，并用单块磁盘存放奇偶校验信息。如果一块磁盘失效，奇偶盘及其他数据盘可以重新产生数据;如果奇偶盘失效则不影响数据使用。RAID 3对于大量的连续数据可提供很好的传输率，但对于随机数据来说，奇偶盘会成为写操作的瓶颈。</li><li><code>RAID 5</code>：使用硬盘分割技术，至少需3块硬盘。既提高传输速度，也可实现镜像备份。但采用奇偶校验信息，写速度相当慢，读速度与RAID0相近，且镜像保障程度也不及RAID1。空间利用率高。是在所有磁盘上交叉存储数据与奇偶校验信息，并不是单独保存在某块内存中，而是分别互相保存在每一块硬盘，raid5并不是备份实际硬盘数据，而是在硬盘出现故障后通过奇偶校验信息尝试恢复数据。<br><code>RAID5</code>的利用率为总可用盘容量的<code>(n-1)/n</code></li><li><code>RAID 6</code>：相较RAID5增加第二个独立的奇偶校验信息块，数据可靠性非常高，需要四个以上硬盘</li><li><code>RAID 7</code>：全称是最优化的异步高 I/O 速率和高数据传输率，不仅仅是一种技术，它还是一个独立存储计算机，自身带的操作系统和管理工具，完全可以独立运行。采用了非同步访问，极大地减轻了数据写瓶颈，提高了 I/O 速度，存储计算机操作系统可使主机 I/O 传递性能达到最佳，能够自动执行恢复操作，并可管理备份磁盘的重建过程。该技术已被raid7公司垄断。</li><li><code>RAID 10（企业主要用）/01</code>：<ul><li>10为1+0 先镜射再分割数据，两个两个组成raid1，再两组两组组成raid0，拥有较高速度与较高数据保护性，但需要4块以上且数量为偶数的硬盘数，因为使用raid1，所以利用率也是50%。安全性比01强，速度也比01强，恢复速度快于5</li><li>01为0+1 先分割再镜射，两个两个组raid0，再两组两组组raid1</li></ul></li><li><code>RAID 50</code>：至少需要6块硬盘，将数据分为条带同时存入多个磁盘，以数据校验位保证数据安全，目的在于提高RAID5的读写性能</li></ul><h2 id="RAID基础搭建"><a href="#RAID基础搭建" class="headerlink" title="RAID基础搭建"></a>RAID基础搭建</h2><p>RAID的创建管理由<code>mdadm</code>命令实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mdadm [模式] [RAID设备名] [选项] [成员设备]</span><br><span class="line">  -a    # 检测设备名</span><br><span class="line">  -As   # 激活raid（停止的时候）</span><br><span class="line">  -n    # 指定设备数量</span><br><span class="line">  -c    # 指定数据块大小</span><br><span class="line">  -l    # 指定raid级别</span><br><span class="line">  -C    # 创建</span><br><span class="line">  -v    # 显示过程</span><br><span class="line">  -G    # 修改raid</span><br><span class="line">  -f    # 模拟设备损坏</span><br><span class="line">  -r    # 移除设备</span><br><span class="line">  [raid] -a [磁盘] 将磁盘添加到raid阵列</span><br><span class="line">  [raid] -r [磁盘] 将磁盘移出raid阵列</span><br><span class="line">  -Q    # 查看摘要信息</span><br><span class="line">  -D    # 查看详细信息（cat /proc/mdstat查看阵列状态）</span><br><span class="line">  -S    # 停止阵列</span><br><span class="line">  -x    # 备份盘个数</span><br><span class="line">  --detail   # 查看RAID阵列</span><br></pre></td></tr></table></figure></p><p>实验目的：搭建<code>RAID 10</code><br>实验环境</p><ul><li>CentOS7</li><li><code>/dev/sdb</code>分出4分区，每个5G大小</li></ul><p><code>mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb1 /dev/sdb2 /dev/sdb3 /dev/sdb4</code>创建RAID</p><p>可通过<code>cat /proc/mstat</code>查看简要RAID信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cat /proc/mdstat </span><br><span class="line">Personalities : [raid10] </span><br><span class="line">md0 : active raid10 sdb4[3] sdb3[2] sdb2[1] sdb1[0]</span><br><span class="line">      10475520 blocks super 1.2 512K chunks 2 near-copies [4/4] [UUUU]</span><br></pre></td></tr></table></figure></p><p>也可通过<code>mdadm -D /dev/md0</code>查看指定RAID信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># mdadm -D /dev/md0 </span><br><span class="line">/dev/md0:</span><br><span class="line">           Version : 1.2</span><br><span class="line">     Creation Time : Thu Aug  2 09:56:25 2018</span><br><span class="line">        Raid Level : raid10</span><br><span class="line">        Array Size : 10475520 (9.99 GiB 10.73 GB)</span><br><span class="line">      # Array Size总共能使用的空间，因为是raid10，所以总可用空间为400M左右，除去元数据，大于370M左右</span><br><span class="line">     Used Dev Size : 5237760 (5.00 GiB 5.36 GB)</span><br><span class="line">   # Used Dev Size每颗raid组或设备上的可用空间，也即每个RAID1组可用大小为190M左右</span><br><span class="line">      Raid Devices : 4   # raid中设备的个数</span><br><span class="line">     Total Devices : 4   # 总设备个数，包括raid中设备个数，备用设备个数等</span><br><span class="line">       Persistence : Superblock is persistent</span><br><span class="line"></span><br><span class="line">       Update Time : Thu Aug  2 09:57:17 2018</span><br><span class="line">             State : clean   </span><br><span class="line">      # 当前raid状态，有clean/degraded(降级)/recovering/resyncing</span><br><span class="line">    Active Devices : 4</span><br><span class="line">   Working Devices : 4</span><br><span class="line">    Failed Devices : 0</span><br><span class="line">     Spare Devices : 0</span><br><span class="line"></span><br><span class="line">            Layout : near=2</span><br><span class="line">   # RAID10数据分布方式，有near/far/of set，默认为near，即数据的副本存储在相邻设备的相同偏移上。</span><br><span class="line">   # near=2表示要备份2份数据</span><br><span class="line">        Chunk Size : 512K</span><br><span class="line"></span><br><span class="line">Consistency Policy : resync</span><br><span class="line"></span><br><span class="line">              Name : bogon:0  (local to host bogon)</span><br><span class="line">              UUID : 1aa0ce46:4762919a:71542e42:47b8bc7b</span><br><span class="line">            Events : 17</span><br><span class="line"></span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync set-A   /dev/sdb1</span><br><span class="line">       1       8       18        1      active sync set-B   /dev/sdb2</span><br><span class="line">       2       8       19        2      active sync set-A   /dev/sdb3</span><br><span class="line">       3       8       20        3      active sync set-B   /dev/sdb4</span><br></pre></td></tr></table></figure></p><p>制作文件系统并挂载该RAID<br><code>mkfs.ext4 /dev/md0 &amp;&amp; mount /dev/md0 /mnt/md0</code></p><p>模拟RAID损坏，这里模拟损坏<code>/dev/sdb3</code><br><code>mdadm /dev/md0 -f /dev/sdb3</code><br>此时查看RAID信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># mdadm -D /dev/md0 </span><br><span class="line">......</span><br><span class="line">             State : clean, degraded </span><br><span class="line">    Active Devices : 3   # 活跃的设备仅3台</span><br><span class="line">   Working Devices : 3   # 工作中的设备仅3台</span><br><span class="line">    Failed Devices : 1   # 出现故障的设备1台</span><br><span class="line">     Spare Devices : 0</span><br><span class="line">......</span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync set-A   /dev/sdb1</span><br><span class="line">       1       8       18        1      active sync set-B   /dev/sdb2</span><br><span class="line">       -       0        0        2      removed</span><br><span class="line">       3       8       20        3      active sync set-B   /dev/sdb4</span><br><span class="line"></span><br><span class="line">       2       8       19        -      faulty   /dev/sdb3</span><br><span class="line">　　　　# /dev/sdb3的状态为faulty</span><br></pre></td></tr></table></figure></p><p>由于raid10允许一组raid1存在故障，不会影响使用。</p><p>进行恢复，首先要卸载文件系统<code>umount /mnt/md0</code><br>然后移除<code>/dev/sdb3</code>，<code>mdadm /dev/md0 -r /dev/sdb3</code><br>最后再次添加进RAID组，<code>mdadm /dev/md0 -a /dev/sdb3</code><br>立刻查看RAID状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># mdadm -D /dev/md0</span><br><span class="line">......</span><br><span class="line">   Active Devices : 3</span><br><span class="line">   Working Devices : 4</span><br><span class="line">    Failed Devices : 0</span><br><span class="line">     Spare Devices : 1</span><br><span class="line"></span><br><span class="line">            Layout : near=2</span><br><span class="line">        Chunk Size : 512K</span><br><span class="line"></span><br><span class="line">Consistency Policy : resync</span><br><span class="line"></span><br><span class="line">    Rebuild Status : 38% complete</span><br><span class="line"></span><br><span class="line">              Name : bogon:0  (local to host bogon)</span><br><span class="line">              UUID : 1aa0ce46:4762919a:71542e42:47b8bc7b</span><br><span class="line">            Events : 30</span><br><span class="line"></span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync set-A   /dev/sdb1</span><br><span class="line">       1       8       18        1      active sync set-B   /dev/sdb2</span><br><span class="line">       4       8       19        2      spare rebuilding   /dev/sdb3</span><br><span class="line">       3       8       20        3      active sync set-B   /dev/sdb4</span><br><span class="line">可以看出此时活跃设备仍为3台，但工作设备已变为4台，空闲设备为1台</span><br><span class="line">Rebuild Status : 38% complete 表示正在重建该设备</span><br><span class="line">在/dev/sdb3的状态上也可看出正在重建rebuilding</span><br></pre></td></tr></table></figure></p><p>若要彻底停用该阵列，只需要先卸载文件系统，然后执行<code>mdadm -S /dev/md0</code>即可。</p><h3 id="使用RAID-5进行备份"><a href="#使用RAID-5进行备份" class="headerlink" title="使用RAID 5进行备份"></a>使用<code>RAID 5</code>进行备份</h3><p><code>mdadm -Cv /dev/md0 -n 3 -x 1 -l 5 /dev/sdb1 /dev/sdb2 /dev/sdb3 /dev/sdb4</code><br>其中<code>-n 3</code>表示选择3块磁盘做主盘，<code>-x 1</code>表示选1张做备份盘，加起来一共4张磁盘。<br>此时查看RAID信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># mdadm -D /dev/md0 </span><br><span class="line">/dev/md0:</span><br><span class="line">           Version : 1.2</span><br><span class="line">     Creation Time : Thu Aug  2 10:35:01 2018</span><br><span class="line">        Raid Level : raid5</span><br><span class="line">        Array Size : 10475520 (9.99 GiB 10.73 GB)</span><br><span class="line">     Used Dev Size : 5237760 (5.00 GiB 5.36 GB)</span><br><span class="line">      Raid Devices : 3</span><br><span class="line">     Total Devices : 4</span><br><span class="line">       Persistence : Superblock is persistent</span><br><span class="line"></span><br><span class="line">       Update Time : Thu Aug  2 10:35:28 2018</span><br><span class="line">             State : clean </span><br><span class="line">    Active Devices : 3</span><br><span class="line">   Working Devices : 4</span><br><span class="line">    Failed Devices : 0</span><br><span class="line">     Spare Devices : 1</span><br><span class="line"></span><br><span class="line">            Layout : left-symmetric</span><br><span class="line">        Chunk Size : 512K</span><br><span class="line"></span><br><span class="line">Consistency Policy : resync</span><br><span class="line"></span><br><span class="line">              Name : bogon:0  (local to host bogon)</span><br><span class="line">              UUID : 9d0e9a0d:38372c14:2ad4666f:feb13f5c</span><br><span class="line">            Events : 18</span><br><span class="line"></span><br><span class="line">    Number   Major   Minor   RaidDevice State</span><br><span class="line">       0       8       17        0      active sync   /dev/sdb1</span><br><span class="line">       1       8       18        1      active sync   /dev/sdb2</span><br><span class="line">       4       8       19        2      active sync   /dev/sdb3</span><br><span class="line"></span><br><span class="line">       3       8       20        -      spare   /dev/sdb4</span><br><span class="line">可看出/dev/sdb4做了备份盘，状态为空闲</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://baike.baidu.com/item/RAID%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97/10588130?fr=aladdin" target="_blank" rel="noopener">百度百科–RAID磁盘阵列</a><br><a href="http://blog.itpub.net/787018/viewspace-666280/" target="_blank" rel="noopener">RAID基础，RAID10与RAID01比较，RAID10与RAID5比较</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/7049501.html" target="_blank" rel="noopener">骏马金龙–RAID</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/7049233.html" target="_blank" rel="noopener">骏马金龙–LVM</a><br><a href="http://www.hack520.com/169.html" target="_blank" rel="noopener">图文并茂 RAID 技术全解</a><br>Linux就该这么学</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> LVM </tag>
            
            <tag> RAID </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>STP学习笔记</title>
      <link href="/2018/07/31/STP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/31/STP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>组播学习笔记</title>
      <link href="/2018/07/31/%E7%BB%84%E6%92%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/31/%E7%BB%84%E6%92%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>基于华三网络学习笔记（理论）</strong></p><ul><li><a href="#组播概述">组播概述</a></li><li><a href="#组播组管理协议">组播组管理协议</a></li><li><a href="#组播转发机制">组播转发机制</a></li><li><a href="#组播路由协议">组播路由协议</a></li><li><a href="#"></a><a id="more"></a></li></ul><h2 id="组播概述"><a href="#组播概述" class="headerlink" title="组播概述"></a>组播概述</h2><p>组播用于实现点到多点的传输。</p><ul><li>效率高，分布式应用，多点传输</li><li>数据源仅发送一份数据包，链路仅传输一份数据包，只有组播组中接受者能收到数据包</li><li>尽最大努力交付</li><li>无拥塞控制</li><li>数据报重复</li><li>数据包无序交付</li></ul><p><strong>组播需求问题与相关技术：</strong></p><ol><li>如何标识接受者—–组播地址机制</li><li>接受者动态加入或离开组播组—–组成员关系管理</li><li>组播报文如何在网络中转发—-组播报文转发过程</li><li>组播报文转发路径（组播转发树）构建—–组播路由协议</li></ol><p>组播地址：<br>组播地址范围：<code>224.0.0.0---239.255.255.255</code></p><ul><li>本地协议预留组播地址：<code>224.0.0.0---224.0.0.255</code>，属于局部范围，不会被路由器转发</li><li>用户组播地址：<code>224.0.1.0---238.255.255.255</code>，用户可用组播地址，全网有效<br><code>232.0.0.0/8</code>为SSM组地址，其余属于ASM组</li><li>本地管理组地址：<code>239.0.0.0---239.255.255.255</code>，特定本地范围有效，属于ASM组</li><li>组播MAC地址：以太网：<code>01-00-5e-xx-xx-xx</code></li></ul><p>组播地址映射：<br>组播MAC地址中高24位固定为<code>0x01005E</code>，第25位为0，低23位来自组播IP地址的低23位。<br>组播IP地址的高4位为<code>1110</code>，标识组播，而低28位只有23位被映射到组播MAC地址，即有5位的丢失，一共会有<code>2^5</code>即32个IP地址公用一个组播MAC，也就是可能会接受所在组播组外的其他组播数据。<br><img src="/2018/07/31/组播学习笔记/1.png"></p><p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">组播IP地址为：224.231.123.14</span><br><span class="line">换成二进制：11100000 11100111 01111011 00001110</span><br><span class="line">组播MAC地址高24位为01005E，即</span><br><span class="line">0000 0001 0000 0000 0101 1110</span><br><span class="line"></span><br><span class="line">                1110|00001|11001110111101100001110   组播IP地址，共32位</span><br><span class="line">000000010000000001011110|0|11001110111101100001110   组播MAC地址，共48位</span><br><span class="line">组播IP地址中第二部分，案例中00001部分，在MAC地址中没有任何对应，一共有32种可能</span><br></pre></td></tr></table></figure></p><h2 id="组播组管理协议"><a href="#组播组管理协议" class="headerlink" title="组播组管理协议"></a>组播组管理协议</h2><p>常用的组播组管理协议为IGMP（Internet Group Management Protocol因特网组管理协议）。<br>主机通过IGMP通知路由器加入或离开某个组播组，路由器通过IGMP周期查询组播组成员是否处于活动状态，收集成员关系并维护</p><p>IGMP有三个版本：</p><ul><li>IGMPv1：定义了基本的组成员查询和报告过程</li><li>IGMPv2：添加了组成员快速离开机制</li><li>IGMPv3：添加了成员可指定接受或拒绝组播源的报文，支持SSM模型</li></ul><h3 id="IGMPv2"><a href="#IGMPv2" class="headerlink" title="IGMPv2"></a>IGMPv2</h3><p>IGMP报文：</p><ul><li><code>Type</code>：IGMP报文类型，包含<code>Membership Query</code>、<code>Report</code>、<code>Leave Group</code></li><li><code>Max Reps Time</code>：最大响应时间，只有<code>Membership Query</code>使用该字段</li><li><code>checksum</code>：校验和</li><li><code>Group Address</code>：组地址。不同报文填的不同。普遍查询填0，特定组查询填指定组播组地址，报告报文和离开报文填组播组地址</li></ul><p>IGMPv2原理：</p><ol><li>当同一网段中有多个IGMP路由器时，通过查询器选举机制（最小接口IP）选出唯一查询器。</li><li>查询器周期发送普遍查询消息<code>General Query</code>，目的地址<code>224.0.0.1</code>，<code>TTL</code>为1，进行组成员关系查询。主机收到后发送报告消息<code>Report</code>响应。也有称为<code>Membership Report</code>，但本篇统一为<code>Report</code></li><li>主机若要加入组播组，可直接向查询器发送<code>Report</code>，离开组播组时，直接发送<code>Leave</code>，目的地址为<code>224.0.0.2</code>，通告所有组播路由器。查询器收到<code>Leave</code>后，会发送特定组查询消息<code>Group-Specific Query</code>确定该组所有成员是否都离开。</li><li>若是加入，查询器则会查看组播转发表项，若不存在就添加，表项为<code>(组播源IP地址,组播组IP)</code>，若为<code>*</code>表示任意源。组播转发表项还包含：组播指定报文的入接口、出接口等</li></ol><p>案例完整流程：<br><img src="/2018/07/31/组播学习笔记/2.png"><br><img src="/2018/07/31/组播学习笔记/3.png"></p><p>IGMP Snooping：解决二层组播。原因：组播数据在二层以广播发送<br>主机发往IGMP查询器的报告消息经过交换机时，交换机会监听并将组播MAC和端口做映射，建立表项。当交换机收到组播数据时，就按表项转发，也就只向组成员发送了</p><p>IGMPv3概述：<br>1.可对源过滤  2.新的报文类型与格式 3.报告报文的组播地址为224.0.0.22 4.取消成员报告抑制机制<br>IGMPv3主机为接口上每个组播组维护一个表项（组地址，过滤模式，源列表）<br>过滤模式：INCLUDE：只接收来自源列表的组播源的数据包<br>   EXCLUDE：只接收不在源列表的组播源的数据包<br>三种状态：当前状态，过滤模式改变状态，源列表改变状态。对应三种记录<br>当主机接口维护的组状态变化时，会主动发送组记录类型为过滤模型变化或源列表变化的报告报文。当接收到查询报文时，会响应记录类型为当前状态的报告报文</p><p>组播分发树模型：是组播数据的转发数据，分为最短路径树(S,G)和共享树<code>(*,G)</code><br>组播转发机制：逆向路径转发<br>组播路由协议：域内：DVMRP（基于路径矢量协议）、MOSPF（基于OSPF）、PIM         域间：MSDP、MBGP<br>域内协议：基于SPT：PIM DM、DVMRP、MOSPF       基于RPT：PIM SM<br>组播模型：ASM任意信源组播：接收端只选择加入组播组，不能选择组播源<br>    SSM指定信源组播：接收端可以指定组播源</p><p>组播分发树：由组播路由协议建立的无环传输路径<br>SPT最短路径树：组播源到接受者的最短路径。要为每个组播源建一棵最短路径树<br>缺点：路由器必须为每个组播源保存路由信息<br>RPT共享树：以某个路由器作为树根，该路由器称为汇聚点RP，以RP为树根建立到每个接收者的最短路径树。所有组播源和接收者都使用这棵树收发报文。组播源先向RP发数据，再由RP发送到所有接收者。<br>优点：路由器保留的路由信息很少<br>缺点：数据报文先要经过RP，再到达接收者，对RP的可靠性和性能要求高<br>组播报文转发机制<br>RPF逆向路径转发<br>原因：组播报文是发送给一组接收者的，路由器收到组播报文后，必须根据报文的源地址确定正确的入接口和下游方向，然后向下游方向转发。该过程就是RPF。<br>目的：确保组播数据沿正确路径传输，避免出现环路<br>检查过程：在单播路由表上查找组播源（分发树为SPT）或RP（分发树为RPT）对应的RPF接口，若数据包是在RPF端口接收到的，则RPF检查成功，转发数据包。否则检查失败，直接丢弃<br>PIM协议无关组播：与单播路由无关，但仍然依靠单播路由表进行组播路由。使用RPF转发报文。分为两种模式：PIM-DM（密集模式），PIM-SM（稀疏模式）<br>PIM-DM：用于小型网络中接收者较多且密集的情况，采用“推”方式将流量泛洪。<br>邻居发现：路由器周期发送PIM Hello消息，发现其他PIM路由器，建立邻居关系，判断叶子网络，选举DR（若运行的是IGMPv1，通过Hello选举，其他版本就不需要选举DR）。<br>扩散-剪枝：将组播数据扩散到每个节点，每个节点创建(S,G)表项（包含出接口（除RPF接口外所有连接PIM-DM邻居或组播组成员的接口）与入接口列表），若节点没有该组播组成员，就向上游发送Prune剪枝消息，若共享网段有路由器上有接收者，就向上游发送Join消息，覆盖其他路由器发送的Prune。 扩散-剪枝过程周期进行。最终形成SPT。<br>Prune消息发送情况：1.若路由器(S,G)表中出接口表为空  2.路由器从非RPF接口收到组播报文，会触发断言Assert机制，断言失败一方会向成功一方发送Prune消息。<br>断言Assert：若同一网段有多个组播路由器，相同报文可能会被重复发送，通过断言选取网段唯一转发组播数据的路由器。<br>过程：路由器在重复接收到报文的接口上发送Assert消息，包含S，G，单播路由的优先级，开销Metric。先比较路由优先级（高的胜），再比较开销（小的胜），再比较本地接口IP地址（大的胜）。当一台路由器上游接口故障时，该路由器将Metric值设为无穷大并广播Assert，引发新一轮断言，保证流量不会长时间中断。<br>状态刷新机制：与组播源直连的路由器发送State Refresh，其他路由器收到后重置剪枝超时定时器，并向所有连接PIM-DM邻居的路由器发送该消息，对于处于转发的接口，消息中剪枝位为0，处于剪枝的接口，剪枝位为1。周期发送该消息可使剪枝状态的接口维持状态，减少不必要的扩散。<br>嫁接：当被剪枝的节点上出现接收者时，节点会主动向上游发送嫁接Graft消息，上游收到后回复Graft Ack消息确认，节点从剪枝状态变为转发状态。两个消息都是单播发送。<br>PIM-SM：用于中大型网络中，组播组成员相对分散，范围较广，采用“拉”方式。核心任务是构造维护RPT，选出RP作为共享树的根。<br>过程：组播源侧DR向RP注册，将注册报文单播发给RP，该报文到达RP后触发建立SPT，组播源把数据沿SPT发给RP，再由RP沿RPT发给接收者</p><p>ASM模型：任意源模型。任何发送者都可作为组播源向组播组发数据，接收者无法预先知道组播源位置，但可以在任意时间加入离开组播组<br>SSM模型：指定信源组播模型。接收端能指定组播源。SSM模型无需RP，无需构建RPT，无需组播源注册过程。</p>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 组播 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OSPF学习笔记</title>
      <link href="/2018/07/31/OSPF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/31/OSPF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>基于华三网络学习笔记（理论）</strong></p><p>本篇包含以下内容</p><ul><li><a href="#OSPF特性与基本术语">OSPF特性与基本术语</a></li><li><a href="#OSPF报文">OSPF报文</a></li><li><a href="#OSPF邻居建立维护与状态机">OSPF邻居建立维护与状态机</a></li><li><a href="#OSPF特殊区域">OSPF特殊区域</a><a id="more"></a></li></ul><h2 id="OSPF特性与基本术语"><a href="#OSPF特性与基本术语" class="headerlink" title="OSPF特性与基本术语"></a>OSPF特性与基本术语</h2><p>Open Shortest Path First开放最短路径优先</p><ul><li>属于IGP，优先级AS内部10，外部150</li><li>采用链路状态算法SPF防环</li><li>封装在IP报文中，协议号89</li><li>度量值为开销cost=带宽参考值/接口带宽，参考值通常为100M，若求得的数小于1，则cost就取1</li><li>报文更新方式为触发更新+周期更新（30min。LSA老化时间60min）</li><li>增量更新（通过LSA），组播更新报文</li><li>组播地址224.0.0.5（主要，所有OSPF路由器都能收到）或224.0.0.6（DR、BDR可收到）</li><li>没有跳数限制，可用于大规模组网</li></ul><p>路由生成过程：</p><ol><li>生成LSA描述自身接口状态（链路开销、IP地址等）</li><li>同步OSPF区域内每台路由器的LSDB（通过交换LSA）</li><li>SPF算法计算路由：每个路由器以自身为根计算最短路径树（即根到各节点的开销都是最小的），加入路由表，若两条路径开销相同，则都加入表中形成等价路由。</li></ol><p>开启OSPF的路由器上与路由转发相关的三张表：</p><ul><li>邻居表：记录建立了邻居关系的路由器</li><li>LSDB表：记录所有链路状态信息，需要实时同步</li><li>路由表：记录经SPF算法计算的路由</li></ul><p>OSPF选路原则：</p><ol><li>按路由类型优先级：区域内路由&gt;区域间路由&gt;第一类外部路由&gt;第二类外部路由</li><li>类型相同，选路由开销小的</li><li>以上都相同，形成等价路由</li></ol><p>两类外部路由：<br><img src="/2018/07/31/OSPF学习笔记/3.png"></p><ul><li>第一类外部路由：偏向于AS内部的选路，并不关心AS外的开销。用于控制入AS的路由选路。<br>如图中RTA，若选择第一类外部路由，则关心AS内部的开销，会选择开销较小的RTB路线。</li><li>第二类外部路由：偏向与AS外部的选路，并不关心AS内的开销。用于控制出AS的路由选路。<br>如图中RTA，若选择第二类外部路由，则关心AS外部的开销，会选择开销较小的RTC路线。</li></ul><p>若同一网段的路由信息同时通过第一类外部路由和第二类外部路由学习到，在其他条件相同的情况下，会优选第一类外部路由。</p><p>骨干区域：area 0，负责转发非骨干区域之间的路由。<br>区域间路由规则：</p><ol><li>非骨干区域必须与骨干区域相连</li><li>非骨干区域之间不能传递路由，必须通过骨干区域</li><li>骨干区域传出的路由不能传回非骨干区域</li></ol><p>OSPF防环：从一个区域学习到的路由不会再向该区域注入。非骨干区域间不能直接通信</p><p>当骨干区域被分割或非骨干区域不与骨干区域相连时，可通过虚连接解决。<br>两台ABR（区域边界路由器）通过一个非骨干区域建立一条逻辑通道，对于通道上的路由器是透明的。</p><p>划分区域的好处：</p><ul><li>减少了区域内LSDB中链路状态信息的数量</li><li>便于管理</li><li>减少路由震荡的影响范围</li></ul><p>OSPF路由器类型：</p><ol><li>区域内路由器Internal：所有接口都属于同一个区域</li><li>区域边界路由器Area Border：连接骨干与非骨干区域（物理上或逻辑上）</li><li>骨干路由器Backbone：至少有一个接口属于骨干区域，即所有区域内和区域边界路由器都是骨干路由器</li><li>自治系统边界路由器Autonomous System Border：与其他AS路由器交换路由信息，不一定在AS的边界，只要该路由器引入外部路由，就是ASBR。<img src="/2018/07/31/OSPF学习笔记/2.png"></li></ol><p>Router ID用来在AS中唯一标识一个路由器，RouterID的选取优先级如下：<br>局部 &gt; 全局 &gt; 自动选举<br>局部：创建OSPF进程时同时指定router-id<br>全局：系统视图下指定router id<br>自动选举：环回口中最大的，若无环回口，则选取接口中IP地址最大的</p><p>网络类型：</p><ol><li>Broadcast广播：当链路层为以太网协议时，默认为Broadcast，以组播地址发报文(.5|.6)，需要DR，Hello定时器10s，邻居失效时间40s。</li><li>NBMA非广播多点可达网络：当链路层为帧中继或ATM时，默认为NBMA，以单播发报文，需要DR，Hello定时器10s，邻居失效时间40s。</li><li>P2P点到点：当链路层为PPP、HDLC时，默认P2P，以组播发报文(.5)，不需要DR，Hello定时器30s，邻居失效时间120s。</li><li>P2MP点到多点：需要手动修改，以组播发报文(.5)，不需要DR，Hello定时器30s，邻居失效时间120s。</li></ol><h2 id="OSPF报文"><a href="#OSPF报文" class="headerlink" title="OSPF报文"></a>OSPF报文</h2><p>OSPF五种报文：</p><ol><li><code>Hello</code>报文：发现维护邻居关系，包含定时器、DR、BDR和已知邻居</li><li><code>DD</code>报文：数据库描述报文，<strong>描述本地LSDB中LSA摘要，进行主从关系协商</strong>，用于路由器间LSDB同步</li><li><code>LSR(Request)</code>报文：链路请求报文，向对方请求所需LSA（通过比对DD报文知道自己缺哪些LSA）</li><li><code>LSU(Update)</code>报文：链路状态更新报文，向对方发送所要求的LSA</li><li><code>LSAck</code>报文：链路状态确认报文，对收到的LSA进行确认</li></ol><h2 id="OSPF邻居建立维护与状态机"><a href="#OSPF邻居建立维护与状态机" class="headerlink" title="OSPF邻居建立维护与状态机"></a>OSPF邻居建立维护与状态机</h2><p>邻居建立与维护：</p><ol><li>组播发送Hello报文（.5），双方协商参数，若验证、区域等都相同，则表示邻居发现</li><li>邻居周期交换Hello报文，若邻居失效时间超时未收到Hello则认为邻居失效，将该邻居从邻居表中删除</li></ol><p>DR/BDR选举：<br>目的：减少邻接关系的数量，所有路由信息都发给DR（指定路由器），再由DR发LSA<br>若不设置DR/BDR，则邻接关系数量<code>R=n(n-1)/2</code>个<br>若设置DR/BDR，则邻接关系数量<code>R=2(n-2)+1</code>个</p><p>BDR是DR的备份。若DR失效，BDR立刻成为DR。<br>DR/BDR选举原则：</p><ol><li>首先比较Hello报文中的优先级，最高的为DR，次高的为BDR，若为0不参加选举。</li><li>优先级相同则比较RouterID，大的优</li><li>选举完毕后，即使有更优的路由器加入区域，也不会更换DR/BDR（可以在用户视图重置ospf进程，使ospf重新选举）</li><li>只有广播和NBMA网络选举DR/BDR</li><li>剩余路由器成为DRother，只与DR、BDR建立邻接关系</li></ol><p>邻接关系建立：</p><ol><li>初始状态，A的邻居为<code>Down</code>，由于邻居表为空，所以DR字段置为<code>0.0.0.0</code>，发送Hello报文，B收到Hello报文后，将A添加进邻居表中，邻居状态变为<code>Init</code>，两个路由器比较RouterID，大的（假设A）会在后面的Hello报文中将DR字段设为自己的RouterID。</li><li>B收到Hello报文，发现邻居表中有自己的RouterID，于是将邻居表中A状态变为<code>2-way</code>。B也收到后，同理。若当前两台路由器都是DRother，则邻接状态就会维持在<code>2-way</code>。只有其中一个是DR或BDR，才会继续建立关系</li><li>若进一步建立邻接关系，A会将B状态设为<code>ExStart</code>，并发送一个不包含LSA的DD报文，开始主从协商。<br>其中DD报文包含MS位，最开始该MS位置1，表示路由器以自己为Master。Master路由器的作用就是在交换DD报文时，主动发送DD报文，并控制报文的序列号。Slave路由器仅能接受Master指定的序列号并被动发送DD。</li><li>B收到DD后，将发送方的状态设为<code>ExStart</code>。对比RouterID，若大（假设A）就在DD报文中将MS位也置为1，表明自己是Master，并回复。B收到DD报文后，同意A为Master，将MS位置0，表明自身Slave，采用A规定的序列号向A发DD报文，此时DD报文中包含LSA摘要，A收到后将B状态改为<code>Exchange</code>。B收到A的DD报文后也将A状态改为<code>Exchange</code>。</li><li>A与B都对DD报文的LSA与LSDB进行比对，若LSA信息在LSDB中都存在，就直接进入<code>Full</code>状态。若一方LSDB不完全包含LSA，则向另一方请求，并将对方状态置为<code>Loading</code>，发送LSR。另一方收到后根据LSR返回LSU。再次比对后相同就进入<code>Full</code>。</li></ol><p>OSPF状态机<br>其中有三个稳定状态：<code>Down</code>、<code>2-way</code>、<code>Full</code></p><ul><li><code>down</code>：未启动ospf</li><li><code>init</code>：收到对方hello包，但hello包中的邻居表没有自己</li><li><code>2-way</code>：收到对方hello包，且在hello包中看到自己</li><li><code>exstart</code>：互相发送空的DD协商主从报文，以决定谁发DD报文</li><li><code>exchange</code>：交换真正的DD报文</li><li><code>loading</code>：交互路由信息</li><li><code>full</code>：路由学习完毕，邻接关系建立</li></ul><img src="/2018/07/31/OSPF学习笔记/1.png"><p>影响OSPF建立邻接关系的因素：</p><ol><li>area是否一致</li><li>接口是否开启OSPF</li><li>接口是否开启验证</li><li>是否启用了静默接口，或开启过滤</li><li>是否处于特殊区域</li><li>Hello/Dead定时器是否一致</li><li>Router-id是否不同</li><li>链路两端接口掩码是否不同（广播类型链路hello会携带掩码信息）</li><li>两端MTU是否不同（若不同会一直在Exstart状态）</li></ol><h3 id="链路状态广播LSA"><a href="#链路状态广播LSA" class="headerlink" title="链路状态广播LSA"></a>链路状态广播LSA</h3><p>LSA老化时间3600s（1小时），每1800s（半小时）ospf就会泛洪一次全部路由信息</p><p>报文字段：</p><ol><li><code>LS age</code>：LSA产生后经过的时间（单位秒）</li><li><code>LS type</code>：LSA类型（1-11）</li><li><code>Link State ID</code>：LSA链路ID，根据LSA类型而定</li><li><code>Advertising Router</code>：始发LSA的路由器ID，也称LSA通告路由器<br><strong><code>LS type</code>、<code>Link State ID</code>、<code>Advertising Router</code>三个参数唯一标识一个LSA</strong></li><li><code>LSA sequence number</code>：LSA序列号，用于判断是否是最新的LSA</li><li><code>LS checksum</code>：LSA信息的校验和</li><li><code>length</code>：LSA总长度</li></ol><p>LSDB更新过程：收到一条LSA更新报文，在LSDB中查找该LSA，若未找到就将这条LSA加入LSDB，若找到，就对比LSA的序列号，若该条的大，就更新，否则不更新。</p><p>LSA类型：</p><ul><li>一类：<code>Router LSA</code>，描述区域内部与路由器直连的链路信息，所有OSPF路由器始发，仅在区域内传播。不携带掩码信息</li><li>二类：<code>Network LSA</code>，记录广播或NBMA上所有路由器RouterID，DR始发，仅在区域内传播。携带网段掩码信息，和一类LSA共同计算网段<br><strong>一类和二类LSA解决了区域内部的通信</strong></li><li>三类：<code>Network Summary LSA</code>，包含区域网段与开销，传播给相邻区域，ABR始发，区域间传播。实际就是收集一类和二类的LSA。每个三类LSA包含一个网段<br><strong>一、二、三类LSA解决了区域内和区域间通信</strong></li><li>四类：<code>ASBR Summary LSA</code>，描述ASBR的RouterID和开销，传播给非ASBR区域，ABR始发。辅助五类LSA，实现到达ASBR。告诉OSPF内部路由器如何到达ASBR</li><li>五类：<code>AS External LSA</code>，描述到AS外部的路由，包含外部网段、开销等，传播给整个OSPF系统，ASBR始发。每个五类LSA包含一个网段。</li><li>七类：<code>NSSA Exteranl LSA</code>，只在NSSA中传播，描述到AS外部的路由，ASBR始发</li></ul><p>路由聚合：ABR和ASBR可将具有相同前缀的路由聚合发布。</p><p>安全：</p><ul><li>协议报文验证：通过验证的OSPF报文才能被接收（路由器+接口都要配置验证：Simple或MD5）</li><li>禁止端口发送OSPF报文：该端口成为被动端口（静默），不再发送Hello报文</li><li>过滤计算出的路由：通过过滤规则的路由才加入路由表</li><li>过滤三类LSA：设置规则过滤外部路由（本地有效）</li></ul><h2 id="OSPF特殊区域"><a href="#OSPF特殊区域" class="headerlink" title="OSPF特殊区域"></a>OSPF特殊区域</h2><p>OSPF特殊区域：</p><ol><li><code>Stub</code>：不允许注入四、五类LSA。不能存在ASBR。虚连接不可穿过。若有多个ABR可能产生次优路由</li><li><code>Totally Stub</code>：不允许注入三、四、五类LSA。虚连接不可穿过。ABR会产生一条0.0.0.0/0的三类LSA</li><li><code>NSSA</code>：不允许四、五类LSA，允许七类LSA。虚连接不可穿过。该区域存在一个ASBR，该区域不希望接收其他ASBR的外部路由。七类默认路由LSA由ASBR产生，在NSSA中传播，当到达ABR时，会转换为五类LSA传到别的区域。<br><strong>Totally STub和NSSA都是Stub的变形或改进</strong></li><li><code>Totally NSSA</code>：不允许注入三、四、五类LSA，而是用七类默认路由取代。虚连接不可穿过。</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> OSPF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BGP学习笔记</title>
      <link href="/2018/07/31/BGP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/31/BGP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>基于华三网络学习笔记（理论）</strong></p><p>本篇包含以下内容</p><ul><li><a href="#BGP特性与基本术语">BGP特性与基本术语</a></li><li><a href="#BGP消息与状态机">BGP消息与状态机</a></li><li><a href="#BGP路由属性">BGP路由属性</a></li><li><a href="#BGP选路规则">BGP选路规则</a><a id="more"></a></li></ul><h2 id="BGP特性与基本术语"><a href="#BGP特性与基本术语" class="headerlink" title="BGP特性与基本术语"></a>BGP特性与基本术语</h2><p>Border Gateway Protocol边界网关协议。用于自治系统间，进行不同AS间路由传递。</p><ul><li>路径矢量路由协议</li><li>基于TCP，端口号179</li><li>EGP协议，优先级255</li><li>支持路由聚合与CIDR</li><li>只发送增量路由</li><li>路由信息中携带经过的所有AS路径表</li><li>支持CIDR和路由聚合</li><li>丰富的路由属性、强大的路由过滤和路由策略</li><li>可传输大量路由（基于TCP的可靠传输和滑动窗口）</li><li>只能点对点连接（TCP的点对点）</li></ul><p><strong>基本术语</strong></p><ul><li>BGP发言者：发送BGP消息的路由器</li><li>Router ID：32位，在AS中唯一标识一台主机，必须配置</li><li>BGP对等体Peer：相互交换消息的BGP发言者互为对等体，也可称BGP邻居。<ul><li>IBGP对等体：处于同一AS的对等体，不需要直连<br><strong>从IBGP获得的路由不会向其他IBGP邻居发布（为了防环）<br>从IBGP获得的路由是否发个EBGP邻居与是否同步有关（为了防止路由黑洞）</strong><br>全连接：为解决部分连接导致的无法学习路由，每两个路由器都建立IBGP邻居则可以保持AS内的所有BGP路由器路由信息相同</li><li>EBGP对等体：处于不同AS的对等体，且通常要求直连<br>从EBGP获得的路由会发布给所有IBGP邻居<br>EBGP的TTL=1，所以只能是直连对端接口，不可跨设备（可修改TTL实现跨设备）<br>而IBGP的TTL=255可与AS内任意BGP路由器建邻居</li></ul></li></ul><p>BGP防环：</p><ol><li>对于EBGP：使用AS-PATH</li><li>对于IBGP：禁止将从IBGP邻居学到的路由发布出去。缺点：有路由器学不到路由。解决：全连接</li></ol><p>BGP同步：IBGP与IGP之间同步，避免转发黑洞。收到IBGP邻居发布的路由后，会查看该路由是否在IGP表中，只有IGP表中存在，才会置为有效并发布，否则无效不发布。路由器默认关闭同步。</p><h2 id="BGP消息与状态机"><a href="#BGP消息与状态机" class="headerlink" title="BGP消息与状态机"></a>BGP消息与状态机</h2><p>BGP所有消息都是消息头+消息体，消息头长度19字节，包含以下字段：</p><ul><li>Marker：16字节，用于BGP验证的计算，不使用验证时所有位都置为1</li><li>Length：2字节，BGP消息总长度（包括报文头）</li><li>Type：1字节，BGP消息的类型，取值为1到5，分别表示Open、Update、Notification、Keepalive、Route-Refresh</li></ul><p>BGP消息种类：</p><ol><li>Open：用于建立BGP邻居。TCP连接后的第一个消息，进行参数协商。包含以下字段：<ul><li>BGP版本</li><li>AS号</li><li>routerID</li><li>Hold Time：保存时间，若超时仍未收到对端的Keepalive或Update消息，则认为BGP连接中断。建立对等体时要协商该参数并保持一致</li><li>认证信息或多协议扩展等功能</li></ul></li><li>Update：在邻居间交换路由信息（发布或撤销）。可通告一类相同属性的可达路由和不可达路由。包含以下字段：<ul><li>不可达路由字段长度。单位字节，若为0表示没有<code>Withdrawn Routes</code></li><li>Withdrawn Routes不可达路由列表，即存放被撤销的路由</li><li>路径属性字段长度。单位字节，若为0表示没有<code>Path Attibutes</code></li><li>Path Attibutes，存放与NLRI相关的所有路径属性列表，每个路径属性由一个TLV三元组构成。</li><li>NLRI可达路由的前缀和前缀长度二元组，存放一类相同属性的可达路由</li></ul></li><li>Notification：错误通知（消息错误或断开BGP连接）。包含以下字段：<ul><li>差错码，指定错误类型</li><li>差错字码，提示错误类型的详细信息</li><li>数据，出错部分的数据。用于辅助发现错误的原因，依赖于差错码和差错子码</li></ul></li><li>Keepalive：维护邻居关系或对Open消息回应。只有消息头。周期发送，默认周期30s。</li><li>Route-refresh：要求对等体重新发送指定地址族的路由</li></ol><p>BGP状态机：</p><ol><li>Idle：空闲。初始状态，等待Start事件。一旦有Start，就向邻居发起TCP建立请求</li><li>Connect：连接。等待TCP建立完成。若TCP完成，状态改为Open-sent。若失败，状态改为Active。</li><li>Active：活跃。TCP未成功建立。若超时，会返回Connect。若成功，进入Open-sent状态。</li><li>Open-sent：Open消息已发送。已发出Open消息，等待邻居的Open消息。若收到邻居的Open消息且无错误，进入OpenConfirm状态，并发送Keepalive。否则，进入Notification。</li><li>OpenConfirm：Open消息已确认。Keepalive已发送，等待邻居的Keepalive。若收到邻居的Keepalive，则进入Established状态。若收到Notification，则断开连接</li><li>Established：BGP连接建立。可发送Update交换路由，发送Keepalive维护连接，若收到Notification则断开连接</li></ol><img src="/2018/07/31/BGP学习笔记/1.png"><h2 id="BGP路由属性"><a href="#BGP路由属性" class="headerlink" title="BGP路由属性"></a>BGP路由属性</h2><ol><li>公认必遵属性：BGP路由器必须识别，必须存在于Update<ul><li>ORIGIN：定义路由信息来源<br>类型：IGP–路由产生于AS内   EGP–路由通过EGP学到  Incomplete–路由来源不确定<br><strong>优先级：IGP&gt;EGP&gt;Incomplete</strong></li><li>AS_PATH：路由更新经过的AS路径列表，保证AS间无环。可用于路由选择和过滤<br>当BGP将一条路由通告到其他AS时，会把本地AS号添加到AS-PATH最前<br>优先选择AS-PATH最短的路由。<br>若向EBGP邻居发送路由更新修改，IBGP间不修改</li><li>NEXT_HOP：路由下一跳<br>向邻居发布路由时，会将下一跳设为自己与对端连接的端口<br>从EBGP邻居得到的路由发给IBGP邻居时，不会修改下一跳</li></ul></li><li>公认可选属性：BGP路由器必须识别，不必须存在于Update<ul><li>LOCAL_PREF：用于IBGP选择<strong>离开AS时</strong>的路由，表明BGP路由器的优先级<br>仅在IBGP对等体间交换。默认值100</li></ul></li><li>可选传递属性：在AS间可传递，路由器可不支持，仍可接收并通告<ul><li>COMMUNITY</li><li>AGGREGATOR</li></ul></li><li>可选非传递属性：若BGP路由器不支持，属性会被忽略，且不通告<ul><li>MED：度量值。告诉EBGP邻居<strong>进入AS</strong>的路由。<br>仅在相邻AS间交换，收到MED的AS不会再通告给其他AS<br>通常只比较来自同一AS的MED</li></ul></li><li>私有BGP属性：<ul><li>Preferred-value：对从邻居学习到的路由分配优先级<br>本地有效，不通告。初始为0</li></ul></li></ol><p>对于BGP路由处理：</p><ol><li>接收BGP路由</li><li>路由过滤、属性设置</li><li>路由优选</li><li>发布策略</li><li>发布路由过滤、属性设置、路由聚合</li></ol><h2 id="BGP选路规则"><a href="#BGP选路规则" class="headerlink" title="BGP选路规则"></a>BGP选路规则</h2><p>路由选路优先级（高到低）：</p><ol><li>丢弃下一跳不可达的路由</li><li>Preferred-value选大</li><li>LOCAL_PREF选大</li><li>聚合路由，本地路由</li><li>AS_PATH选小</li><li>ORIGIN按优先级选</li><li>MED选小</li><li>依次选从EBGP、联盟、IBGP学到的路由</li><li>下一跳度量值最低</li><li>CLUSTER_LIST选短</li><li>ORIGINATOR_ID最小</li><li>RouterID最小路由器发布的路由</li><li>地址最小的邻居发布的路由</li></ol><p>BGP一定能选出唯一的最优路由，且可以负载分担<br>路由下一跳不一定是直连邻居，原因：IBGP发布路由不改变下一跳。路由器会查找直连可达地址，到达要发布路由的下一跳（去往该下一跳的路由为依赖路由，过程为路由迭代）。路由器支持基于迭代的负载分担。</p><p>BGP路由发布策略：</p><ul><li>只发布最优路由</li><li>只发布自己使用的路由</li><li>发布所有从EBGP邻居学到的路由给所有BGP邻居（IBGP和EBGP）</li><li>不把从IBGP邻居学到的路由发布给IBGP邻居</li><li>IBGP路由发到EBGP：BGP同步关–直接发布。BGP同步开–IGP也发布时才发布</li><li><strong>BGP连接建立后，发布所有BGP路由</strong></li></ul><p>BGP下一跳原则：<br>若从EBGP邻居学到的路由传给IBGP邻居时下一跳不变，可能会导致BGP设备因为下一跳不可达而不加入路由表。解决：应在EBGP路由传给IBGP邻居时将下一跳改为自身</p><p>BGP路由不优的原因：1.同步打开，但网络不满足同步要求   2.下一跳不可达</p><p>BGP源IP地址原则：BGP设备收到一个BGP报文，会检查报文源IP地址，若与peer所指IP地址一致，则设备接收该报文，若不一致，则丢弃报文，在建环回口建立BGP关系时，要修改BGP报文源</p><p>默认情况，BGP使用到达对等体的最佳路由作为出接口作为与对等体建TCP连接的源接口<br>将建立TCP的源接口配置为环回口，在网络中存在冗余链路时不会因为某个接口或链路故障而使BGP，提高了可靠性和稳定性</p><h3 id="控制BGP路由"><a href="#控制BGP路由" class="headerlink" title="控制BGP路由"></a>控制BGP路由</h3><p>常用属性：<code>preferred-value</code>、<code>Local-preference</code>、<code>MED</code>、<code>next-hop-local</code><br>路由首选值<code>Preferred-value</code>：优选大的。默认从对等体学来的路由首选值为0<br>本地优先级<code>Local-preference</code>：判断离开AS的最佳路由<br>AS路径过滤表<code>AS_PATH list</code>：一个基于AS表的ACL，使用正则表达式对路由携带的AS路径属性域进行匹配</p><p>正则表达式：</p><ul><li><code>^</code> 匹配字符串的开始</li><li><code>$</code> 匹配字符串的结束</li><li><code>*</code> 匹配<code>*</code>前的字符（串）0或多次</li><li><code>+</code> 匹配+前的字符（串）1或多次</li><li><code>.</code> 通配符，匹配任何一个字符</li><li><code>_</code> 下划线，匹配一个符号</li><li><code>-</code> 连接符，连接两个字母或数值</li><li><code>( )</code> 字符组，一般与<code>-</code>连用</li><li><code>[ ]</code> 匹配<code>[ ]</code>中任意一个字符</li></ul><p>常用正则组合：</p><ul><li><code>^$</code>只匹配本地路由</li><li><code>.*</code>匹配所有路由</li><li><code>^100</code>匹配AS100、1001等邻居的路由</li><li><code>^100_</code>只匹配AS100邻居发的路由</li><li><code>_100$</code>匹配AS100始发的路由</li><li><code>_100_</code>匹配经过AS100的路由</li></ul><h2 id="BGP补充知识点"><a href="#BGP补充知识点" class="headerlink" title="BGP补充知识点"></a>BGP补充知识点</h2><p>BGP对等体组peer group：具有某些相同属性的对等体集合，可分为IBGP或EBGP对等体组</p><p>BGP团体属性：一组具有相同特征目的地址的集合，与所在AS无关，一条路由可以有多个团体属性。</p><p>公认团体属性<br>INTERNET：有这一属性的路由可以被通告给所有对等体。路由缺省属于该团体<br>NO_EXPORT：该团体路由不能被发布到本地AS外，若使用联盟，不能发布到联盟外<br>NO_ADVERTISE：不能被通告任何BGP对等体<br>NO_EXPORT_SUBCONFED：不能被发布到任何其他AS</p><p>BGP聚合<br>两种聚合：手动、自动<br>自动：聚合为自然路由。只能引入IGP子网路由聚合，不能对BGP邻居学来的或network发布的路由进行聚合。<br>手动：手动配置灵活的聚合，可以对从BGP邻居学习的、引入IGP的、network生成的路由聚合</p><p>BGP反射<br>作用：可代替IBGP对等体全连接<br>原理：允许设备从IBGP对等体接收到的路由信息发布给特定IBGP对等体，这些网络设备称为路由反射器。</p>]]></content>
      
      
        <tags>
            
            <tag> BGP </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker Compose学习笔记</title>
      <link href="/2018/07/30/Docker-Compose%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/30/Docker-Compose%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>环境：docker：18.06.1，docker-compose：1.22.0</p><p>docker18.06对应的Compose文件格式版本为3.7</p><p>本篇包含以下内容：</p><ul><li><a href="#docker-compose介绍">docker-compose介绍</a></li><li><a href="#Compose文件格式">Compose文件格式</a></li><li><a href="#docker-compose示例">docker-compose示例</a></li></ul><a id="more"></a><h1 id="docker-compose介绍"><a href="#docker-compose介绍" class="headerlink" title="docker-compose介绍"></a>docker-compose介绍</h1><p><code>Docker Compose</code>是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。在配置文件中，所有的容器通过services来定义，然后使用docker-compose脚本来启动，停止和重启应用，和应用中的服务以及所有依赖服务的容器。</p><p><strong>Compose的特性</strong></p><ul><li>通过项目名称将单个主机隔离成多个环境，能将应用环境复制多份，还能防止使用相同名称的服务的应用间的干扰</li><li>能够保护卷中的数据，如果Compose发现存在之前运行过的容器，它会把旧容器中的数据卷拷贝到新的容器中</li><li>只会重新创建改变过的容器，Compose会缓存用于创建容器的配置信息，当你重启服务时，如果服务没有被更改，Compose就会重用已经存在的容器，加快了修改应用的速度</li></ul><p><strong>编排：</strong>Orchestration，根据被部署的对象间的耦合关系以及被部署对象对环境的依赖，制定部署流程中各个动作的执行顺序，部署过程中所需要的依赖文件和被部署文件的存储位置和获取方式，以及如何验证部署成功。这些信息都会在编排工具中以制定格式定义并保存。</p><p><strong>部署：</strong>Deployment，按照编排所指定的内容和流程，在目标机器上执行编排指定环境初始化，存放指定的依赖和文件，运行指定的部署动作，按照编排中规则确认是否部署成功。</p><blockquote><p>以上编排和部署定义摘选自《docker容器与容器云》</p></blockquote><p><strong>docker-compose安装</strong></p><p>使用pip快速安装<code>pip install docker-compose</code></p><p>docker-compose参数选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br><span class="line">  -f, --file FILE             指定compose文件，默认为docker-compose.yml</span><br><span class="line">  -p, --project-name NAME     指定项目名，默认为所在目录名</span><br><span class="line">  --verbose                   显示详细过程信息</span><br><span class="line">  --log-level LEVEL           设置日志级别(DEBUG, INFO, WARNING, ERROR, CRITICAL)</span><br><span class="line">  --no-ansi                   不打印ANSI控制字符</span><br><span class="line">  -H, --host HOST             指定要连接的主机</span><br><span class="line"></span><br><span class="line">  --tls                       使用tls，就是指--tlsverify</span><br><span class="line">  --tlscacert CA_PATH         指定只承认该CA颁发的证书</span><br><span class="line">  --tlscert CLIENT_CERT_PATH  TLS证书路径</span><br><span class="line">  --tlskey TLS_KEY_PATH       TLS密钥路径</span><br><span class="line">  --tlsverify                 使用TLS</span><br><span class="line">  --skip-hostname-check       不根据客户端证书中指定的名称检查守护程序的主机名</span><br><span class="line">  --project-directory PATH    指定工作目录，默认为compose文件所在目录</span><br><span class="line">  --compatibility             Compose将尝试将v3文件中的部署密钥转换为其非Swarm等效项</span><br></pre></td></tr></table></figure><p><strong>docker-compose命令：</strong></p><ul><li><p><strong><code>build</code></strong>：构建或重构服务（services）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build [options] [--build-arg key=val...] [SERVICE...]</span><br><span class="line">    --compress              使用gzip压缩构建上下文</span><br><span class="line">    --force-rm              始终移除中间容器</span><br><span class="line">    --no-cache              构建镜像时不使用缓存</span><br><span class="line">    --pull                  总是尝试拉取最新镜像</span><br><span class="line">    -m, --memory MEM        设置构建镜像的内存上限</span><br><span class="line">    --build-arg key=val     设置服务的构建时变量</span><br></pre></td></tr></table></figure></li><li><p><strong><code>bundle</code></strong>：从Compose文件生成Docker包</p><p>镜像必须存储摘要，这需要与Docker Registry进行交互。如果没有为所有镜像存储摘要，可以使用<code>docker-compose pull</code>或<code>docker-compose push</code>来获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bundle [options]</span><br><span class="line">    --push-images              在打包时自动推送已使用build指定的服务的镜像</span><br><span class="line">    -o, --output PATH          包文件路径，默认为&quot;项目名.dab&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>config</code></strong>：校验并查看compose文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config [options]</span><br><span class="line">    --resolve-image-digests  将镜像标签写入摘要</span><br><span class="line">    -q, --quiet              静默模式，只校验配置，不打印信息</span><br><span class="line">    --services               列出所有服务</span><br><span class="line">    --volumes                列出所有数据卷</span><br></pre></td></tr></table></figure></li><li><p><strong><code>down</code></strong>：停止并删除容器、网络、镜像、数据卷</p><p>默认能删除的内容：</p><ul><li>Compose文件中定义的服务的容器<ul><li>Compose文件的<code>networks</code>中定义的网络</li><li>默认网络（如果使用）</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">down [options]</span><br><span class="line">    --rmi type              删除镜像，必须指定类型：</span><br><span class="line">                              &apos;all&apos;: 删除任何服务使用的所有镜像</span><br><span class="line">                              &apos;local&apos;: 只删除没有通过image指定自定义标签的镜像</span><br><span class="line">    -v, --volumes           删除在Compose文件的&quot;volumes&quot;中声明的命名卷和附加到容器的匿名卷。</span><br><span class="line">    --remove-orphans        为服务删除没有在compose文件中声明的容器</span><br><span class="line">    -t, --timeout TIMEOUT   指定几秒后关闭（默认10s）</span><br></pre></td></tr></table></figure></li><li><p><strong><code>events</code></strong>：从容器接收实时事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">events [options] [SERVICE...]</span><br><span class="line">    --json      使用json格式输出事件</span><br></pre></td></tr></table></figure></li><li><p><strong><code>exec</code></strong>：在运行的容器中执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exec [options] [-e KEY=VAL...] SERVICE COMMAND [ARGS...]</span><br><span class="line">    -d, --detach      后台运行命令</span><br><span class="line">    --privileged      给进程额外的权限</span><br><span class="line">    -u, --user USER   指定运行命令的用户</span><br><span class="line">    -T                禁止分配伪终端，exec默认分配一个伪终端</span><br><span class="line">    --index=index     设置容器的索引（如果一个服务有多个容器），默认为1</span><br><span class="line">    -e, --env KEY=VAL 设置环境变量</span><br><span class="line">    -w, --workdir DIR 设置工作目录</span><br></pre></td></tr></table></figure></li><li><p><strong><code>images</code></strong>：列出镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">images [options] [SERVICE...]</span><br><span class="line">    -q, --quiet  静默模式，只显示镜像号</span><br></pre></td></tr></table></figure></li><li><p><strong><code>kill</code></strong>：杀死容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill [options] [SERVICE...]</span><br><span class="line">    -s SIGNAL         发送给容器的SIGNAL，默认为SIGKILL</span><br></pre></td></tr></table></figure></li><li><p><strong><code>logs</code></strong>：显示容器的输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logs [options] [SERVICE...]</span><br><span class="line">    --no-color          单色输出</span><br><span class="line">    -f, --follow        按照日志输出</span><br><span class="line">    -t, --timestamps    显示时间戳</span><br><span class="line">    --tail=&quot;all&quot;        显示日志的末尾行数</span><br></pre></td></tr></table></figure></li><li><p><strong><code>pause</code></strong>：暂停服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pause [SERVICE...]</span><br></pre></td></tr></table></figure></li><li><p><strong><code>ps</code></strong>：列出容器，执行此命令时必须<code>cd</code>到项目的根目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps [options] [SERVICE...]</span><br><span class="line">    -q, --quiet          静默，只显示容器号</span><br><span class="line">    --services           显示服务</span><br><span class="line">    --filter KEY=VAL     根据属性过滤服务</span><br></pre></td></tr></table></figure></li><li><p><strong><code>port</code></strong>：显示用于绑定的公共端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port [options] SERVICE PRIVATE_PORT</span><br><span class="line">    --protocol=proto  选择协议，tcp或udp，默认tcp</span><br><span class="line">    --index=index     设置容器的索引，默认为1</span><br></pre></td></tr></table></figure></li><li><p><strong><code>pull</code></strong>：拉取服务镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pull [options] [SERVICE...]</span><br><span class="line">    --ignore-pull-failures  忽略拉取失败的镜像</span><br><span class="line">    --parallel              并行拉取多个镜像，默认开启，官方不推荐</span><br><span class="line">    --no-parallel           禁止并行拉取多个镜像</span><br><span class="line">    -q, --quiet             静默模式，不显示拉取信息</span><br><span class="line">    --include-deps          同时拉取依赖的服务</span><br></pre></td></tr></table></figure></li><li><p><strong><code>push</code></strong>：推送服务镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push [options] [SERVICE...]</span><br><span class="line">    --ignore-push-failures  忽略推送失败的镜像</span><br></pre></td></tr></table></figure></li><li><p><strong><code>restart</code></strong>：重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">restart [options] [SERVICE...]</span><br><span class="line">  -t, --timeout TIMEOUT      指定几秒后重启（默认10s）</span><br></pre></td></tr></table></figure></li><li><p><strong><code>rm</code></strong>：删除停止的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rm [options] [SERVICE...]</span><br><span class="line">    -f, --force   不询问确认删除</span><br><span class="line">    -s, --stop    在删除前自动停止容器</span><br><span class="line">    -v            删除任何关联的匿名数据卷，默认不会删除</span><br></pre></td></tr></table></figure></li><li><p><strong><code>run</code></strong>：运行一次性命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">run [options] [-v VOLUME...] [-p PORT...] [-e KEY=VAL...] [-l KEY=VALUE...] SERVICE [COMMAND] [ARGS...]</span><br><span class="line">    -d, --detach          后台运行</span><br><span class="line">    --name NAME           设置容器名</span><br><span class="line">    --entrypoint CMD      覆盖容器的ENTRYPOINT</span><br><span class="line">    -e KEY=VAL            设置环境变量</span><br><span class="line">    -l, --label KEY=VAL   添加或覆盖标签</span><br><span class="line">    -u, --user=&quot;&quot;         以指定用户执行，可设置用户名或uid</span><br><span class="line">    --no-deps             不启动相连的服务，默认依赖的服务也会启动</span><br><span class="line">    --rm                  在运行后删除容器，不与-d兼容</span><br><span class="line">    -p, --publish=[]      发布公共端口</span><br><span class="line">    --service-ports       通过已启用并映射到主机的端口执行命令</span><br><span class="line">    --use-aliases         在容器连接的网络中使用服务的网络别名</span><br><span class="line">    -v, --volume=[]       Bind mount挂载一个数据卷</span><br><span class="line">    -T                    禁止分配伪终端（tty），默认run会分配一个</span><br><span class="line">    -w, --workdir=&quot;&quot;      容器中的工作目录</span><br></pre></td></tr></table></figure></li><li><p><strong><code>start</code></strong>：启动已存在的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start [SERVICE...]</span><br></pre></td></tr></table></figure></li><li><p><strong><code>stop</code></strong>：停止运行中的容器，并不会删除它们</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop [options] [SERVICE...]</span><br><span class="line">  -t, --timeout TIMEOUT      指定几秒后关闭（默认10s）</span><br></pre></td></tr></table></figure></li><li><p><strong><code>top</code></strong>：显示服务的进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [SERVICE...]</span><br></pre></td></tr></table></figure></li><li><p><strong><code>unpause</code></strong>：恢复暂停的服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unpause [SERVICE...]</span><br></pre></td></tr></table></figure></li><li><p><strong><code>up</code></strong>：创建并启动容器</p><p>默认会启动相连的服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">up [options] [--scale SERVICE=NUM...] [SERVICE...]</span><br><span class="line">    -d, --detach               后台运行。与--abort-on-container-exit不兼容</span><br><span class="line">    --no-color                 单色输出</span><br><span class="line">    --quiet-pull               静默拉取</span><br><span class="line">    --no-deps                  不启动连接的服务</span><br><span class="line">    --force-recreate           强制重建服务（即使配置和镜像都没变）</span><br><span class="line">    --always-recreate-deps     重建依赖的服务，与--no-recreate不兼容</span><br><span class="line">    --no-recreate              若容器存在就不会重建，与--force-recreate和-V不兼容</span><br><span class="line">    --no-build                 即使镜像丢失也不重建镜像</span><br><span class="line">    --no-start                 在构建服务后不启动该服务</span><br><span class="line">    --build                    在启动容器前先构建镜像</span><br><span class="line">    --abort-on-container-exit  如果任何容器停止，就停止所有容器，与-d不兼容</span><br><span class="line">    -t, --timeout TIMEOUT      设置容器几秒后关闭（默认10s）</span><br><span class="line">    -V, --renew-anon-volumes   重建匿名卷而不是从以前的容器中恢复数据。</span><br><span class="line">    --remove-orphans           删除服务的compose文件中未定义的容器</span><br><span class="line">    --exit-code-from SERVICE   返回指定服务的退出码 Implies --abort-on-container-exit.</span><br><span class="line">    --scale SERVICE=NUM        将SERVICE扩展到NUM个实例。会覆盖Compose文件中的&quot;scale&quot;设置（如果存在）</span><br></pre></td></tr></table></figure></li></ul><h1 id="Compose文件格式"><a href="#Compose文件格式" class="headerlink" title="Compose文件格式"></a>Compose文件格式</h1><p>Compose文件采用<a href="">YAML语法</a>，文件名以<code>.yml</code>或<code>.yaml</code>结尾，默认应存放在项目的根目录中，文件名应为<code>docker-compose.yml</code>。在Compose文件中无需再指定Dockerfile中已定义的项。</p><p>文件格式为3.7，所以compose文件最开始要写上<code>version: &quot;3&quot;</code></p><p>然后定义服务<code>services</code>，在<code>services:</code>下添加服务，开始对服务的配置。</p><p><code>build</code>：用于指定在构建时应用的配置选项。</p><p><code>context</code>：用于指定构建上下文。</p><p><code>dockerfile</code>：用于指定Dockerfile文件</p><p><code>args</code>：用于给Dockerfile文件中<code>ARG</code>定义的参数传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services: </span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir     可以这样直接指定上下文路径</span><br><span class="line">    </span><br><span class="line">  webapp:</span><br><span class="line">    build:           也可以作为具有在上下文中指定的路径的对象</span><br><span class="line">      context: ./dir 然后通过context指定上下文路径</span><br><span class="line">      当提供的值是相对路径时，context被解释为相对于Compose文件的位置。此目录也是发送到Docker daemon的构建上下文</span><br><span class="line">    build: </span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: webapp.dockerfile   还可以指定Dockerfile文件</span><br><span class="line">      args:          可以为Dockerfile文件传参</span><br><span class="line">        args1: 123</span><br><span class="line">        args2: 345</span><br><span class="line">      也可以这样表示：</span><br><span class="line">      args: </span><br><span class="line">      - args1=123</span><br><span class="line">      - args2=345</span><br><span class="line">    image: webapp:tag  可以指定构建镜像，会生成一个名为webapp，并打上tag标签的镜像</span><br><span class="line">    在群集模式下使用Compose文件（版本3）部署堆栈时，将忽略image选项。 docker stack命令仅接受预先构建的图像。</span><br></pre></td></tr></table></figure><blockquote><p>注：YAML布尔值（true，false，yes，no，on，off）必须用引号括起来，以便解析器将它们解释为字符串。</p></blockquote><p><code>cache_from</code>：指定Docker引擎用于实现缓存的镜像列表</p><p><code>labels</code>：使用标签将元数据添加到生成的镜像中，可使用数组或字典</p><p><code>shm_size</code>：为构建的容器设置<code>/dev/shm</code>分区的大小，指定字节数或字节值字符串，如<code>2mb</code>或<code>2000000</code></p><p><code>target</code>：根据Dockerfile中的定义构建指定的阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">build:</span><br><span class="line">  context: .</span><br><span class="line">  target: prod</span><br></pre></td></tr></table></figure><p><code>cap_add</code>和<code>cap_drop</code>：添加或删除容器功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - NET_ADMIN</span><br><span class="line">  - SYS_ADMIN</span><br></pre></td></tr></table></figure><p><code>command</code>：覆盖容器启动后默认执行的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">或使用列表表示：</span><br><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure><p><code>container_name</code>：自定义该容器名称。由于Docker容器名称必须是唯一的，因此如果指定了自定义名称，则无法将服务扩展到多个容器</p><p><code>volumes</code>：卷挂载路径设置。格式：<code>宿主机源路径:容器目的路径[:访问权限]</code>，默认访问权限为读写。可使用相对路径，相对于compose文件所在目录。</p><p><code>links</code>：链接到另一个服务中的容器，格式：<code>服务名[:别名]</code></p><p><code>external-links</code>：链接到docker-compose.yml外部的容器，甚至并非 Compose 管理的容器。</p><p><code>expose</code>：暴露端口，但不映射到宿主机，只被连接的服务访问。最好使用字符串表示数字，因为YAML会解析<code>xx:yy</code>这种数字格式为 60 进制，容器端口小于 60 可能出错。</p><p><code>ports</code>：暴露端口信息，格式：<code>[宿主机IP:][端口:]容器端口</code>，可用<code>-</code>表示一个端口范围</p><h1 id="docker-compose示例"><a href="#docker-compose示例" class="headerlink" title="docker-compose示例"></a>docker-compose示例</h1><p>首先是docker-compose官方文档中的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://blog.csdn.net/vchy_zhao/article/details/70238413" target="_blank" rel="noopener">Docker三剑客之Compose-一</a></li><li><a href="https://blog.csdn.net/vchy_zhao/article/details/70238432" target="_blank" rel="noopener">Docker三剑客之Compose-二</a></li><li><a href="https://blog.csdn.net/vchy_zhao/article/details/70238461" target="_blank" rel="noopener">Docker三剑客之Compose-三</a></li><li><a href="https://blog.csdn.net/pushiqiang/article/details/78682323" target="_blank" rel="noopener">docker-compose教程（安装，使用, 快速入门）</a></li><li><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">docker-compose官方文档</a></li><li><a href="https://www.cnblogs.com/ee900222/p/docker_5.html" target="_blank" rel="noopener">Docker系列之（五）：使用Docker Compose编排容器</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> docker-compose </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 容器编排 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kubernetes学习笔记-1</title>
      <link href="/2018/07/13/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/13/Kubernetes%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker存储学习笔记-1</title>
      <link href="/2018/07/06/Docker%E5%AD%98%E5%82%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/07/06/Docker%E5%AD%98%E5%82%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>主要是对docker文档(v18.03)的翻译以及自己的学习笔记</strong><br>本篇主要包含以下内容</p><ul><li><a href="#Docker存储介绍">Docker存储介绍</a></li><li><a href="#BindMount">BindMount</a></li><li><a href="#Volume数据卷">Volume数据卷</a></li><li><a href="#数据卷容器">数据卷容器</a><a id="more"></a></li></ul><h2 id="Docker存储介绍"><a href="#Docker存储介绍" class="headerlink" title="Docker存储介绍"></a>Docker存储介绍</h2><p>Docker为容器提供了两种存放数据的资源：</p><ul><li>storage driver：管理的镜像层和容器层<br>  特点：Copy-on-Write。新数据会存放在最上层容器层，修改现有数据会先从镜像层复制到容器层，修改后的数据直接保存在容器中，镜像层保持不变。若多层中有同名文件，用户只能看到最上层的文件。<br>  可通过docker info查看到。Docker优先使用默认的storage driver。</li><li>data volume数据卷<br>  特点：是目录或文件，不是磁盘，volume数据可以被永久的保存，即使使用它的容器已经销毁。<br>  分为两种volume：bind mount 和docker managed volume</li></ul><p><strong>存储驱动：</strong>目前docker支持五种存储驱动。详见<a href="#存储引擎">存储引擎</a></p><ol><li>AUFS  </li><li>Btrfs  </li><li>Device Mapper  </li><li>Overlay  </li><li>ZFS</li></ol><p><strong>原理：</strong></p><ol><li>Copy-On-Write写时复制<br> 所有驱动都是用到Cow写时复制（copy-on-write），只在需要写时才复制。可以让所有容器都共享一个image文件系统，所有数据都从image读取，容器需要写操作时，才将要写的文件从image复制到自己的文件系统，即所有写操作都是对image中副本的修改。有效提高了磁盘利用率。</li><li>allocate-on-demand用时分配<br> 在要写入一个文件时才按需分配空间</li></ol><p><strong>驱动：</strong></p><ol><li>AUFS：一种Union FS联合文件系统，文件级存储。支持将不同目录挂载到同一个虚拟文件系统，下层文件系统只可读，最上层可写。若要修改，AUFS会创建一个该文件的副本，放在可写层，结果也保存在可写层。</li><li>Overlay：一种UnionFS，文件级存储。只有两层：upper层和lower层</li><li>Device Mapper：RHEL下Docker Engine的默认存储驱动，基于同名级卷管理技术框架的存储引擎。</li></ol><p>默认情况下，在容器内创建的所有文件都存储在可写容器层中，仅存储在主机系统的内存中，即<code>tmpfs</code>方式，永远不会写入主机系统的文件系统，因此一旦容器停止，容器内所有文件的改动都会丢失，所以需要通过一些机制将文件保存以至于在容易停止后仍不会丢失。</p><p>docker有三种存储容器数据的方式：</p><ul><li><a href="#BindMount"><code>bind mount</code></a>：可将容器数据存放在宿主机的任何位置。</li><li><a href="#Volume数据卷"><code>volumes</code></a>：通过创建数据卷将容器数据持久化到文件系统。</li><li><a href="#Tmpfs"><code>tmpfs</code></a>：数据存放在内存中，不会写入文件系统。</li></ul><img src="/2018/07/06/Docker存储学习笔记/types-of-mounts.png"><h2 id="BindMount"><a href="#BindMount" class="headerlink" title="BindMount"></a>BindMount</h2><p><code>bind mount</code>可使容器中的文件存储在主机系统的任何位置。Docker主机或Docker容器上的非Docker进程可以随时修改它们。bind mount非常高效，但它们依赖于具有特定目录结构的主机文件系统。</p><p>docker提供两种选项进行bind mount。</p><ul><li><code>-v</code>或<code>--volume</code>：三个字段组成，冒号分隔。</li></ul><ol><li>第一个字段：卷名，若是匿名卷，则可省略</li><li>第二个字段：文件或目录在容器中安装的路径</li><li>第三个字段：可选项，例如<code>ro</code>，默认是可读可写</li></ol><ul><li><code>--mount</code>：由多个键值对组成，用逗号分隔，键和值用<code>=</code>连接。以下是提供的键：</li></ul><ol><li><code>type</code>：挂载的类型，可以是bind，volume或tmpfs。</li><li><code>source</code>或<code>src</code>：挂载源，即卷名。匿名卷可省略。</li><li><code>destination</code>或<code>dst</code>或<code>target</code>：挂载到的容器中的指定目录或文件路径</li><li><code>readonly</code>：以只读方式挂载，可选。</li><li><code>volume-opt</code>：卷选项，可指定多次，也是键值对形式</li><li><code>bind-propagation</code>：绑定传播，有以下选择：<code>rprivate</code>，<code>private</code>，<code>rshared</code>，<code>shared</code>，<code>rslave</code>，<code>slave</code><br>注：–mount不支持设置selinux的<code>z</code>或<code>Z</code>选项</li></ol><p><strong>如果使用<code>-v</code>或<code>--volume</code>绑定安装Docker主机上尚不存在的文件或目录，则-v会为您创建端点。它始终作为目录创建。而如果使用<code>--mount</code>，Docker不会自动为您创建它，但会生成错误。</strong></p><p><strong>注：</strong>bind mount允许访问敏感文件<br>使用bind mount的一个副作用：可以通过容器中运行的进程更改主机文件系统，包括创建，修改或删除重要的系统文件或目录。这是一种强大的功能，可能会产生安全隐患，包括影响主机系统上的非Docker进程。</p><p>当挂载一个bind mount或非空数据卷到容器中的一个非空目录，则该目录中原有的文件会被掩盖（并非删除），而只显示挂载的卷内容。当挂载一个空数据卷到容器中的一个非空目录，则该目录中的文件都会复制到该卷中。若启动容器时指定了一个不存在的数据卷，则会自动创建一个卷。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用-v挂载</span><br><span class="line">docker run -v &lt;源目录或文件&gt;:&lt;容器中目录或文件&gt;</span><br><span class="line"># 路径都需要绝对路径</span><br><span class="line"># 若添加单个文件，主机源文件必须存在，否则会当做一个新目录挂载到容器</span><br><span class="line">使用--mount挂载</span><br><span class="line">docker run --mount type=bind,src=&lt;源目录或文件&gt;,dst=&lt;容器目录或文件&gt;</span><br></pre></td></tr></table></figure><p><code>docker inspect 容器</code>查看是否挂载了数据卷</p><h3 id="bind-propagation传播挂载"><a href="#bind-propagation传播挂载" class="headerlink" title="bind-propagation传播挂载"></a>bind-propagation传播挂载</h3><p>在指定的bind mount或数据卷上挂载是否能被复制到挂载的目录中去。用于做动态，可通过编排工具方便实现。</p><p>有以下几种选项：</p><ul><li>shared：源挂载的子挂载会暴露给副本挂载，副本挂载的子挂载也会复制到源挂载。</li><li>slave：类似于shared，但只在一个方向上。如果源挂载暴露了子挂载，则副本挂载可以看到它。但是，如果副本挂载暴露了子挂载，则源装载无法看到它。</li><li>private：此挂载是私人的。其中的子挂载不会暴露给副本挂载，副本挂载的子挂载不会暴露给源挂载。</li><li>rshared：与shared相同，但传播也扩展到嵌套在任何源或副本挂载中的挂载点。</li><li>rslave：与slave相同，但传播也扩展到嵌套在任何源或副本挂载中的挂载点。</li><li>rprivate：默认值。与private相同，源或副本挂载中任何位置的挂载点都不会沿任一方向传播。</li></ul><h3 id="Selinux标签"><a href="#Selinux标签" class="headerlink" title="Selinux标签"></a>Selinux标签</h3><p>如果使用selinux，则可以添加<code>z</code>或<code>Z</code>选项以修改要挂载到容器的主机文件或目录的selinux标签。这会影响主机本身上的文件或目录，并且可能会影响到Docker外部。</p><ul><li><code>z</code>选项表示绑定装载内容在多个容器之间共享。</li><li><code>Z</code>选项表示绑定装载内容是私有且非共享的。使用<code>Z</code>选项绑定安装系统目录（例如<code>/home</code>或<code>/usr</code>）会导致主机无法运行。</li></ul><p>当bind mount和service一起使用时，会自动忽略selinux标签（<code>z</code>和<code>Z</code>）还有<code>ro</code>。</p><h2 id="Volume数据卷"><a href="#Volume数据卷" class="headerlink" title="Volume数据卷"></a>Volume数据卷</h2><p>卷是保存Docker容器生成和使用的数据的首选机制，并且卷完全由Docker管理。<br>写入容器的可写层需要存储驱动程序来管理文件系统，存储驱动程序使用Linux内核提供联合文件系统UFS。而数据卷是经过特殊设计的目录，可以绕过联合文件系统，为多个容器提供访问。数据卷的目的在于数据永久化，完全独立于容器的生存周期，容器删除时挂载的数据卷不会被删除。</p><p>特点：</p><ul><li>卷比bind mount更容易备份或迁移。</li><li>卷适用于Linux和Windows容器。</li><li>可以在多个容器之间更安全地共享卷。</li><li>在容器启动时初始化，若挂载点已有数据，则会被拷贝到新初始化的数据卷中</li><li>数据卷变化不会影响镜像更新</li><li>卷驱动程序允许在远程主机或云提供程序上存储卷，加密卷的内容或添加其他功能。 </li></ul><p>可通过<code>docker volume create 数据卷名</code>创建数据卷。每创建一个volume，就会在<code>/var/lib/docker/volumes</code>中创建一个同名目录。若不指定数据卷名，就会随机生成一个volume ID作为数据卷名。</p><p><code>docker volume</code>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create 创建数据卷</span><br><span class="line">inspect 查看数据卷信息</span><br><span class="line">ls 查看所有数据卷</span><br><span class="line">prune 删除未使用的数据卷</span><br><span class="line">rm 删除指定数据卷</span><br></pre></td></tr></table></figure></p><p>在创建volume时或启动使用为创建卷的容器时，可以指定卷的驱动。<br>数据卷驱动可通过<code>docker plugin install [选项] 驱动名</code>。<br><strong>如果卷驱动程序要求您传递选项，则必须使用<code>--mount</code>标志来装入卷</strong></p><p>docker提供<code>-v</code>和<code>--mount</code>选项进行挂载。使用与bind mount基本一致。<br>如果需要指定卷驱动程序选项，则必须使用<code>--mount</code>。将卷与服务一起使用时，仅支持<code>--mount</code>。</p><p><strong>注：挂载数据卷不支持单个文件，只能是目录。且不权限控制，均为可读写。</strong><br>因为容器配置文件里的可以指定<code>docker inspect</code>查看，发现<code>Mounts</code>中的<code>Source</code>字段，其中已指定了源，源为：<code>/var/lib/docker/volumes/容器长ID/_data</code>。</p><p>以上两种方法数据源其实还是宿主机中的，并不是真正放在volume container中，可以在通过dockerfile的<code>ADD</code>将数据打包进镜像并指定<code>VOLUME</code>，将<code>ADD</code>指定的目录与<code>VOLUME</code>设为一致，此法称为<code>data-packed volume container</code>。</p><h2 id="Tmpfs"><a href="#Tmpfs" class="headerlink" title="Tmpfs"></a>Tmpfs</h2><p>使用<code>tmpfs mount</code>创建容器时，容器可以在容器的可写层之外创建文件。tmpfs挂载是临时的，仅保留在主机内存中。当容器停止时，将删除tmpfs挂载，该数据不可被共享，Docker默认使用tmpfs挂载。<br><code>--tmpfs</code>：安装tmpfs挂载而不允许指定任何可配置选项，并且只能与独立容器一起使用。<br>也可以通过<code>--mount</code>指定<code>type=tmpfs</code>。</p><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>容器挂载数据卷，其他容器通过挂载该容器实现数据共享，挂载数据卷的容器称为数据卷容器。</p><p>创建容器时<code>--volumes-from 数据卷容器</code>创建数据卷容器<br><strong>注：由于数据卷容器仅是提供数据，所以只要create，不用run</strong><br><code>docker rm -v 容器</code> 在删除容器时一并删除数据卷。但是，只要有容器还在使用该数据卷，数据卷就不会删除。宿主机上的数据卷若删除，就真的没了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; docker volume create volume_1</span><br><span class="line">&gt; docker volume create volume_2</span><br><span class="line"># 创建数据卷容器，挂载volume_1，volume_2</span><br><span class="line">&gt; docker create \</span><br><span class="line">    -v volume_1:/volume1 \</span><br><span class="line">    -v volume_2:/volume2 \</span><br><span class="line">    --name vol_container \</span><br><span class="line">    alpine</span><br><span class="line"># 创建容器挂载数据卷容器</span><br><span class="line">&gt; docker run -it \</span><br><span class="line">    --volumes-from vol_container \</span><br><span class="line">    --name test \</span><br><span class="line">    alpine</span><br><span class="line">/ # ls</span><br><span class="line">bin       home      mnt       run       sys       var</span><br><span class="line">dev       lib       proc      sbin      tmp       volume1</span><br><span class="line">etc       media     root      srv       usr       volume2</span><br><span class="line"># 数据卷容器中挂载的数据卷也被挂载到新容器的根目录了，也可通过-v设置挂载点</span><br></pre></td></tr></table></figure><h3 id="数据卷备份、还原与迁移"><a href="#数据卷备份、还原与迁移" class="headerlink" title="数据卷备份、还原与迁移"></a>数据卷备份、还原与迁移</h3><p>使用数据卷能方便地进行数据备份、迁移和还原。<br><img src="/2018/07/06/Docker存储学习笔记/beifen-1.jpg"></p><h4 id="备份一个容器"><a href="#备份一个容器" class="headerlink" title="备份一个容器"></a>备份一个容器</h4><p>首先创建一个数据卷，用于存放备份数据。<br><code>docker volume create vol_backup</code><br>然后创建一个数据卷容器，挂载该数据卷<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker create --name backup_container\</span><br><span class="line">     -v vol_backup:/backup \</span><br><span class="line">     alpine</span><br></pre></td></tr></table></figure></p><p>接着运行要备份容器，挂载数据卷容器backup_container，并将要备份的数据打包放入数据卷。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">    --volumes-from backup_container \</span><br><span class="line">    -v /backup \</span><br><span class="line">    alpine tar -cvf /backup/data.tar /usr /var</span><br></pre></td></tr></table></figure></p><p>在主机的<code>/var/lib/docker/volumes/vol_backup/_data/</code>中出现了打包后的<code>data.tar</code></p><h4 id="还原一个容器"><a href="#还原一个容器" class="headerlink" title="还原一个容器"></a>还原一个容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">    --volumes-from backup_container \</span><br><span class="line">    -v /backup \</span><br><span class="line">    alpine \</span><br><span class="line">    bash -c &quot;cd /dbdata &amp;&amp; tar xvf /backup/data.tar --strip 1&quot;</span><br></pre></td></tr></table></figure><h4 id="删除一个数据卷"><a href="#删除一个数据卷" class="headerlink" title="删除一个数据卷"></a>删除一个数据卷</h4><p>删除的数据卷有两种情况：</p><ul><li>命名卷在容器外部有指定源，删除了容器，数据卷并不会被删除</li><li>匿名卷没有指定源，在删除容器时，该匿名卷也会被删除。也可在创建容器时，加上<code>--rm</code>参数，关闭时自动删除容器和匿名卷。</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="#https://docs.docker.com/storage/">Docker官方文档-存储</a><br>每天5分钟玩转docker容器技术</p>]]></content>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见VPN技术笔记</title>
      <link href="/2018/06/18/%E5%B8%B8%E8%A7%81VPN%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/18/%E5%B8%B8%E8%A7%81VPN%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>华三网络学习笔记（理论）</strong></p><p>本篇包含以下知识点</p><ul><li><a href="#VPN概述">VPN概述</a></li><li><a href="#GRE-VPN">GRE-VPN</a></li><li><a href="#L2TP-VPN">L2TP-VPN</a></li><li><a href="#IPSEC-VPN">IPSEC-VPN</a><ul><li><a href="#GRE-OVER-IPSEC">GRE-OVER-IPSEC</a></li><li><a href="#IPSEC-OVER-GRE">IPSEC-OVER-GRE</a></li></ul></li><li><a href="#MPLS">MPLS</a></li><li><a href="#BGP-MPLS-VPN">BGP-MPLS-VPN</a></li><li><a href="#SSL-VPN">SSL-VPN</a><a id="more"></a></li></ul><h2 id="VPN概述"><a href="#VPN概述" class="headerlink" title="VPN概述"></a>VPN概述</h2><p>Virtual Private Network虚拟私有网，利用共享公共网络仿真WAN设施，构建私有的专用网络。基于IP的VPN体系的核心是使用Tunnel隧道技术。</p><p><strong>VPN的优势</strong></p><ul><li>快速构建，降低部署周期</li><li>与私有网络一样的安全性、可靠性与可管理性</li><li>提高了基础资源的利用率</li><li>简化了用户端的配置和维护工作</li></ul><img src="/2018/06/18/常见VPN技术笔记/1.png"><p><strong>概念术语</strong></p><ul><li>承载协议：在公网传输时使用的协议</li><li>封装协议：用于标识承载协议中封装的数据包，放置在承载协议头与载荷协议头间</li><li>载荷协议：最初封装数据包的协议</li><li>隧道协议：决定如何实现隧道的协议</li></ul><img src="/2018/06/18/常见VPN技术笔记/2.png"><p><strong>主要VPN技术</strong><br>L2 VPN技术</p><ul><li>L2TP VPN：二层隧道协议，可实现拨号VPN与专线VPN</li><li>PPTP VPN：点到点隧道协议，支持PPP在IP网络上的隧道封装，使用增强GRE技术为传输的PPP报文提供流控与拥塞控制的封装</li><li>MPLS L2 VPN：多协议标签交换<br>L3 VPN技术</li><li>GRE VPN：通用路由封装，可在任意协议中封装任意协议的封装方法</li><li>IPSEC VPN：IP安全，并不是单个协议，而是一系列协议组成的数据安全体系，包括AH、ESP、IKE等，实现对数据私密性、完整性保护与源校验</li><li>BGP/MPLS VPN：多协议BGP，利用MPLS与MP-BGP技术</li><li>SSL VPN：安全套接字层，使用SSL协议实现远程VPN</li></ul><h2 id="GRE-VPN"><a href="#GRE-VPN" class="headerlink" title="GRE-VPN"></a>GRE-VPN</h2><p>Generic Routing Encapsulation通用路由封装，是一种能在任意协议中封装任意协议的封装方法，可以直接使用GRE封装建立GRE隧道，为IP协议，协议号47。以下为<br>GRE封装包的格式。</p><img src="/2018/06/18/常见VPN技术笔记/3.jpg"><p>GRE头包含了2字节的<code>Protocol Type</code>，用于指示载荷协议类型，<code>IP</code>协议为<code>0x0800</code>。此外还有扩展GRE头，增加了<code>Key</code>和<code>Sequence Number</code>，具备标识数据流和分组次序的能力。<br>IP协议使用协议号47标识GRE头，说明IP头后跟着GRE头。而GRE头中protocol type若为0x0800，说明GRE头后跟着IP头。</p><img src="/2018/06/18/常见VPN技术笔记/4.png"><p>双方通过Tunnel接口（逻辑接口）建立隧道，再通过实际物理接口进行转发。tunnel口为载荷协议服务，物理口为承载协议服务。<br><img src="/2018/06/18/常见VPN技术笔记/5.png"></p><p>GRE隧道通信过程：</p><ol><li>隧道起点路由查找：隧道两端的路由器必须是私网边界路由器。收到数据包时查找ip路由表</li><li>加封装：查找路由表确认下一跳为tunnel口，则进行GRE封装。</li><li>承载协议路由转发：对封装后的包进行公网路由查询。</li><li>中途转发：即公网转发</li><li>解封装：到达对端私网边界路由器后，该路由器检查IP地址，若是自己则解开IP头，发现有GRE头，就交给目标Tunnel口，tunnel口解开GRE头</li><li>隧道终点路由转发：解开GRE头后，发现私网IP目的地址，然后查表转发。</li></ol><p>每个运行GRE的路由器只有一个路由表，公网和私网之间只能通过不同的路由加以区分，因此公网私网IP地址能重复，且公网私网必须采用不同策略。</p><ul><li>连接到私网的物理接口和Tunnel口属于私网路由AS，采用一致的私网路由策略。</li><li>连接到公网的物理接口属于公网路由AS，必须和公网采用一致的路由策略。</li></ul><p>优点：</p><ol><li>支持多种协议  </li><li>支持IP路由协议和组播 </li></ol><p>缺点：</p><ol><li>点对点隧道  </li><li>静态配置隧道  </li><li>缺乏安全性  </li><li>不可分配地址空间  </li><li>部署复杂</li></ol><p>静态路由配置：配置到达目的IP的私网网段路由，下一跳为对端Tunnel口的地址。<br>动态路由配置：将隧道和私网作为一个AS看待，动态路由需要将Tunnel口和私网都包括。</p><p>Tunnel口虚假状态：GRE本身不对隧道状态维护，系统默认根据接口状态设置Tunnel状态，即若物理链路中出现故障，物理口仍为UP，则隧道口也为UP，而此时隧道却不通。只存在于静态配置时。<br>解决：tunnel口keepalive机制：允许路由器探测隧道口的实际状态。路由器会从tunnel口周期发keepalive消息，默认周期10s，若连续3次未收到，则认为隧道不通，会自动删除该tunnel口为出接口的静态路由。</p><h2 id="L2TP-VPN"><a href="#L2TP-VPN" class="headerlink" title="L2TP-VPN"></a>L2TP-VPN</h2><p>对PPP协议链路提供隧道，允许二层链路端点和PPP会话点驻留在不同设备上，并采用分组交换技术进行信息交互。使用PSTN/ISDN拨号、xDSL直接连接到ISP位于本地的POP（存在点），或直接连接到Internet获得IP通信服务，然后ISP设备或用户设备建立L2TP通道连接对端。</p><p>L2TP特点：</p><ul><li>L2TP支持对用户和隧道的验证，和对客户端的动态地址分配。可使用PPP验证，也可使用LAC提供的AAA验证</li><li>具备点到网络特性。适合单个或少量接入</li><li>不提供加密，但可结合IPSec等加密</li><li>面向连接，为信息提供一定的可靠性</li></ul><p>L2TP组件：</p><ul><li>LAC：L2TP访问集中器，隧道就在LAC和LNS间建立</li><li>LNS：L2TP网络服务器</li><li>NAS：网络访问服务器，抽象概念，是远程访问的接入点，可以是LAC或LNS</li></ul><p>两种拓扑方式：</p><ol><li>独立LAC：ISP提供LAC，不依赖IP接入点。<br>条件：ISP支持L2TP，验证系统支持VPDN属性<br>特点：终端用户不需要配置VPN拨号软件，只需要执行普通拨号，登录一次就可以接入企业网。</li><li>客户LAC：远程系统安装VPDN客户端，直接对LNS发起连接请求。不依赖LAC，验证只能由LNS执行<br>条件：远程系统必须接入Internet，远程系统需要安装专用客户端软件并配置<br>特点：只需配置VPN软件即可与企业网建立VPN连接。对用户的验证只能由LNS端执行。</li></ol><p>L2TP封装：<br>L2TP以UDP/IP为承载协议，UDP端口号为1701。<br><img src="/2018/06/18/常见VPN技术笔记/6.png"><br>L2TP头中<code>Type</code>字段标识消息类型，若为1表示控制消息，若为0表示数据消息。<br><code>Tunnel ID</code>字段标识L2TP控制连接，即隧道标识符，是在隧道建立时通过<code>Assigned Tunnel ID AVP</code>交换的。<br><code>Session ID</code>字段用于标识一个隧道中的各个会话，是在隧道建立时通过<code>Assigned Session ID AVP</code>交换的。</p><blockquote><p>控制连接：在L2TP隧道内部，建立维护和释放会话与隧道<br>控制消息：LAC与LNS间交换的隧道内消息，用于对隧道操作。包含AVP（属性值对，通过发送AVP对隧道建立维护或释放，即管理隧道和会话）</p></blockquote><p>L2TP协议操作：</p><ol><li>建立控制连接：由PPP触发<br>（1）LAC使用任意UDP端口向LNS的UDP1701端口发起连接（<code>SCCRQ</code>打开控制连接请求）<br>（2）LNS将连接重定向到一个随机UDP端口并回应（<code>SCCRP</code>打开控制连接应答）<br>（3）LAC收到后返回确认（<code>SCCCN</code>打开控制连接已确认）<br>（4）LNS收到后再确认，隧道建立（<code>ZLB</code>零长度体）<br>若要执行隧道验证，可在<code>SCCRQ</code>或<code>SCCRP</code>中加上<code>Challenge AVP</code>（挑战AVP）发起验证，接收方要在回应中加上<code>Challenge Response AVP</code>（挑战响应AVP）。</li><li>建立会话：前提为控制连接的建立。由PPP模块触发<br>LAC发起：<br>（1）LAC向LNS发送<code>ICRQ</code>（入呼叫请求）发起会话建立<br>（2）LNS收到请求后返回<code>ICRP</code>（入呼叫应答）<br>（3）LAC收到应答后返回<code>ICCN</code>（入连接已连接）<br>（4）LNS再回应<code>ZLB</code>，会话建立<br>LNS发起：<br>（1）LNS发送<code>OCRQ</code>（出呼叫请求）发起会话建立<br>（2）LAC收到后返回<code>OCRP</code>（出呼叫应答）<br>（3）LAC执行呼叫，返回<code>OCCN</code>（出呼叫已连接）<br>（4）LNS收到后回应<code>ZLB</code>，会话建立<br>会使用<code>Tunnel ID</code>和<code>Session ID</code>区分不同隧道和会话</li><li>隧道状态维护<br>LAC与LNS互发<code>Hello</code>消息维持会话，默认周期60s，若三次未收到对方的Hello消息，则认为隧道断开。</li><li>关闭会话与控制链接<br>关闭会话：<br>（1）LAC发送<code>CDN</code>（呼叫断开通知），通知LNS关闭会话<br>（2）LNS收到后返回<code>ZLB</code>，并关闭会话<br>关闭控制连接：<br>（1）LAC发送<code>StopCCN</code>（停止控制连接通知），通知LNS关闭控制连接<br>（2）LNS收到后回应<code>ZLB</code>，并关闭控制连接</li><li>L2TP验证<br>1.对拨入的远程系统PPP验证<br>2.LAC与LNS间隧道验证<br>3.LNS对远程系统再次PPP验证。方式分为三种：<br> 1）代理验证：LAC将从远程系统得到的验证信息和自身的验证信息都发给LNS<br> 2）强制CHAP验证：LNS直接对远程系统进行CHAP验证<br> 3）LCP重协商：LNS与远程系统重新进行LCP协商，采用相应虚拟模板接口上配置的验证方式进行验证</li></ol><p>LAC端对远程系统用户的AAA验证包括：</p><ul><li>本地验证：需要LAC端配置本地用户名、密码、服务类型等信息，与用户输入的通过对比进行验证。</li><li>远程验证：需要与RADIUS或TACACS服务器协同验证，需要在RADIUS或TACACS服务器上配置用户验证信息，LAC将用户输入的信息发送给验证服务器进行验证。</li></ul><p><center>下图为：独立LAC隧道会话建立</center><br><img src="/2018/06/18/常见VPN技术笔记/7.png"></p><p><center>下图为：客户LAC隧道会话建立</center><br><img src="/2018/06/18/常见VPN技术笔记/8.png"></p><h2 id="IPSEC-VPN"><a href="#IPSEC-VPN" class="headerlink" title="IPSEC-VPN"></a>IPSEC-VPN</h2><p>一种网络层安全保障机制。可实现访问控制、机密性、完整性校验、数据源校验、拒绝重播报文等。IPSec是可扩展的体系，不受限于任何一种特定算法，可引入多种验证算法、加密算法、密钥管理机制。<br>缺点：复杂，消耗大量资源、数据延迟、点对点、不支持组播</p><h3 id="IPSec-SA"><a href="#IPSec-SA" class="headerlink" title="IPSec SA"></a>IPSec SA</h3><p>IPSec SA：IPSec安全联盟，安全服务通过SA实现。<br>SA是双方的安全协定，包括协议、算法、密钥。SA是单向的，入站和出站数据流分别由入站SA和出站SA处理。</p><p>SA的三元组：</p><ol><li>SPI：安全参数索引，32位数值</li><li>IP目的地址：对方IP地址</li><li>安全协议标识符：标识AH或ESP</li></ol><p>SA建立方式：</p><ol><li>手工配置：两端手动设置参数</li><li>自动协商：双方通过IKE生成维护</li></ol><p>SA具有生存时间，有两种方式：</p><ol><li>时间：每隔定时长更新SA</li><li>流量：每传输一定流量更新SA</li></ol><p>SA协商信息存放在SPD（安全策略数据库），SPD的项指向SAD（安全联盟数据库）相应项</p><h3 id="IKE"><a href="#IKE" class="headerlink" title="IKE"></a>IKE</h3><p>IKE：因特网密钥交换。基于UDP协议，端口号500，为IPSec提供自动协商交换密钥、建立SA服务，实际提供安全服务的是IPSec，采用DH算法交换密钥（精髓）。且可以定时更新密钥和SA，提供了完善的前向安全性。可以为IPSec自动重新建立SA，允许IPSec提供抗重播服务（通过SPI值）。</p><p>采用ISAKMP的密钥交换框架体系<br><strong>IKE安全机制：</strong></p><ol><li>身份验证：预共享密钥（默认）、RSA数字签名、DES数字签名</li><li>DH密钥交换</li><li>PFS完善前向安全性：通过在第二阶段再进行一次DH交换，使IKE SA密钥与IPSec SA密钥无派生关系</li></ol><p><strong>协商两个阶段：</strong></p><ul><li>阶段1：建立一个IKE SA，为阶段2提供保护<br>分为主模式main和野蛮模式aggressive</li></ul><p>主模式：强制实现的阶段1交换模式。共三步，六条消息</p><ol><li>策略协商：A向B发送本地IKE策略，B查找匹配的策略，并确认<br>其中协商属性包括：加密算法，散列算法（MD5、SHA等），验证方法（预共享密钥、DSS、RSA），DH组信息（默认MODP 768），DH公共值，IKE生存时间，身份信息</li><li>DH交换：A向B发起密钥生成信息，B生成密钥并回应。</li><li>ID交换验证：A向B发送身份和验证数据，B回应身份验证。<img src="/2018/06/18/常见VPN技术笔记/13.png"></li></ol><p>野蛮模式：远程拨号时，由于拨号用户IP无法确定，可以使用野蛮模式</p><ol><li>A向B发送本地IKE策略，开始DH交换</li><li>B查找匹配策略，回应验证信息</li><li>A接收确认信息并验证，生成密钥，向B发送验证载荷</li><li>B验证<img src="/2018/06/18/常见VPN技术笔记/14.png"></li></ol><ul><li>阶段2：在IKE SA的保护下完成IPSec SA的协商。采用快速模式</li></ul><blockquote><p>野蛮模式安全性差于主模式，但过程简单快速。<br>在不知道对端IP且需要使用预共享密钥的情况下，必须用野蛮模式。</p></blockquote><h3 id="IPSec包处理流程"><a href="#IPSec包处理流程" class="headerlink" title="IPSec包处理流程"></a>IPSec包处理流程</h3><p><strong>出站包处理：</strong></p><ol><li>查找SPD，三种结果：丢弃、旁路安全服务：直接转发、提供安全服务：查找IPSec SA</li><li>若第一步结果是提供安全服务，就在SAD中找IPsec SA，若找到就根据参数提供安全服务，若找不到就查找IKE SA</li><li>若找到IKE SA，就只要创建IPSec SA，若找不到IKE SA，就要先创建IKE SA，再创建IPSec SA。</li></ol><p><strong>入站包处理：</strong></p><ol><li>检查目的地址是否本地，若是则检查数据包是否被IPSec保护</li><li>若被IPSec保护，则查找IPSec SA，若不被IPSec 保护，则交给上层</li><li>若找到IPSec SA，则解封装，若未找到则丢弃</li></ol><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><ul><li>AH：验证头，提供完整性保护、数据源验证、抗重播服务。不支持机密性保护。IP协议，协议号51。<br>AH头格式：<br>  <code>Next Header</code>：8位，指示AH头后的载荷协议类型<br>  <code>Payload Length</code>：8位，指示AH的长度并减2，单位为32位<br>  <code>SPI</code>：32位任意数值，用于和目的IP地址和安全协议标识结合，唯一标示一个SA<br>  <code>Sequence Number</code>：32位无符号整数，SA建立时为0，随着数据包发送而增大，接收方通过该值确定数据包的序列<br>  <code>Authentication Data</code>：包含该数据包的完整性校验值<code>ICV</code>（使用HMAC算法对IP头+AH头+载荷+共享密钥加密计算），变长且必须是32位的整数倍。AH强制实现<code>HMAC-MD5-96</code>和<code>HMAC-SHA-1-96</code>两种验证算法</li><li>ESP：封装安全载荷，有AH所有功能且支持加密。包含ESP头和ESP尾。IP协议，协议号50。<br>ESP头格式：<br>  <code>Next Header</code>：同上。强制包含。<br>  <code>SPI</code>：同上<br>  <code>Sequence Number</code>：同上<br>  <code>Payload Data</code>：<code>Next Header</code>描述的数据，即载荷数据，长度为字节的整数倍。若加密，ESP强制实现了基础加密算法DES-CBC。强制包含。<br>  <code>Padding</code>：填充，使载荷数据达到指定长度。<br>  <code>Pad Length</code>：填充长度，范围为0到255。强制包含。<br>  <code>Authentication Data</code>：ICV，长度由验证算法决定。可选，验证服务开启时才包含。同样强制实现<code>HMAC-MD5-96</code>和<code>HMAC-SHA-1-96</code><br>ESP尾格式：<code>Padding</code>、<code>Pad Length</code>、<code>Next Header</code></li></ul><p>IPSec有两种工作模式：</p><ul><li>传输模式：保护端到端安全，两个终端间直接运行IPSec，所有加解密、协商都是<strong>端系统</strong>完成，网络设备完全不参与IPSec，只进行正常路由转发。</li><li>隧道模式：保护站点到站点安全，两个<strong>安全网关</strong>间运行IPSec，整个数据包都计算AH或ESP头，AH或ESP头加上数据都被封装在一个新的IP包中。所有加解密、协商都是安全网关完成，终端主机不参与。</li></ul><p>因此AH和ESP对两种工作模式分别有封装的方式：</p><ul><li><p><strong>AH</strong></p><ul><li><p><strong>传输模式</strong><br>原IP包、AH头与密钥通过散列函数（如RSA）生成校验值。<br>将校验值封装在AH头中，再由TCP和原IP头封装。</p><img src="/2018/06/18/常见VPN技术笔记/9.png"></li><li><p><strong>隧道模式</strong><br>新IP头（根据隧道起点终点建立隧道IP头）、AH头与原IP包生成校验值。<br>将校验值封装在AH头中，封装原IP包，再用新IP头封装。</p><img src="/2018/06/18/常见VPN技术笔记/10.png"></li></ul></li><li><p><strong>ESP</strong></p><ul><li><p><strong>传输模式</strong><br>原IP包（不包括原IP头）、ESP尾与密钥加密（通过DES等算法）生成密文。<br>将生成的密文与ESP头和验证密钥通过数字签名算法（通过RSA）生成校验值。<br>最后将用ESP头和原IP头封装密文和校验值。</p><img src="/2018/06/18/常见VPN技术笔记/11.png"></li><li><p><strong>隧道模式</strong><br>将整个原IP包、ESP尾、加密密钥通过加密算法（如DES）生成密文。<br>将密文与ESP头和验证密钥通过散列函数（如RSA）生成校验值。<br>用ESP头和新IP头封装密文和校验值。</p><img src="/2018/06/18/常见VPN技术笔记/12.png"></li></ul></li></ul><h3 id="GRE-OVER-IPSEC"><a href="#GRE-OVER-IPSEC" class="headerlink" title="GRE-OVER-IPSEC"></a>GRE-OVER-IPSEC</h3><p>使用<code>Gre Over IPsec</code>的原因：GRE不保证数据机密性与完整性，不能数据源验证。</p><table><thead><tr><th>特性</th><th>GRE</th><th>IPSec</th></tr></thead><tbody><tr><td>多协议</td><td>支持</td><td>不支持</td></tr><tr><td>虚接口</td><td>支持</td><td>不支持</td></tr><tr><td>组播</td><td>支持</td><td>不支持</td></tr><tr><td>路由协议</td><td>支持</td><td>不支持</td></tr><tr><td>IP协议族</td><td>支持</td><td>支持</td></tr><tr><td>机密性</td><td>不支持</td><td>支持</td></tr><tr><td>完整性</td><td>不支持</td><td>支持</td></tr><tr><td>数据源验证</td><td>不支持</td><td>支持</td></tr></tbody></table><p>封装：原始IP包被封装在GRE隧道包中。GRE隧道包被封装在IPSec包中。</p><img src="/2018/06/18/常见VPN技术笔记/15.png"><h3 id="IPSEC-OVER-GRE"><a href="#IPSEC-OVER-GRE" class="headerlink" title="IPSEC-OVER-GRE"></a>IPSEC-OVER-GRE</h3><h2 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h2><p>Multi Protocol Labal Switching：多协议标签交换<br>MPLS使用定长标签封装网络层分组。标签位于数据链路层和网络层之间，称为2.5层。<br>多协议指：MPLS被多种二层协议封装，也可封装多种三层协议</p><p>两种工作模式：</p><ol><li>帧模式：用于PPP、以太网、帧中继  </li><li>信元模式：作用于ATM</li></ol><p>组成：</p><ol><li>LSR：位于MPLS内部的核心交换机或路由器，提供标签交换和分发  </li><li>LER：位于MPLS网络边缘，提供标签映射、移除和分发</li></ol><p>FEC：转发等价类，转发过程中以等价方式处理的一组数据分组，可根据IP地址、隧道、COS标识创建FEC<br>LSP：标签交换通道，属于同一个FEC的数据流在每个节点赋予一个确定的标签，按照一个确定的标签转发表项进行转发，每个FEC流会有固定的转发路径，该路径就成为该FEC的LSP</p><p>MPLS标签：4个字节。分为四个字段</p><ol><li>Label：标签值，20位，标签转发表的关键索引</li><li>EXP：标识QoS优先级，3位</li><li>S：栈底标识，1位，若为1说明是最后一个标签，若为0说明后面还有MPLS标签。可实现多层MPLS标签嵌套</li><li>TTL：存活时间，8位，每经过一台LSR，TTL就减1<img src="/2018/06/18/常见VPN技术笔记/16.png"></li></ol><p>链路层协议为MPLS分配的标识：</p><ol><li>PPP：0x0281</li><li>以太网或HDLC：0x8847</li><li>帧中继：0x0080</li></ol><p>标签分配协议：用于在LSR间分配标签，建立LSP。有以下四种：</p><ol><li>LDP标签分发协议：最通用</li><li>CR-LDP基于路由受限的标签分发协议：可进行路由约束、QoS，用于流量工程</li><li>RSVP-TE基于流量工程扩展的资源预留协议：用于流量工程中MPLS标签分配</li><li>MP-BGP多协议扩展BGP协议：为BGP路由分配MPLS标签</li></ol><p>LDP消息类型：</p><ol><li>发现<code>Discover</code>消息：LDP邻居的发现维护</li><li>会话<code>Session</code>消息：LDP邻居会话的建立维持与终止</li><li>通告<code>Advertisement</code>消息：向LDP邻居宣告Label、地址等信息</li><li>通知<code>Notification</code>消息：向LDP邻居通知事件或错误</li></ol><blockquote><p>所有LDP消息都采用TLV结构，具有扩展性（TLV：Type-Length-Value 类型-长度-值）</p></blockquote><p>LDP会话建立维护：</p><ol><li>邻居发现：互发<code>Hello</code>消息，组播地址<code>224.0.0.2</code>，UDP端口646</li><li>TCP连接：LSR-ID大的，即IP地址大的一方主动发起，TCP端口646</li><li>会话建立：Master发出初始化Initialization消息，携带协商参数。协商成功Session建立</li><li>会话维持：互发Keepalive消息维持会话。LSR之间发送Label mapping消息，形成标签转发表。期间若收到任何差错消息都会关闭会话，断开TCP连接。</li></ol><p>LDP邻居状态机：<br><strong>两台LDP邻居间建立<code>LDP Session</code>后，状态会维持在<code>Operational</code></strong><br><img src="/2018/06/18/常见VPN技术笔记/17.png"></p><p>标签分配过程：<br>上下游根据数据转发方向而定。<code>LDP Session</code>建立后路由器根据路由表分配标签，生成MPLS标签转发表<br>标签转发表包含：入标签<code>IN</code>，出标签<code>OUT</code>，出接口<code>next-hop</code><br>标签为随机生成，16以下系统保留</p><p>标签分配模式：</p><ol><li>DOD下游按需标记分配：上游LSR向下游LSR发送标签请求信息。下游LSR为此FEC分配标签，通过标签映射消息反馈给上游LSR。原则：下游设备需要收到上游的标签请求才能分配标签</li><li>DU下游自主标记分配：下游LSR在LDP会话建立后主动向上游LSR发布标签映射消息，不需等待上游请求</li></ol><p>标签控制模式：</p><ol><li>有序：只有最下游设备能分发标签，上游设备只有收到了下游的标签映射消息，才能再向上游发送标签映射信息。使得MPLS的转发是端到端的</li><li>独立：不管是不是最下游，不管是否收到下游的标签映射信息，都向上游发送标签映射信息。任何的数据流经过MPLS网络都可进行MPLS转发</li></ol><p>标签保持方式：收到下游的标签映射后，是否记录标签信息的原则</p><ol><li>保守：只保留下一跳邻居的标签，丢弃所有非下一跳邻居发来的标签<br>优点：节约空间<br>缺点：当网络故障时，LSP收敛较慢</li><li>自由：保留来自邻居的所有标签。<br>优点：网络故障后，路由切换时收敛快<br>缺点：消耗空间</li></ol><blockquote><p>常用组合：DU + 有序 + 自由</p></blockquote><p><strong>MPLS转发：</strong><br>第一阶段：标签PUSH：报文进入MPLS网络，LER设备发现报文目的IP地址有关联的标签，对报文进行压标签。该报文就变为了MPLS报文<br>第二阶段：标签SWAP：报文在MPLS网络内进行标签交换。<br>第三阶段：标签POP：报文转出MPLS网络时，在最后一跳弹出标签。倒数第二跳的设备上标签表的出标签为3，说明此为倒数第二跳。一旦包查找到出标签为3，就直接弹出标签。</p><h2 id="BGP-MPLS-VPN"><a href="#BGP-MPLS-VPN" class="headerlink" title="BGP-MPLS-VPN"></a>BGP-MPLS-VPN</h2><p>解决了传统VPN的问题：1.实现隧道动态建立  2.解决本地地址冲突问题  3.VPN私网路由易于控制</p><h3 id="多VPF组网"><a href="#多VPF组网" class="headerlink" title="多VPF组网"></a>多VPF组网</h3><p>多VRF技术用于解决同一台设备（PE）上地址冲突问题。<br>存在以下路由器角色：</p><ul><li>CE：直接与ISP相连的用户设备</li><li>PE：公网边缘路由器，与CE相连，负责VPN接入</li><li>P：公网核心路由器，负责路由与快速转发</li></ul><p>实现：将一台路由器划分为多个VRF，每个VRF相互独立，拥有各自的路由表、端口、协议，每个VRF类似一台虚拟路由器。未划分VRF的路由在公网路由表中。各个VRF与各自的网络运行一个实例，该实例学到的路由只能加入该VPN路由表。实例与所属VPN进行绑定。并且，端口与VPN绑定，与VRF绑定的接口只会出现在该VRF对应的路由表中，当报文从该接口进入路由器后只能查询该VRF对应的路由表。确保了不同VRF数据间不会冲突。<br><img src="/2018/06/18/常见VPN技术笔记/18.png"></p><p>多VRF与路由协议多实例：各VRF与各自用户网络之间运行一个路由实验，该路由实例学习到的路由只能加入该VPN的路由表。各个路由实例与所属VPN绑定，互相独立，只能学到各自的邻居信息。</p><h3 id="MP-BGP"><a href="#MP-BGP" class="headerlink" title="MP-BGP"></a>MP-BGP</h3><p>MP-BGP（Multi　Protocol BGP，多协议BGP）是对BGP根据特性（TCP连接、TLV扩展属性位）进行扩展的协议。<br>MP-BGP相对于BGP的新增特性：</p><ul><li>普通BGP只能传递IPv4信息，MP-BGP能承载多个协议路由信息。</li><li>新增了<code>MP_REACH_NLRI</code>和<code>MP_UNREACH_NLRI</code>两个属性，并新增了扩展团体属性（Extended_Communities）。</li><li>MP-BGP可传递BGP MPLS VPN、L2VPN、6PE等路由信息。</li></ul><blockquote><p><code>MP_REACH_NLRI</code>和<code>MP_UNREACH_NLRI</code>两个属性都是路由更新消息属性。<br><code>MP_REACH_NLRI</code>代替了原BGP更新消息中的<code>NLRI</code>和<code>Next-hop</code>。增加了地址族的描述Address-Family、私网Label和RD，包含原有的Next-hop。<br>若地址族描述为VPNv4，则NLRI包含两个部分，一个是私网标签（一个MPLS标签），第二部分是VPNv4地址（RD+IPv4地址）<br><code>MP_UNREACH_NLRI</code>代替了原BGP更新消息中的<code>Withdrawn Routes</code>。可撤销通过<code>MP_REACH_NLRI</code>发布的各种地址族的路由。包含<code>Address-Family</code>和<code>Withdrawn Routes</code>。</p></blockquote><p><strong>VPNv4地址族主要用于PE路由器间传递VPN路由，并只存在于MP-BGP路由信息和PE设备的私网路由表中，即只出现在路由的发布学习过程中，在穿越ISP公网时，数据包头是没有VPNv4地址的。</strong></p><p><center>下图为MP_REACH_NLRI属性</center><br><img src="/2018/06/18/常见VPN技术笔记/20.png"></p><p><center>下图为MP_UNREACH_NLRI属性</center><br><img src="/2018/06/18/常见VPN技术笔记/21.png"></p><p>BGP的扩展团体属性：RT（Route Target）路由目标。本质是每个VPN实例表达自己的路由取舍方式。<br>RT的格式有三种，都表示RT。<br><img src="/2018/06/18/常见VPN技术笔记/22.png"></p><ul><li><code>0x0002</code>：2字节的AS号，加上4字节的用户自定义数字，如<code>100:1</code>、<code>200:1</code></li><li><code>0x0102</code>：4字节的IP地址，加上2字节的用户自定义数字，如<code>192.168.1.1:1</code>、<code>10.1.1.1:2</code></li><li><code>0x0202</code>：4字节的AS号，加上2字节的用户自定义数字</li></ul><blockquote><p>　通常设置为冒号后的数字设置为VPN实例编号。</p></blockquote><p>RT由两个部分组成：<code>Export Target</code>和<code>Import Target</code>。MP-BGP在PE间交互私网路由时，需要遵循以下规则：</p><ul><li>在PE设备上，发送某一个VPN用户的私网路由给BGP邻居时，需要在扩展团体属性区域中增加该VPN的<code>Export Target</code>属性。</li><li>在PE设备上，需要将收到的MP-BGP路由的扩展团体属性中携带的RT值与本地每个VPN的<code>Import Target</code>对比，若存在交集，则可以将该路由添加进实例的路由表。</li></ul><p>通过对RT的操作可实现两种模式：<code>Hub-Spoke</code>和<code>Extranet</code>。<br><code>Hub-Spoke</code>模式：用户总部可与每个分布互通，但每个VPN分布之间禁止互通。<br><code>Extranet</code>模式：使指定的节点可以与其他节点互通。<br><img src="/2018/06/18/常见VPN技术笔记/23.png"></p><p>RD（Route Distinguisher）路由区分。本质就是用于私网路由的撤销，因为在撤销路由时是不能携带属性值的（包括RT），PE在删除路由时无法判断撤销哪个VPN的路由。长度6字节。<br>RD有两种格式：</p><ul><li>2字节的AS号，加上4字节用户自定义数，如<code>100:1</code></li><li>4字节的IP地址，加上2字节用户自定义数，如<code>192.168.1.1:1</code></li></ul><p>只要保证存在相同地址的两个VPN实例的RD不同即可，但最好为每个VPN实例配置一个RD。若两个VPN实例中存在相同IP地址，则这两个实例一定不能互访，间接互访也不行。</p><p>私网标签Label，用于帮助PE判断该报文前往的VPN，是通过MPLS的多标签嵌套实现的。</p><p>BGP MPLS VPN实现分为以下步骤：</p><ul><li>公网隧道建立：公网IGP协议开启，PE间互通。</li><li>本地VPN建立：PE上设置本地VPN并设置RD、RT属性，然后将VPN与接口绑定，即配置VRF。</li><li>私网路由的学习：PE与CE间运行路由协议多实例，各VPN实例进行路由学习。PE间建立MP-BGP邻居，下游LSR分配标签，建立标签转发表。并会生成一条MP-BGP更新消息，包含VPNv4路由前缀（即IP地址）、下一跳地址、RT属性、私网标签。PE设备会对比RT值，若通过就会记录该路由信息并发布给本地VPN。</li><li>私网数据转发：数据会根据标签转发表进行转发。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FTP笔记</title>
      <link href="/2018/06/06/FTP%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/06/FTP%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇笔记包含以下内容</p><ul><li><a href="#FTP原理">FTP原理</a></li><li><a href="#VSFTP搭建">VSFTP搭建</a><ul><li><a href="#服务器端">服务器端</a></li><li><a href="#常用客户端软件">常用客户端软件</a></li></ul></li><li><a href="#TFTP原理">TFTP原理</a><ul><li><a href="#服务器端">服务器端</a></li><li><a href="#客户端">客户端</a><a id="more"></a></li></ul></li></ul><h2 id="FTP原理"><a href="#FTP原理" class="headerlink" title="FTP原理"></a>FTP原理</h2><p>File Transfer Protocol文件传输协议，基于TCP协议，采用C/S模式，控制连接端口21，数据连接端口20。</p><ul><li>控制连接：负责FTP客户端与服务器交互命令与信息的传输，在整个会话过程中始终打开。</li><li>数据连接：负责客户端与服务器数据的传输，传输完毕就会关闭</li></ul><p><strong>文件类型：</strong>一共有４种，但目前主流仅支持以下两种。</p><ol><li>ASCII：默认模式，发送方将文件转为ASCII码传输，适合文本文件传输</li><li>二进制：也称图像文件传输模式，按比特流传输，适合程序文件传输</li></ol><p><strong>格式控制</strong>：有三种选项，但目前主流配置只允许<strong>非打印</strong>。非打印：表示文件中不含有垂直格式信息。</p><p><strong>数据结构</strong>：有四种选项，但主流配置只允许<strong>文件结构</strong>。文件结构认为数据是一个连续的字节流。</p><p><strong>传输模式</strong>：有四种选项，但主流仅允许<strong>流方式</strong>，文件以字节流形式传输。对于文件节后，发送方在文件结束处提示关闭数据连接。</p><p><strong>数据传输方式：</strong></p><ul><li>主动PORT</li></ul><ol><li>首先客户端（随机端口）与服务器（21端口）TCP三次握手建立连接，建立控制连接通道</li><li>客户端向服务器发送PORT命令，告知服务器使用主动模式。<br>其中PORT命令携带参数（客户端IP地址, P1, P2），P1与P2用于标识客户端数据连接的临时端口号，具体为256*P1+P2，IP地址也是四段，每段用逗号分隔</li><li>服务器收到PORT命令后按照参数用20端口与客户端指定端口三次握手建立数据传输通道。</li><li>数据传输完毕，发送方发送FIN报文，关闭数据连接</li></ol><blockquote><p>注：若客户端在防火墙内部网络，主动方式会出现问题，因为客户端提供的端口是随机的，防火墙若未放行该端口，则无法建立FTP连接。此时需要使用<strong>被动方式</strong>建立连接</p></blockquote><img src="/2018/06/06/FTP笔记/post.png"><ul><li>被动PASV</li></ul><ol><li>首先客户端（随机端口）与服务器（21端口）TCP三次握手建立连接，建立控制连接通道</li><li>客户端向服务器发送PASV命令，参数与PORT一致。但IP是服务器的，标识的是服务器端的临时端口号。</li><li>客户端用随机端口与服务器的指定临时端口TCP三次握手建立数据连接通道。</li><li>数据传输完毕，发送方发送FIN报文，关闭数据连接</li></ol><img src="/2018/06/06/FTP笔记/pasv.png"><p><strong>FTP应答格式：</strong><br>服务器端处理完命令后，会将状态信息，如命令是否执行成功、出错类型、是否就绪等，通过控制连接发送给客户端，即应答。应答的目的就是对数据传输过程进行同步，也为了让客户端了解服务器目前的状态。</p><p>FTP应答由3个ASCII码数字组成，并跟随解释性文本符号。数字面向机器，文本面向用户。</p><ul><li><p>第一位：</p><ul><li>1：确定预备应答：仅仅是在发送另一个命令前期待另一个应答时启动</li><li>2：确定完成应答：要求的操作已完成，可接受新命令</li><li>3：确定中间应答：该命令已被接受，另一个命令必须被发送</li><li>4：暂时拒绝完成应答：请求的命令没有执行，但差错状态是暂时的，命令以后可以再发。</li><li>5：永久拒绝完成应答：该命令不被接受，并要求不要再重试。</li></ul></li><li><p>第二位：</p><ul><li><p>0：语法错误</p></li><li><p>1：一般性的解释信息</p></li><li>2：与控制和数据连接有关</li><li>3：与认证和账户登录过程有关</li><li>5：与文件系统有关</li></ul></li><li><p>第三位：未明确规定，指示对第二位的进一步细化。</p></li></ul><p><strong>常见FTP应答：</strong></p><ul><li>110：重新启动标记应答</li><li>120：服务在多久时间内准备</li><li>125：数据连接打开，传输开始</li><li>150：文件状态正常，打开数据连接端口</li><li>200：命令执行成功</li><li>202：命令执行失败</li><li>211：系统状态或是系统求助响应</li><li>212：目录的状态</li><li>213：文件的状态</li><li>214：帮助信息</li><li>215：名称系统类型</li><li>220：新的联机服务准备</li><li>221：服务控制连接关闭，可注销</li><li>225：数据连接开启，但无传输动作</li><li>226：关闭数据连接端口，请求的文件操作成功</li><li>227：进入passive modes</li><li>250：请求的文件操作完成</li><li>331：用户名已接受，需要输入密码</li><li>332：登录时需账号信息</li><li>350：请求的命令需要进一步的命令</li><li>421：无法提供服务，关闭控制连接</li><li>425：无法开启数据连接</li><li>426：关闭联机，终止传输</li><li>450：请求的操作未执行</li><li>451：命令终止，有本地错误</li><li>452：未执行命令，磁盘空间不足</li><li>500：格式错误，无法识别命令</li><li>501：参数语法错误</li><li>502：命令执行失败</li><li>503：命令顺序错误</li><li>504：命令所接的参数不正确</li><li>530：未登录</li><li>532：存储文件需要账户登录</li><li>550：未执行请求的操作</li><li>551：请求的命令终止，类型未知</li><li>552：请求的文件终止，储存位溢出</li><li>553：未执行请求的命令，名称不正确</li></ul><h2 id="VSFTP搭建"><a href="#VSFTP搭建" class="headerlink" title="VSFTP搭建"></a>VSFTP搭建</h2><p>Very Secure FTP安全文件传输软件。针对系统的程序权限设计，有以下特点：</p><ul><li>将PID的权限降低</li><li>使用chroot机制</li><li>服务的启动者就是一个一般用户</li><li>任何需要执行具有较高执行权限的VSFTP指令都由特殊的上层程序控制</li></ul><p>VSFTPD有两种启动方式：</p><ul><li>stand alone：CentOS默认使用该方式启动VSFTPD，适合主要用于提供大量下载的任务，服务速度快。使用systemd管理就是stand alone</li><li>super daemon：适合内部人员小范围使用。使用xinetd管理就是super daemon</li></ul><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>安装vsftpd服务<br><code>yum install vsftpd</code><br><code>systemctl enable vsftpd</code><br><code>systemctl start vsftpd</code></p><p>安装完在<code>/etc/vsftpd</code>中有四个默认文件：</p><ul><li><code>ftpusers</code>：指定哪些用户不能访问FTP服务器，即黑名单</li><li><code>user_list</code>：实行访问控制的用户列表</li><li><code>vsftpd.conf</code>：VSFTP主配置文件</li><li><code>vsftpd_conf_migrate.sh</code>：VSFTPD操作的一些变量和设置的脚本</li></ul><h4 id="配置文件-etc-vsftpd-vsftpd-conf简单解析"><a href="#配置文件-etc-vsftpd-vsftpd-conf简单解析" class="headerlink" title="配置文件/etc/vsftpd/vsftpd.conf简单解析"></a>配置文件<code>/etc/vsftpd/vsftpd.conf</code>简单解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">listen = YES            # IPv4监听，默认是以StandAlone方式启动</span><br><span class="line">listen_ipv6 = NO        # IPv6监听</span><br><span class="line">                        # ipv6监听若v4为yes则v6必须为no,同理v6为yes则v4为no</span><br><span class="line">listen_address =        # 监听的IP地址</span><br><span class="line">listen_port = 21        # 监听的端口</span><br><span class="line">port_enable = YES       # 开启端口监听</span><br><span class="line">ftp_data_port = 20      # 数据传输端口20</span><br><span class="line">connect_from_port_20=YES  # 数据连接的端口号</span><br><span class="line">pasv_enable = YES       # 是否启用被动连接</span><br><span class="line">pasv_max_port =         # 被动连接的最大端口号</span><br><span class="line">pasv_min_port =         # 被动连接的最小端口号</span><br><span class="line"></span><br><span class="line">connect_timeout = 60    # 主动连接若60秒tcp无法建立就不建立了</span><br><span class="line">accept_timeout = 60     # 被动连接若60秒tcp无法建立就不建立了</span><br><span class="line">max_clients = 2000      # 最多允许2000用户同时登录（0为不限制）</span><br><span class="line">max_login_fails = 3     # 最多允许3次登录失败</span><br><span class="line">max_per_ip = 20         # 同一地址最多允许多少连接（0为不限制）</span><br><span class="line">data_connection_timeout = 300   # 数据连接超时时间（数据无响应）就断开</span><br><span class="line">idle_session_timeout = 300      # 用户登录上后无操作时间300s则断开</span><br><span class="line"></span><br><span class="line">user_config_dir = /etc/vsftpd/conf  # </span><br><span class="line">dirmessage_enable=YES   # 是否启用目录提示信息，默认YES。</span><br><span class="line">                        # 当用户进入某个目录时，会先检查该目录是否存在message_file参数指定的文件</span><br><span class="line">                        # 若有就显示文件中的内容，通常用于放置欢迎语或目录说明</span><br><span class="line">message_file =          # 设置文件路径，该文件用于存放目录的说明或欢迎语（当dirmessage_enable为YES时生效）</span><br><span class="line"></span><br><span class="line">xferlog_enable=YES      # 是否启用详细记录上传下载的日志功能，日志文件路径由xferlog_file指定</span><br><span class="line">xferlog_file = /var/log/xferlog    # 设置文件路径，该文件用于存放目录的说明或欢迎语（当xferlog_enable为YES时生效）</span><br><span class="line">pam_service_name=vsftpd   # PAM认证服务配置文件名，放在/etc/pam.d/目录中</span><br><span class="line">tcp_wrappers=YES          # 开启TCP_wrappers防火墙，用于在一定程度上限制某种服务的访问权限</span><br><span class="line">ftpd_banner =             # 登录FTP服务器时的欢迎语，默认为空</span><br><span class="line"></span><br><span class="line">download_enable = YES     # 是否允许下载</span><br><span class="line">userlist_enable = YES     # 是否启用用户名单（对名单中的用户进行访问控制）</span><br><span class="line">chroot_list_enable = YES  # 是否启用锁定用户在自己的主目录中的功能。</span><br><span class="line">                          # 被锁定的用户登录FTP服务器后只能进入自己的主目录，不能进入其他目录，默认为NO，应该禁用。</span><br><span class="line">                          # 锁定的用户名单文件由chroot_list_file参数指定</span><br><span class="line">chroot_local_user = YES   # 是否将用户限制在自己的根目录中</span><br><span class="line">chroot_list_file = /etc/vsftpd/chroot_list  # 实行或不实行chroot的用户名单，默认就是该文件。文件中是一个用户一行记录</span><br><span class="line">                          # 若chroot_list_enable为enable，则该文件中的用户会chroot</span><br><span class="line">                          # 若chroot_local_user为enable（chroot_list_enable为enbale仍为前提），则该文件中的用户不会chroot</span><br><span class="line">write_enable = YES        # 是否允许修改，默认NO</span><br><span class="line">userlist_enable=YES       # 当用户登录FTP服务器时，在输入完账户名后，服务器会根据userlist_file中指定的用户列表进行控制</span><br><span class="line">                          # 若在该文件中，则禁止该用户输入密码。默认NO</span><br><span class="line">userlist_file = /etc/vsftpd/user_list    # 禁止访问的，默认该文件</span><br><span class="line">uesrlist_deny = NO        # 是否不允许该文件中的用户登录ftp，需要userlist_enable=YES</span><br><span class="line">                          # NO表示只允许该文件中的用户访问，YES表示禁止文件中的用户登录FTP</span><br><span class="line">use_localtime = YES       # VSFTPD默认使用GMT（格林威治）时间，为防止文档时间错误，需要改为YES，即使用本地时间</span><br><span class="line">banner_file = /etc/vsftpd/welcome.txt    # 当用户登录时会显示的文字，文件必须存在</span><br></pre></td></tr></table></figure><h4 id="认证访问控制"><a href="#认证访问控制" class="headerlink" title="认证访问控制"></a>认证访问控制</h4><p>VSFTPD提供三种认证方式：</p><ul><li>匿名访问anoymous：无需认证即可登入</li><li>本地用户local：使用ftp服务器中的用户登录</li><li>虚拟用户：创建独立ftp账户。是最安全的</li></ul><p><strong>匿名访问</strong><br>无需提供真正用户名和密码就能登录FTP服务器。最好不要开启匿名登录，若要开启就进行限制行为。</p><ul><li>只允许匿名用户使用少量基本的操作命令</li><li>限制文件下载数量，不要允许上传</li><li>限制匿名登录的最大同时联机数</li></ul><p>配置文件相关参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable = YES    # 是否允许匿名用户登录，默认YES</span><br><span class="line">                          # 因为是匿名模式，所以要开启。否则尽量不要匿名访问</span><br><span class="line">anon_umask = 077          # 匿名用户创建文件的umask值，默认077，此时匿名传递的文档权限为600</span><br><span class="line">anon_root = /var/ftp/anon # 匿名用户的ftp根目录</span><br><span class="line">anon_upload_enable = NO   # 允许匿名用户上传文件（这项生效的条件为write_enable为YES且ftp匿名用户对该目录有写权限），默认NO</span><br><span class="line">anon_mkdir_writable_enable = NO    # 是否允许匿名用户创建目录（需要该目录的父目录的写权限），默认为NO</span><br><span class="line">anon_other_writable_enable = NO    # 是否开放匿名用户其他写入权限，最好关闭</span><br><span class="line">anon_world_readable = YES          # 仅允许匿名用户下载可读文档</span><br><span class="line">anon_max_rate = 0         # 匿名用户最大传输速率，0为不限制，单位字节/秒</span><br><span class="line"># 传输速率的控制大概有20%的上下浮动，即范围为速度*80%到120%</span><br><span class="line">no_anon_password = NO     # 匿名用户登录是否需要密码（NO为需要，YES为不需要，默认为NO）</span><br><span class="line">                          # 若为需要，登录时输入任意字符串即可</span><br></pre></td></tr></table></figure></p><p>在客户端上匿名登录ftp服务器：只要在输用户名时输入anonymous，并任意输入字符串作为密码</p><p><strong>本地用户</strong><br>使用ftp服务器本地的用户进行登录，会更加安全，也是最常用的方式。</p><p>配置文件相关参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_enable = YES        # 允许本地用户登录ftp，默认YES，在实际工作环境中，应该将这项设为NO</span><br><span class="line">local_umask = 022         # 本地用户上传文件的umask，默认为077</span><br><span class="line">local_root = /var/ftp     # 本地用户的根目录</span><br><span class="line">local_max_rate = 0        # 本地用户最大传输速率，0为不限制，单位字节/秒</span><br></pre></td></tr></table></figure></p><p><strong>虚拟用户</strong></p><p>本地用户登录时会自动转为虚拟用户，即使有大量用户登录，但最终也仅仅转为一个虚拟用户，避免了创建大量的系统用户。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guest_enable = YES        # 是否开启虚拟账户</span><br><span class="line">guest_username = ftp      # 虚拟账户映射的用户名</span><br></pre></td></tr></table></figure><h4 id="使用本地用户认证"><a href="#使用本地用户认证" class="headerlink" title="使用本地用户认证"></a>使用本地用户认证</h4><p>创建FTP用户限制该用户仅能登录FTP服务器<code>useradd ftpuser -s /sbin/nologin</code>并设置密码。<br>为该用户创建一个主目录，即用户登录FTP后的根目录。<br><code>mkdir -p /data/ftp/ftpuser/pub</code>。<br>其中<code>/data/ftp/ftpuser</code>为用户<code>ftpuser</code>的主目录，该目录不得上传文件，该目录下的<code>pub</code>目录供ftpuser用户上传文件。<br><code>usermod -d /data/ftp/ftpuser ftpuser</code><br><code>chmod a-w /data/ftp/ftpuser</code><br><code>chmod a+w -R /data/ftp/ftpuser/pub</code></p><p>配置文件中几条修改项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_enable = YES</span><br><span class="line">local_root = /data/ftp</span><br></pre></td></tr></table></figure></p><h4 id="使用虚拟账户"><a href="#使用虚拟账户" class="headerlink" title="使用虚拟账户"></a>使用虚拟账户</h4><p>首先创建虚拟用户文件<code>/etc/vsftpd/visualusers</code>，文件中列出虚拟用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ftp_visual_1</span><br><span class="line">123456</span><br><span class="line">ftp_visual_2</span><br><span class="line">234567</span><br></pre></td></tr></table></figure><p>生成虚拟用户数据库（可选）。需要工具<code>libdb4-utils</code>（Berkeley DB工具，CentOS中是该软件包）</p><p><code>db_load -T -t hash -f /etc/vsftpd/visualusers /etc/vsftpd/visualusers.db</code> ，然后修改该备份文件的访问权限<code>chmod 600 /etc/vsftpd/{visualusers,visualusers.db}</code></p><p>创建PAM文件，设置账户验证。</p><p>PAM配置文件位于<code>/etc/pam.d/vsftpd</code>，该文件的名称取决于vsftpd主配置文件的<code>pam_service_name</code>字段。将默认配置注释，然后添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/visualusers.db</span><br><span class="line">account required /lib64/security/pam_userdb.so db=/etc/vsftpd/visualusers.db</span><br></pre></td></tr></table></figure><p>所有的虚拟用户都需要映射到一个真实的系统用户，因此需要添加一个系统账户并设置家目录。</p><p><code>useradd -s /sbin/nologin -d /home/virtual virtual</code></p><p>查看修改主配置文件（有的不用改）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local_enable = YES</span><br><span class="line">chroot_local_user = YES</span><br><span class="line">pam_service_name = vsftpd</span><br><span class="line">user_config_dir = /etc/vsftpd/visual_config     # 设置虚拟用户配置文件主目录</span><br></pre></td></tr></table></figure><p>创建虚拟用户配置文件的存放目录<code>/etc/vsftpd/visual_config</code>，这样可以为每个账户做单独的权限设置</p><p>创建用户<code>visual</code>的独立配置（举例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/vsftpd/visual_config/visual</span><br><span class="line">guest_enable = YES</span><br><span class="line">guest_username = ftp_visual_1</span><br><span class="line">anon_max_rate = 100000</span><br></pre></td></tr></table></figure><h3 id="常用客户端软件"><a href="#常用客户端软件" class="headerlink" title="常用客户端软件"></a>常用客户端软件</h3><h2 id="TFTP原理"><a href="#TFTP原理" class="headerlink" title="TFTP原理"></a>TFTP原理</h2><p>Trivial File Transfer Protocol简单文件传输协议，基于UDP协议，端口号69<br><strong>特点：</strong></p><ul><li>仅提供简单文件传输功能（上传，下载）</li><li>无存取授权与认证机制，无目录功能</li><li>由客户端发起</li></ul><p><strong>下载过程：</strong></p><ol><li>客户端向服务器发送读请求  </li><li>服务器根据请求回应数据报文（块编号从1开始）  </li><li>客户端收到数据后回应确认报文。重复2.3步直至完成下载</li></ol><p><strong>上传过程：</strong></p><ol><li>客户端向服务器发送写请求  </li><li>服务器回应确认报文（块编号为0）  </li><li>客户端发送数据报文（块编号从1开始）  </li><li>服务器收到后回应确认报文。重复3，4步直至上传完成</li></ol><blockquote><p>文件传输时，将文件分成多个文件块，封装到数据报文中并打上文件块编号</p></blockquote><p><strong>传输文件模式：</strong></p><ul><li>netASCII：对应FTP的ASCII模式   </li><li>octet：对应FTP二进制模式</li></ul><p><strong>协议报文：</strong></p><ul><li>RRQ读请求报文  </li><li>WRQ写请求报文  </li><li>数据报文  </li><li>确认正确/错误报文</li></ul><p>报文的头两个字节是操作码字段，1为读请求，2为写请求，3为数据报文，4为确认正确，5为错误。<br>文件传输过程中读写出错就发送差错报文，数据传输就停止，差错报文不会被确认也不会重传。<br>TFTP每次传输的数据报文中文件块大小固定为512字节，若文件大小刚好是512字节的整数倍，则传完文件后还要再发一个空文件块的数据报文表明文件传输完成。</p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Iptables、Selinux与防火墙笔记</title>
      <link href="/2018/06/06/Iptables%E3%80%81Selinux%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/06/Iptables%E3%80%81Selinux%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本片包含以下内容：</p><ul><li><a href="#Iptables">Iptables</a><ul><li><a href="#Netfilter/Iptables框架">Netfilter/Iptables框架</a></li><li><a href="#iptables规则">iptables规则</a></li><li><a href="#iptables应用">iptables应用</a></li></ul></li><li><a href="#Selinux">Selinux</a><ul><li><a href="#Selinux介绍">Selinux介绍</a></li><li><a href="#安全上下文">安全上下文</a></li><li><a href="#Selinux管理">Selinux管理</a></li></ul></li><li><a href="#firewalld">firewalld</a><ul><li><a href="#防火墙部署结构">防火墙部署结构</a></li><li><a href="#firewalld服务">firewalld服务</a></li></ul></li></ul><a id="more"></a><h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><h2 id="Netfilter-Iptables框架"><a href="#Netfilter-Iptables框架" class="headerlink" title="Netfilter/Iptables框架"></a>Netfilter/Iptables框架</h2><p>Netfilter是Linux 2.4.x引入的一个子系统，它作为一个通用的、抽象的框架，为每种网络协议都提供一整套的hook函数的管理机制，使得诸如数据包过滤、网络地址转换(NAT)和基于协议类型的连接跟踪成为了可能。Netfilter的架构就是在整个网络流程的若干位置放置了一些检测点（HOOK），而在每个检测点上登记了一些处理函数进行处理。</p><p>Netfilter采用的关键技术：</p><ul><li>连线跟踪（Connection Tracking）：是<strong>包过滤、地址转换的基础</strong>，它作为一个独立的模块运行。在<strong>协议栈低层截取数据包</strong>，将当前数据包及其状态信息<strong>与历史数据包及其状态信息进行比较</strong>，从而得到当前数据包的<strong>控制信息</strong>，根据这些信息决定对网络数据包的操作，达到保护网络的目的。</li><li>包过滤（Packet Filtering）：检查通过的每个数据包的头部，然后根据规则处理</li><li>地址转换（NAT）：网络地址转换分为源NAT（SNAT）、目的NAT（DNAT）和端口转换（PNAT）。SNAT修改数据包的源IP，DNAT修改数据包的目的IP。SNAT在数据包送出之前的最后一刻做好转换工作，DNAT在数据包进入后立刻完成转换。</li><li>包处理（Packet Mangling）：可以设置或改变数据包的服务类型（TOS），改变包的生存期（TTL），在包中设置标志值，利用该标志值可以进行带宽限制和分类查询。</li></ul><blockquote><p> 资料摘自<a href="https://baike.baidu.com/item/netfilter/8916221?fr=aladdin#2_1" target="_blank" rel="noopener">百度百科-netfilter</a></p></blockquote><p>Netfilter为IPv4定义了5个hook函数，这些hook函数会在数据报流过协议栈的5个关键点被调用。</p><ul><li><code>NF_IP_PRE_ROUTING</code>：刚刚进入网络层的数据包通过此点（已完成版本号，校验和等检测）， 目的地址转换在此点进行</li><li><code>NF_IP_LOCAL_IN</code>：经路由查找后，送往本机的数据包通过此检查点，INPUT包过滤在此点进行</li><li><code>NF_IP_FORWARD</code>：要转发的包通过此检测点，FORWARD包过滤在此点进行</li><li><code>NF_IP_POST_ROUTING</code>：所有马上要通过网络设备出去的包通过此检测点，内置的源地址转换SNAT功能（包括地址伪装）在此点进行</li><li><code>NF_IP_LOCAL_OUT</code>：本机进程发出的包通过此检测点，OUTPUT包过滤在此点进行</li></ul><p>Netfilter所有的过滤规则都以模块存放在<code>/usr/lib/modules/$(uname -r)/kernel/net/netfilter/</code>目录中。在Linux内核版本2.6前，netfilter分为<code>IPv4</code>版和<code>IPv6</code>版，分别存放在<code>/usr/lib/modules/$(uname -r)/kernel/net/ipv4</code>和<code>/usr/lib/modules/$(uname -r)/kernel/net/ipv6</code>中，Linux2.6后进行了整合，使得Netfilter更加简单高效。</p><h2 id="iptables规则"><a href="#iptables规则" class="headerlink" title="iptables规则"></a>iptables规则</h2><p>iptables是一个工具，位于用户空间，用于插入，修改，删除数据包过滤表的规则。</p><p>iptables分为三部分：</p><ol><li><p>表：分为四张表</p><ol><li><p>raw表：是否对该数据包进行状态跟踪</p></li><li><p>mangle表：为数据包设置标记，修改数据包（TOS，TTL，MARK）</p></li><li><p>nat表：修改数据包中源、目的IP地址或端口</p></li><li><p>filter表：过滤数据包（对数据包）</p><p>顺序：<strong>raw -&gt; mangle -&gt; nat -&gt; filter</strong></p></li></ol></li><li><p>链：分为五条链</p><ol><li><p>在路由选择前处理数据包（PREROUTING）</p></li><li><p>处理流入的数据包（这条规则起到保证内网不被侵犯的关键作用）（INPUT）</p></li><li><p>处理流出的数据包（OUTPUT）</p></li><li><p>处理转发的数据包（FORWARD）</p></li><li><p>在路由选择后处理数据包（POSTROUTING）</p><p>链顺序：</p><ul><li>入站：<strong>prerouting -&gt; input</strong></li><li>出站：<strong>output -&gt; postrouting</strong></li><li>转发：<strong>prerouting -&gt; forward -&gt; postrouting</strong></li></ul></li></ol></li><li><p>规则：规则被分组在链中，<strong>规则被添加到相应的链中，链被添加在表中</strong>。规则表默认是允许，则规则链就是被禁止的规则。若规则表是禁止的，则规则链就是被允许的规则</p></li></ol><p><strong>完整包过滤流程：</strong></p><ol><li>包到达网络接口  </li><li>进入raw表的prerouting链（在连接跟踪前处理数据包）  </li><li>连接跟踪（若要做）  </li><li>进入mangle表的prerouting链，修改数据包   </li><li>进入nat表的prerouting链，做DNAT（目标地址转换，改变数据包目的地址使包能到达内网某服务器），但不做过滤 </li><li>路由判断<ul><li>若是要<strong>转发</strong>：进入<strong>mangle表forward链</strong>，然后进入<strong>filter表的forward链过滤</strong>，进入<strong>mangle表的postrouting链</strong>，进入<strong>nat表的postrouting链</strong>，做<strong>SNAT，但不过滤</strong>，然后数据包离开本机。</li><li>若是<strong>发给本地</strong>的：进入<strong>mangle表的input链</strong>，进入<strong>filter表的input链</strong>，对数据<strong>包过滤</strong>，然后交给本地程序，处理完后<strong>先判断路由</strong>，进入<strong>raw表的output链</strong>，<strong>连接跟踪</strong>对包的处理，进入<strong>mangle表的output链</strong>，可<strong>修改数据包但不过滤</strong>，进入<strong>nat表的output链，做NAT</strong>，然后路由，进入<strong>filter表的output链</strong>，可<strong>过滤包</strong>，进入<strong>mangle表的postrouiting链</strong>，进入<strong>nat表的postrouting链</strong>，做<strong>SNAT但不过滤</strong>，包离开本机。</li></ul></li></ol><img src="/2018/06/06/Iptables、Selinux与防火墙笔记/0.png"><h2 id="iptables应用"><a href="#iptables应用" class="headerlink" title="iptables应用"></a>iptables应用</h2><p>iptables有八种匹配后的触发动作：</p><ol><li>ACCEPT：允许通过</li><li>DROP：丢弃</li><li>REJECT：拒绝</li><li>LOG：记录日志（syslog）</li><li>DNAT：目的地址转换</li><li>SNAT：源地址转换</li><li>MASQUERADE：地址欺骗</li><li>REDIRECT：重定向</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型（上面八种）]</span><br><span class="line">  -P INPUT (DROP|ACCEPT) 设置默认策略</span><br><span class="line">  -L  查看规则链</span><br><span class="line">  -F  清空规则链</span><br><span class="line">  -A  在链末尾加新规则</span><br><span class="line">  -I num  在链头部加新规则</span><br><span class="line">  -D num  删除指定规则</span><br><span class="line">  -R  替换指定链中的一条匹配规则</span><br><span class="line">  -N  创建一个新链</span><br><span class="line">  -X  删除指定用户的定义链，若未指定就删除所有用户链</span><br><span class="line">  -C  检查数据包是否与指定链规则匹配</span><br><span class="line">  -Z  将指定链中的所有规则byte计数器清零</span><br><span class="line">  匹配参数：</span><br><span class="line">  -s 匹配源IP/mask，加！表示除该IP</span><br><span class="line">  -d  匹配目的地址</span><br><span class="line">  -i [网卡] 匹配流入网卡的数据</span><br><span class="line">  -o [网卡] 匹配流出网卡的数据</span><br><span class="line">  -p [协议] 匹配协议</span><br><span class="line">  -n   ip地址会以数字显示</span><br><span class="line">  --dport num    匹配目标端口号</span><br><span class="line">  --sport num    匹配源端口号</span><br></pre></td></tr></table></figure><h1 id="Selinux"><a href="#Selinux" class="headerlink" title="Selinux"></a>Selinux</h1><h1 id="firewalld"><a href="#firewalld" class="headerlink" title="firewalld"></a>firewalld</h1><p>RHEL7中firewalld取代了iptables。firewalld将所有网络流量都分类汇集到zones，然后通过zones管理防火墙规则。</p><p>firewalld匹配规则：</p><ul><li>数据包进入系统，首先检查源IP地址和网卡接口，若与某个zone匹配，则按照该zone的规则过滤。每个zone都有开启或关闭的服务和端口列表，数据包根据列表决定是否放行。如果数据包不与任何定义的zone匹配，则进入默认zone，默认zone的名称为<code>public</code>。firewalld提供以下默认zone：<code>home/drop/work/internal/block/public/trusted/dmz/external</code>，在fedora中，还会默认提供<code>FedoraWorkstation</code>和<code>FedoraServer</code>两个zone。</li><li></li></ul><p>firewall命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd </span><br><span class="line">Status Options</span><br><span class="line">  --state              返回firewalld状态</span><br><span class="line">  --reload             重新加载firewalld，会保留状态信息</span><br><span class="line">  --complete-reload    重载firewalld，不会保留状态信息</span><br><span class="line">  --runtime-to-permanent</span><br><span class="line">                       Create permanent from runtime configuration</span><br><span class="line">  --permanent          设置为永久配置</span><br><span class="line"></span><br><span class="line">  --get-default-zone   显示默认zone</span><br><span class="line">  --set-default-zone=&lt;zone&gt;</span><br><span class="line">                       设置默认zone</span><br><span class="line">  --get-active-zones   显示活跃的zone</span><br><span class="line">  --get-zones          显示所有预设的zone</span><br><span class="line">  --get-services       显示所有预设服务</span><br><span class="line">  --list-all-zones     列出所有zone的信息</span><br><span class="line">  --new-zone=&lt;zone&gt;    创建新的zone</span><br><span class="line">  --delete-zone=&lt;zone&gt; 删除指定zone</span><br><span class="line">  --load-zone-defaults=&lt;zone&gt; 加载zone的默认配置</span><br><span class="line">  --zone=&lt;zone&gt;        指定zone进行设置</span><br><span class="line">  --info-zone=&lt;zone&gt;   显示指定zone的信息</span><br><span class="line">  --list-all           列出活跃的zone的信息</span><br><span class="line">  </span><br><span class="line">  --list-services      列出放行的服务</span><br><span class="line">  --add-service=&lt;service&gt;      添加放行的服务</span><br><span class="line">  --remove-service=&lt;service&gt;   取消放行服务</span><br><span class="line">  --query-service=&lt;service&gt;    返回服务是否放行</span><br><span class="line">  </span><br><span class="line">  --list-ports         列出zone中放行的端口</span><br><span class="line">  --add-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;     放行端口</span><br><span class="line">  --remove-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;  取消放行端口</span><br><span class="line">  --query-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt;  返回端口是否放行</span><br><span class="line">  </span><br><span class="line">  --list-protocols     列出指定区域添加的协议</span><br><span class="line">  --add-protocol=&lt;protocol&gt; 为指定区域添加协议</span><br><span class="line">  --remove-protocol=&lt;protocol&gt; 去除协议</span><br><span class="line">  --query-protocol=&lt;protocol&gt; 查询是否协议被添加到区域</span><br><span class="line">                       </span><br><span class="line">  --list-source-ports  查看区域中定义的源端口</span><br><span class="line">  --add-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt; 添加设置源端口</span><br><span class="line">  --remove-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt; 去除源端口</span><br><span class="line">  --query-source-port=&lt;portid&gt;[-&lt;portid&gt;]/&lt;protocol&gt; 查询源端口是否属于该区域</span><br><span class="line">  </span><br><span class="line">  --list-rich-rules    列出所有rich rules</span><br><span class="line">  --add-rich-rule=&lt;rule&gt; 添加rich rules</span><br><span class="line">  --remove-rich-rule=&lt;rule&gt; 去除rich rules</span><br><span class="line">  --query-rich-rule=&lt;rule&gt; 查询指定rich rules是否属于该域</span><br><span class="line">  </span><br><span class="line">  --list-interfaces    列出区域中的网卡</span><br><span class="line">  --add-interface=&lt;interface&gt; 在区域中添加网卡</span><br><span class="line">  --query-interface=&lt;interface&gt; 查询网卡是否属于一个区域</span><br><span class="line">  --remove-interface=&lt;interface&gt; 从区域移除网卡</span><br><span class="line">                       </span><br><span class="line">  --list-sources       查看区域中定义的源</span><br><span class="line">  --add-source=&lt;source&gt;[/&lt;mask&gt;] 添加源</span><br><span class="line">  --query-source=&lt;source&gt;[/&lt;mask&gt;] 查询区域中是否有指定源</span><br><span class="line">  --remove-source=&lt;source&gt;[/&lt;mask&gt;]  去除区域中指定源</span><br></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li><a href="https://wangchujiang.com/linux-command/c/firewall-cmd.html" target="_blank" rel="noopener">firewall-cmd</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> iptables </tag>
            
            <tag> 安全 </tag>
            
            <tag> Linux </tag>
            
            <tag> Selinux </tag>
            
            <tag> 防火墙 </tag>
            
            <tag> firewalld </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DHCP笔记</title>
      <link href="/2018/06/05/DHCP%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/06/05/DHCP%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容</p><ul><li><a href="#DHCP原理">DHCP原理</a></li><li><a href="#DHCP服务器配置">DHCP服务器配置</a><ul><li><a href="#服务器端">服务器端</a></li><li><a href="#客户端">客户端</a></li></ul></li><li><a href="#DHCP中继">DHCP中继</a><a id="more"></a></li></ul><h2 id="DHCP原理"><a href="#DHCP原理" class="headerlink" title="DHCP原理"></a>DHCP原理</h2><p>DHCP（Dynamic Host Configuration Protocol）用于为客户端动态分配IP地址、子网掩码并设置网关等信息。<br>前身为BOOTP协议，工作在应用层，基于UDP协议，端口号67（服务器端），68（客户端），还有一个546端口用于DHCPv6的客户端。</p><p>DHCP与BOOTP最重要的区别：DHCP支持租期，BOOTP不支持，BOOTP分配的IP地址是永久的。</p><p><strong>DHCP提供三种分配方式：</strong></p><ul><li>手动分配：静态绑定固定IP，这些IP固定给特定设备使用（打印机，DNS，web服务器等）</li><li>自动分配：服务器给客户端分配租期无限长的IP地址，只有客户释放，其他客户才能使用该地址</li><li>动态分配：服务器给客户端分配租期有限长的IP地址，一旦租期到期而未续约，地址就会释放。</li></ul><p>DHCP的基本原则：尽可能为客户端分配<strong>原来使用</strong>的地址。<br>DHCP的分配顺序：1.静态分配的  2.客户端曾经会用过的  3.最先找到的可用IP。</p><p><strong>DHCP报文与请求过程</strong><br><img src="/2018/06/05/DHCP笔记/dhcp-qingqiu.png" title="dhcp-qingqiu"></p><p>DHCP工作过程</p><ul><li>发现阶段：</li><li>提供阶段：</li><li>选择阶段：</li><li>确认阶段：</li><li>重新申请：</li><li>更新租约：</li></ul><p>DHCP报文</p><ul><li>Discover：客户端第一次向服务器发送的请求报文，广播发送</li><li>Offer：服务器对客户端Discover的回应，包含分配的IP、掩码、网关等信息，广播或单播发送</li><li>Request：客户端发送给服务器的请求报文，包括服务器的选择与租期更新等，单播或广播发送（根据客户端状态）</li><li>Release：客户端若想释放当前地址，则单播发送给服务器</li><li>Ack/Nak：服务器对客户端的回应，请求报文正确时回复Ack，否则回复Nak</li><li>Decline：客户端收到服务器的Ack后，对获取的IP进行确认，使用ARP，若发现该IP已被使用，则广播向服务器发送Decline报文，拒绝使用该IP。</li><li>Inform：当客户端通过其他方式已获取了IP，若还需要向服务器索取其他配置信息时，会向服务器发送Inform，若服务器能根据要求分配则会回复Ack，否则不操作。</li></ul><p><strong>DHCP续约</strong></p><ol><li>更新状态：使用时间达到租约的50%，客户端进入更新状态，单播向服务器发送Request，服务器若同意续约则回复Ack，否则回复Nak</li><li>重新绑定状态：使用时间达到租约的87.5%，客户端进入重新绑定状态。客户端广播Request请求，请求对有效租期进行更新。<br>进入该状态的原因：客户端未收到服务器对续约Request的回应。<br>若Request未收到回应，客户端会在一定时间内重发Request报文，若直到租期结束也未更新租期，则被迫释放IP地址。</li></ol><p><strong>DHCP中继</strong><br>DHCP只适用于客户端与服务器在同网段（原因：广播请求），但可以通过中继使客户端可向其他网段的DHCP服务器请求。<br>实现：中继路由器收到请求广播报文，便向服务器单播发送，同理服务器也单播回应中继，中继再广播回应客户端。</p><h2 id="DHCP服务器配置"><a href="#DHCP服务器配置" class="headerlink" title="DHCP服务器配置"></a>DHCP服务器配置</h2><p>实验环境：<br>全部为CentOS-7</p><ul><li>服务器端：system2 192.168.163.102</li><li>客户端：system3 192.168.163.103</li></ul><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ul><li><p>安装DHCP服务<br><code>yum install dhcp dhcp-devel</code></p><blockquote><p><code>dhcp</code>为服务器端基础组件，<code>dhcp-devel</code>为服务器开发工具</p></blockquote><p>  开机自启<br>  <code>systemctl enable dhcpd</code><br>  <code>systemctl start dhcpd</code></p></li><li>修改配置文件/etc/dhcp/dhcpd.conf<br>注：该文件是空的，可以参考模板添加项，模板为<code>/usr/share/doc/dhcp-4.2.5/dhcpd.conf.example</code>，其中dhcp的版本号可能不一致，可用<code>find</code>命令查找</li></ul><p>以下为配置文件常见参数的解析，可通过<code>man 5 dhcpd.conf</code>查看完整配置参数解析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># 服务器名</span><br><span class="line">server-name “system2”; </span><br><span class="line"></span><br><span class="line"># DNS域名</span><br><span class="line">option domain-name &quot;example.org&quot;;</span><br><span class="line"># DNS服务器域名（最多指定三个）</span><br><span class="line">option domain-name-servers ns1.example.org, ns2.example.org;</span><br><span class="line"></span><br><span class="line"># 默认租期，单位秒。在默认租期内，可以进行续约操作</span><br><span class="line">default-lease-time 600;</span><br><span class="line"># 最大租期，单位秒。</span><br><span class="line">max-lease-time 7200;</span><br><span class="line"># 最大租期即客户端IP租约时间的最大值，当客户端超过默认租约时间，虽此时已无法续约，但DHCP会仍然允许用户在最大租约时间内使用该IP，之后就收回该IP</span><br><span class="line"></span><br><span class="line"># dhcp与dns动态信息更新模式（必选）</span><br><span class="line"># 三种选择：interim--dns互动更新  ad-hoc--特殊dns更新  none--不支持</span><br><span class="line"># 全局设置中一定要有这个，否则不能成功启动</span><br><span class="line">#ddns-update-style none;</span><br><span class="line"></span><br><span class="line"># 如果该DHCP服务器是本地网络的授权服务器，则需要取消注解</span><br><span class="line">#authoritative;</span><br><span class="line"></span><br><span class="line"># 忽略客户端更新</span><br><span class="line">ignore client-updates;</span><br><span class="line"></span><br><span class="line"># 设置网关</span><br><span class="line">option routers 192.168.163.254;</span><br><span class="line"></span><br><span class="line"># 日志类型</span><br><span class="line">log-facility local7;</span><br><span class="line"></span><br><span class="line"># 设置ntp服务器</span><br><span class="line">ntp-server [IP地址]</span><br><span class="line"></span><br><span class="line"># 子网设置</span><br><span class="line">subnet 10.5.5.0 netmask 255.255.255.224 &#123;</span><br><span class="line">  # 设置地址池</span><br><span class="line">  range 10.5.5.26 10.5.5.30;</span><br><span class="line">  option domain-name-servers ns1.internal.example.org;</span><br><span class="line">  option domain-name &quot;internal.example.org&quot;;</span><br><span class="line">  option routers 10.5.5.1;</span><br><span class="line">  # 广播地址</span><br><span class="line">  option broadcast-address 10.5.5.31;</span><br><span class="line">  default-lease-time 600;</span><br><span class="line">  max-lease-time 7200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># shared-network用于跨网段分配IP地址，多用于中继，形成超级作用域</span><br><span class="line">shared-network 224-29 &#123;</span><br><span class="line">  # 配置子网1</span><br><span class="line">  subnet 10.17.224.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    option routers rtr-224.example.org;</span><br><span class="line">  &#125;</span><br><span class="line">  # 配置子网2</span><br><span class="line">  subnet 10.0.29.0 netmask 255.255.255.0 &#123;</span><br><span class="line">    option routers rtr-29.example.org;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># host指定客户端客户端的IP地址绑定</span><br><span class="line"># hostname仅仅是标识，无意义</span><br><span class="line">host hostname &#123;</span><br><span class="line">  # 指定目标主机</span><br><span class="line">  hardware ethernet [MAC地址];</span><br><span class="line">  # 绑定IP地址</span><br><span class="line">  fixed-address [ip地址];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong>划分子网时，如果选择直接配置多作用域实现动态IP分配的任务，则必须要为DHCP服务器添加多块网卡，并配置多个IP地址，否则DHCP服务器只能分配与其现有网卡IP地址对应网段的作用域。</p><p>DHCP租约文件<br><code>/var/lib/dhcpd/dhcpd.leases</code><br>租约数据库文件用于保存一系列的租约声明，其中包含客户端的主机名、MAC地址、分配到的IP地址，以及IP地址的有效期等相关信息。<br>这个数据库文件是可编辑的ASCII格式文本文件。每当发生租约变化的时候，都会在文件结尾添加新的租约记录。</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>需要安装先<code>dhclient</code>，然后修改<code>/etc/sysconfig-network-scripts/ifcfg-ens33</code>（根据实际网卡名称），修改<code>BOOTPROTO=dhcp</code>，重启网络。</p><h2 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h2><p>DHCP中继代理（DHCP Relay Agent）用于转发其他网段的客户端DHCP请求。当客户端请求</p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> dhcp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP协议基础笔记</title>
      <link href="/2018/05/31/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/31/HTTP%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容</p><ul><li><a href="#Web概述">Web概述</a></li><li><a href="#HTTP概述">HTTP概述</a></li><li><a href="#HTTP报文">HTTP报文</a><ul><li><a href="#HTTP首部">HTTP首部</a></li><li><a href="#状态码">状态码</a></li><li><a href="#HTTP请求方式">HTTP请求方式</a></li></ul></li><li><a href="#HTTP_Cookie">HTTP_Cookie</a><a id="more"></a></li></ul><h2 id="Web概述"><a href="#Web概述" class="headerlink" title="Web概述"></a>Web概述</h2><p>WWW（World Wide Web）环球信息网，也称万维网，由W3C万维网联盟管理。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。<br>WWW的三种技术：HTML，HTTP，URL</p><p><strong>URI：</strong>统一资源标识符，表示服务器资源名称，给定了URI，HTTP便能解析资源。URI有两种形式：</p><ul><li><strong>URL统一资源定位符</strong>：描述特定服务器上指定资源的位置，是固定的。包含三部分：<ul><li>方案：说明访问资源使用的协议方式，如http://</li><li>服务器因特网地址</li><li>指定服务器上的指定资源<br><strong>几乎所有URI都是URL</strong></li></ul></li><li><strong>URN统一资源名</strong>：特定资源的唯一名称，与资源所在地址无关，资源可以四处搬运。</li></ul><h2 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h2><p>超文本传输​​协议Hyper Text Transfer Protocol（HTTP）是用于传输诸如HTML的超媒体文档的应用层协议，用于Web浏览器和Web服务器之间的通信，基于TCP/IP，采用C/S模式。HTTP是无状态协议，意味着服务器不会在两个请求之间保留任何数据（状态）。</p><p>HTTP的三个常见版本：</p><ul><li>HTTP/1.0：客户端只能从web服务器获取一个web资源</li><li>HTTP/1.1：客户端能在一个连接上获取多个web资源（有数量限制，超出部分请求被阻塞）</li><li>HTTP/2.0：多流并行，一个连接可获取多个web资源</li></ul><p>特点：</p><ul><li>简单快速：HTTP协议简单，报文简单易懂，HTTP服务器程序规模 小，通信速度快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由<code>Content-Type</code>加以标记。</li><li>可扩展：通过HTTP首部，只要服务端和客户端就新首部达成语义一致，新功能就可以被轻松加入进来。</li><li>无状态：在同一个连接中，两个执行成功的请求之间是没有关系的。但是可以通过HTTP的头部扩展和HTTP Cookies解决，把Cookies添加到头部中，让每次请求都能共享相同的上下文信息，来创建有状态的会话。</li></ul><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>HTTP消息头（HEADER，也称首部）<br>1.通用（一般）头：适用于请求和响应消息，但与最终消息主体中传输的数据无关<br>2.请求头：包含有关要获取的资源或客户端本身更多信息<br>3.响应头：包含有关服务器响应的补充信息，如其位置或服务器本身（名称和版本等）<br>4.实体头：包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型</p><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><ul><li>GET：请求访问已被URL识别的资源，不会对信息产生影响，每次GET方法都是相同的，GET放在URL首部，GET提交的数据大小一般限制为1024字节，大小随浏览器而。采用明文传输，速度快。只产生一个TCP数据包。GET能被缓存。</li><li>POST：请求服务器传输信息实体的主体，POST放在报文中，没有具体限制，由于放在报文中所以无法看见，安全，form表单必须使用POST。会产生两个TCP数据包。POST不可被缓存。POST提交数据大小没有限制。</li><li>PUT：传输文件，在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置（出于安全，网站一般不会用）</li><li>HEAD：获取报文首部，用于确认URI的有效性及资源更新的日期时间等</li><li>DELETE：请求URL删除指定的资源，与PUT相反（同样一般不用）</li><li>OPTIONS：查询指定URL资源支持的方法</li><li>TRACE：追踪路径，让服务器将之前的请求通信返还给客户端</li><li>CONNECT：要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。</li></ul><p>GET与POST的区别：</p><table><thead><tr><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>请求访问已被URL识别的资源</td><td>将实体提交到指定资源</td></tr><tr><td>放在URL首部，明文传输，可见</td><td>封装在报文中，不可见</td></tr><tr><td>产生一个TCP包</td><td>产生两个TCP包</td></tr><tr><td>能被缓存</td><td>不可被缓存</td></tr><tr><td>数据传输大小随浏览器而定，一般为1024字节</td><td>没有具体限制</td></tr></tbody></table><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>HTTP请求报文（Request）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET https://developer.mozilla.org/zh-CN/docs/Web/HTTP HTTP/2.0</span><br><span class="line">Host: developer.mozilla.org</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Cookie: dwf_sg_task_completion=False; messages=&quot;67ba01ba64d7aac589a5e34d72bb89050449f64e$[[\&quot;__json_message\&quot;\0541\05430\054\&quot;Redirected from https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms\&quot;\054\&quot;wiki_redirect\&quot;]]&quot;</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p><p><strong>报文解析：</strong><br>第一行为请求行，包含三个部分：</p><ul><li>执行动作：即请求方式。</li><li>请求目标：完整路径，通常是一个URL，或者是协议、端口和域名的绝对路径<ul><li>绝对路径，末尾加上?与查询字符串，称为原始形式</li><li>完整URL，称为绝对形式，通常GET使用</li><li>域名:端口，仅在使用 CONNECT 建立 HTTP 隧道时才使用</li><li>星号形式*，配合 OPTIONS 方法使用，代表整个服务器</li></ul></li><li>HTTP版本</li></ul><p>第二行以后的内容都称为HTTP首部（Headers）。</p><ul><li>Host：请求的服务器主机名<br>User-Agent：用户代理端，即客户端（浏览器），包含详细的浏览器名和</li></ul><p>HTTP响应报文（Response）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/2.0 200 OK</span><br><span class="line">content-type: text/css; charset=&quot;utf-8&quot;</span><br><span class="line">access-control-allow-origin: *</span><br><span class="line">cache-control: max-age=315360000, public, immutable</span><br><span class="line">date: Tue, 05 Jun 2018 16:24:09 GMT</span><br><span class="line">last-modified: Tue, 05 Jun 2018 15:59:27 GMT</span><br><span class="line">server: meinheld/0.6.1</span><br><span class="line">strict-transport-security: max-age=63072000</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">x-xss-protection: 1; mode=block</span><br><span class="line">content-encoding: gzip</span><br><span class="line">vary: Accept-Encoding</span><br><span class="line">age: 336026</span><br><span class="line">x-cache: Hit from cloudfront</span><br><span class="line">via: 1.1 ec1e0045303188984bc160bff8921bbd.cloudfront.net (CloudFront)</span><br><span class="line">x-amz-cf-id: D0Bs8VzYr7qYkVfUiXYivsQqygQPctoPwabrnWC0zSPCwYedUyHAWg==</span><br><span class="line">X-Firefox-Spdy: h2</span><br></pre></td></tr></table></figure></p><p><strong>响应报文解析：</strong><br>第一行为响应行，包含两个部分：</p><ul><li>HTTP版本</li><li>状态码<br>第二行开始为响应首部</li><li>Content-Type：指示服务器文档的MIME类型。帮助用户代理（浏览器）去处理接收到的数据。</li></ul><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p><strong>类别：</strong></p><ul><li>1XX：信息类——-&gt;请求正在处理，属于临时响应</li><li>2XX：成功类——-&gt;请求正常处理完毕</li><li>3XX：重定向——-&gt;需要附加操作完成请求</li><li>4XX：客户端错误—-&gt;服务器无法处理请求</li><li>5XX：服务器错误—-&gt;服务器处理请求出错</li></ul><p><strong>常见状态码：</strong></p><p><strong>1XX信息响应</strong></p><ul><li>100 Continue：迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</li><li>101 Switching Protocol：响应客户端的 Upgrade 标头发送的，并且指示服务器也正在切换的协议。</li><li>102 Processing (WebDAV)：服务器已收到并正在处理该请求，但没有响应可用。</li></ul><p><strong>2XX成功响应</strong></p><ul><li>200 OK：正常，客户端的请求在服务器被正常处理</li><li>201 Created：该请求已成功，并因此创建了一个新的资源。这通常是在PUT请求之后发送的响应。</li><li>202 Accepted：请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</li><li>203 Non-Authoritative Information：服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 No Content：正常处理，但无资源返回，响应报文中不含实体主体</li><li>205 Reset Content：服务器成功处理了请求，且没有返回任何内容。</li><li>206 Partial Content：客户端进行了范围请求且服务器成功执行了这部分的GET请求</li></ul><p><strong>3XX重定向</strong></p><ul><li>300 Multiple Choice：针对请求，服务器可执行多种操作。 服务器可根据user agent选择一项操作，或提供操作列表供请求者选择。</li><li>301 Moved Permanently：永久性重定向，请求的资源已被分配了新的URI（以后都用新URI）</li><li>302 Found：临时性重定向，请求的资源被暂时的移动到了由Location 头部指定的 URL 上（本次使用新URI访问）</li><li>303 See Other：请求对应的资源存在另一个URI,应该使用GET方法定向获取请求的资源<br>当301、302、303响应状态码返回，几乎所有浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求自动再次发送</li><li>304 Not Modified：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</li><li>305 Use Proxy：请求者只能使用代理访问请求的网页。 （已不再使用，但目前仍能生效）</li><li>307 Temporary Redirect：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>308 Permanent Redirect：资源现在永久位于响应头中<code>Location</code>指定的另一个URI。</li></ul><p><strong>4XX请求错误</strong></p><ul><li>400 Bad Request：响应状态码表示由于语法无效，服务器无法理解该请求</li><li>401 Unauthorized：发送的请求需要有通过http认证（BASIC认证、DIGEST认证）的认证信息。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。若之前已经进行了一次请求，则表示用户认证失败</li><li>403 Forbidden：服务器端有能力处理该请求，但是拒绝授权访问</li><li>404 Not Found：服务器端无法找到所请求的资源</li><li>405 Method Not Allowed：禁用请求中指定的方法。</li><li>406 Not Acceptable：无法使用请求的内容特性响应请求的网页。</li><li>407 Proxy Authentication Required：此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 Request Timeout：服务器等候请求时发生超时。</li><li>409 Conflict：服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 Gone：如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 Length Required：服务器不接受不含有效内容长度标头字段的请求。</li><li>412 Precondition Failed：服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 Payload Too Large：服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 URI Too Long：请求的URI过长，服务器无法处理。</li><li>415 Unsupported Media Type：请求的格式不受请求页面的支持。</li><li>416 Requested Range Not Satisfiable：如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 Expectation Failed：服务器未满足”期望”请求标头字段的要求。</li></ul><p><strong>5XX服务器错误</strong></p><ul><li>500 Internal Server Error ：服务器端错误，所请求的服务器遇到意外的情况并阻止其执行请求。</li><li>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 Server Unavailable：服务器暂时处于超负载或者正在停机维护，现在无法处理请求　</li><li>504 Gateway Timeout：服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 HTTP Version Not Supported：服务器不支持请求中所用的 HTTP 协议版本。</li></ul><p><strong>参考文章</strong></p><blockquote><p>HTTP | MDN <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a><br>关于HTTP协议，一篇就够了 <a href="https://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranyonsue/p/5984001.html</a><br>开发之前应该了解的HTTP <a href="https://blog.csdn.net/qq_35414779/article/details/78981151" target="_blank" rel="noopener">https://blog.csdn.net/qq_35414779/article/details/78981151</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HAProxy笔记-1</title>
      <link href="/2018/05/31/HAProxy%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/31/HAProxy%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<img src="/2018/05/31/HAProxy笔记/0.png"><p>本篇包含以下内容：</p><ul><li><a href="#HAProxy介绍">HAProxy介绍</a></li><li><a href="#HAProxy配置文件">HAProxy配置文件</a></li></ul><a id="more"></a><h1 id="HAProxy介绍"><a href="#HAProxy介绍" class="headerlink" title="HAProxy介绍"></a>HAProxy介绍</h1><p>HAProxy是一个提供高可用性、负载均衡，以及可基于TCP（第四层）和HTTP（第七层）的应用代理软件。</p><p>HAProxy适合处理高负载Web站点的HTTP请求，这些站点通常需要会话保持或七层处理，HAProxy完全支持数以万计的并发连接，并且能使后端的Web服务器不会暴露。HAProxy还支持服务器健康检查，当后端服务器出现故障后，HAProxy会自动移除该服务器，在故障排除后自动将该服务器加入。</p><p>HAProxy特点：</p><ul><li>支持连接拒绝：通过限制连接防御攻击蠕虫，降低被DDOS攻陷的可能</li><li>支持全透明代理</li><li>自带服务器状态监控页面</li><li>原生配置了SSL证书</li><li>支持虚拟主机</li><li>支持双机热备</li><li>支持服务器健康检查</li><li>单进程</li></ul><p>HAProxy支持的代理模式：</p><ul><li>基于四层的TCP代理：仅在客户端和服务器间进行流量转发。可用于邮件服务（SMTP、POP3等）、内部协议通信服务器、MySQL、https等</li><li>基于七层的HTTP代理：能分析应用层协议，且能根据协议信息灵活控制访问</li></ul><p><strong>HAProxy的frontend和backend功能：</strong></p><ul><li><strong>frontend</strong>：ACL规则匹配，根据任意HTTP请求头内容做规则匹配，然后将请求重定向到指定的backend</li><li><strong>backend</strong>：事先定义的server pool，等待前端将请求转到的服务器组</li></ul><h1 id="HAProxy配置文件"><a href="#HAProxy配置文件" class="headerlink" title="HAProxy配置文件"></a>HAProxy配置文件</h1><p>直接通过<code>yum install haproxy</code>安装，版本为1.6。安装后会自动创建用户haproxy。</p><p>HAProxy命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">haproxy</span><br><span class="line">        -v 显示版本</span><br><span class="line">        -vv 显示详细的构建选项信息</span><br><span class="line">        -d 进入debug模式</span><br><span class="line">        -f 指定配置文件</span><br><span class="line">        -dM[&lt;byte&gt;] poisons memory with &lt;byte&gt; (defaults to 0x50)</span><br><span class="line">        -D 后台运行; -C changes to &lt;dir&gt; before loading files.</span><br><span class="line">        -q 静默模式</span><br><span class="line">        -c 检查配置文件语法</span><br><span class="line">        -n 设置最大连接数，默认2000</span><br><span class="line">        -m 限制可用的内存量，单位MB</span><br><span class="line">        -N sets the default, per-proxy maximum # of connections (2000)</span><br><span class="line">        -L 设置本地peer name，默认为主机名</span><br><span class="line">        -p writes pids of all children to this file</span><br><span class="line">        -de 禁止使用epoll()函数</span><br><span class="line">        -dp 禁止使用poll()函数</span><br><span class="line">        -dS disables splice usage (broken on old kernels)</span><br><span class="line">        -dR disables SO_REUSEPORT usage</span><br><span class="line">        -dV 禁止服务器端的SSL</span><br><span class="line">        -sf/-st [pid ]* finishes/terminates old pids.</span><br><span class="line">常用操作：选项不可连起来，只能分开</span><br><span class="line">haproxy -c -f /etc/haproxy/haproxy.cfg  检查配置文件，一定要-c -f都指定</span><br><span class="line">haproxy -D -f /etc/haproxy/haproxy.cfg  以daemon模式启动</span><br></pre></td></tr></table></figure><p>HAProxy主配置文件<code>/etc/haproxy/haproxy.cfg</code></p><p>HAProxy的配置有五个部分：<code>global</code>，<code>defaults</code>，<code>frontend</code>，<code>backend</code>，<code>listen</code></p><p>全局global配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">进程管理与安全性参数</span><br><span class="line">  log     127.0.0.1 local2            #日志使用local2输出到本地</span><br><span class="line">  chroot      /var/lib/haproxy        #改变haproxy的工作目录</span><br><span class="line">  pidfile     /var/run/haproxy.pid    #指定PID文件路径</span><br><span class="line">  user        haproxy       #执行HAProxy进程的用户</span><br><span class="line">  group       haproxy       #执行HAProxy进程的用户组</span><br><span class="line">  daemon                    #后台执行</span><br><span class="line">  stats socket /var/lib/haproxy/stats #用户访问统计数据的接口</span><br><span class="line">  stats maxconn 10          #默认stats socket仅限10个并发连接</span><br><span class="line">  nbproc      1             #启动的haproxy进程的个数，只能用于守护进程模式</span><br><span class="line">性能调整参数</span><br><span class="line">  maxconn     4000          #最大连接数</span><br><span class="line">  spread-checks             #设置HealthCheck时间间隔</span><br><span class="line">  noepoll                   #禁用使用epoll事件轮询系统</span><br><span class="line">  nopoll                    #禁用poll事件轮询系统</span><br><span class="line">  nosplice                  #禁用套接字之间使用内核tcp拼接</span><br></pre></td></tr></table></figure><p>默认defaults配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">  mode http                 #默认模式，tcp为4层，http为7层，health只返回ok</span><br><span class="line">  option httplog            #采用http日志格式</span><br><span class="line">  option httpclose          #防止多余的cookie信息影响到客户端请求的处理结果</span><br><span class="line">  retries  3               #尝试连接的次数，若连接失败则认为服务器不可用</span><br><span class="line">  option http_proxy        #开启代理（仅是基本的代理功能）</span><br><span class="line">  option dontlognull       #不记录空连接</span><br><span class="line">  option http-server-close #开启connection closing</span><br><span class="line">  option forwardfor except 127.0.0.0/8</span><br><span class="line">  option redispatch        #当客户端将请求发往了故障的服务器，则会自动将请求发往其他正常的机器</span><br><span class="line">  timeout http-request 10s   #</span><br><span class="line">  timeout queue        1m    #</span><br><span class="line">  timeout connect      10s   #</span><br><span class="line">  timeout client       1m    #</span><br><span class="line">  timeout server       1m    #</span><br><span class="line">  timeout http-keep-alive 10s #</span><br><span class="line">  timeout check        10s    #</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.ttlsa.com/linux/haproxy-study-tutorial/" target="_blank" rel="noopener">HAProxy用法详解 全网最详细中文文档</a></li><li></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> HAproxy </tag>
            
            <tag> 代理 </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Varnish笔记-1</title>
      <link href="/2018/05/31/Varnish%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/31/Varnish%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Squid笔记-1</title>
      <link href="/2018/05/31/Squid%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/31/Squid%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<ul><li><a href="#Squid介绍">Squid介绍</a></li><li><a href="">代理服务器概念</a></li><li><a href="">Squid安装</a></li><li><a href="">Squid常规配置</a></li><li><a href="">Squid访问控制</a></li><li><a href="">Squid多级代理配置</a></li><li><a href="">Squid实验</a></li><li><a href="">cachemgr.cgi管理Squid</a></li><li><a href="">Squid日志</a></li><li><a href="">Squid调优</a></li></ul><a id="more"></a><h1 id="Squid介绍"><a href="#Squid介绍" class="headerlink" title="Squid介绍"></a>Squid介绍</h1><p>Squid是一个支持HTTP、HTTPS、FTP等服务的Web缓存软件，可通过缓存页面实现降低带宽占用并优化页面相应时间。</p><p><strong>Squid特点与功能：</strong></p><ul><li>不仅能缓存Web页面资源，还能对DNS查询结果进行缓存</li><li>强大的访问控制功能</li><li>保护内网，并加速内网对外网的连接</li><li>记录内网用户访问外网行为</li><li>提供用户认证</li><li>减少出口流量</li><li>工作在TCP/IP的应用层，TCP端口3128</li></ul><p>Squid支持的网络协议：HTTP、FTP、Gopher（信息查找协议）、WAIS（广域信息查询系统）、SSL</p><p>Squid支持的内部缓存和管理协议：HTTP、ICP（互联网缓存协议，用于从缓存中查找指定对象）、Cache Digests（用于生成缓存中对象的索引）、SNMP（用于为外部工具提供缓存信息）、HTCP（用于发现HTTP缓存区，存储管理HTTP数据）</p><p>Squid请求过程：</p><ul><li>客户端访问Squid服务器，由代理服务器代表客户端向web服务器（后端Real Server）请求资源</li><li>Web服务器将相应数据返回给代理服务器</li><li>代理服务器将数据返回给客户端，并保留一份在本地</li><li>其他客户端向该代理服务器请求相同的资源</li><li>代理服务器直接将本地的该资源缓存返回给客户端</li></ul><img src="/2018/05/31/Squid笔记/1.png"><p>squid的硬件环境：内存与磁盘是缓存性能的重要体现。所有对象都会尽可能缓存到内存中，更大的磁盘空间实现更多的缓存目标和更高的命中率，最好使用SAS，尽量不用SATA。磁盘与内存间也有关联，最好每G的磁盘空间有32M的内存对应。</p><h1 id="代理服务器概念"><a href="#代理服务器概念" class="headerlink" title="代理服务器概念"></a>代理服务器概念</h1><p>代理服务器一般构建于内网和Internet间，负责转发内网对Internet的访问，并进行访问控制与记录，可实现安全保护、缓存数据、内容过滤、访问控制等功能。</p><p>Web代理维护着庞大的缓存数据，因此对内存和硬盘的要求很高，更大的内存和硬盘意味着更多的缓存和更高的缓存命中率。</p><p><strong>Web缓存类型：</strong></p><ul><li>客户端缓存：一般就存放在浏览器中。有两个缺点：1.缓存容量小，不能存储大的Web对象，因此命中率较低。2.缓存在本地，不能共享，因此存在大量重复数据。</li><li>代理服务器缓存：位于网络中间位置。容量大，缓存能与内网所有客户端共享。但若性能达不到要求，反而会造成网络瓶颈。代理缓存应具有健壮性、可扩展性、稳定性、负载均衡的特点</li><li>服务器缓存：是为了减轻web服务器的负载，并不是为了提高资源命中率。服务器缓存减少了web服务器的流量、并保护了web服务器的安全，因为web服务器仅向服务器缓存提供数据，并不直接面向客户机。并且提高了网站的可靠性，因为各个服务器缓存间可实现共享。</li></ul><p><strong>三种典型代理方式：</strong></p><ul><li><p>传统代理：在浏览器中设置，指出代理服务器的IP地址和网络端口。便于用户对访问管理控制，配置简单。</p></li><li><p>透明代理（正向代理）：为内网提供外网的访问，即普通的代理服务器。但增加了网络设备的负担，并需要做好更详细的配置，会有一定的延时。若程序的一系列请求是相关的并涉及多个目标对象，有可能会出问题。</p></li><li>反向代理：能代理外部网络访问内网服务器。主要为本地网站做缓存，加快web服务器的响应速度。相当于服务器缓存。反向代理结合智能DNS即可实现基本的CDN</li></ul><h1 id="Squid安装"><a href="#Squid安装" class="headerlink" title="Squid安装"></a>Squid安装</h1><p>Squid版本：3.5</p><p>可直接通过<code>yum install squid</code>安装。然后<code>systemctl start squid</code>启动。</p><p>安装时会自动创建用户squid，并且是系统用户，家目录为/var/spool/squid，且禁止登录。</p><p><strong>注：一定要做到squid服务器的时间同步，否则无法进行缓存</strong></p><p>Squid的相关配置文件：</p><ul><li><code>/etc/httpd/conf.d/squid.conf</code>：用于在Apache中添加运行<code>cachemgr.cgi</code>的配置</li><li><code>/etc/logrotate.d/squid</code>：Squid的日志轮替配置</li><li><code>/etc/squid/squid.conf</code>：Squid主配置文件</li><li><code>/etc/squid/cachemgr.conf</code>：设置可通过<code>cachemgr.cgi</code>管理的主机</li><li><code>/etc/squid/mime.conf</code>：定义MIME类型的文件</li></ul><p>Squid其他相关文件：</p><ul><li><code>/var/log/squid/</code>：存放squid日志的目录</li><li><code>/var/spool/squid/</code>：存放squid缓存的目录</li><li><code>/usr/share/squid/errors/</code>：存放给客户端的报错信息HTML，目录中包含各个语言的子目录</li><li><code>/usr/lib64/squid/cachemgr.cgi</code>：squid cache manager，用于管理主机的动态网页</li></ul><p>squid提供两个命令：</p><ul><li><code>squid</code>：用于管理squid守护进程</li><li><code>squidclinet</code>：用于管理squid客户端</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">squid [options]</span><br><span class="line">    -a port   指定HTTP端口，默认3128</span><br><span class="line">    -d level  将指定调试等级的信息发送到标准错误输出</span><br><span class="line">    -f file   指定配置文件启动</span><br><span class="line">    -k        向squid服务器发送指令</span><br><span class="line">        reconfigure 重载配置文件</span><br><span class="line">        rotate      轮替日志文件</span><br><span class="line">        shutdown    安全关闭</span><br><span class="line">        restart     重启服务</span><br><span class="line">        interrupt   中断服务</span><br><span class="line">        kill        杀死服务</span><br><span class="line">        debug       开启debug</span><br><span class="line">        check       检查运行状态</span><br><span class="line">        parse       检查配置文件</span><br><span class="line">    -s       启用syslog</span><br><span class="line">    -u port  指定ICP端口，默认3130，若要关闭，就指定0</span><br><span class="line">    -z        创建缓存目录，即初始化缓存</span><br><span class="line">    -C        不捕获fatal信号</span><br><span class="line">    -D        不进行DNS参数测试</span><br><span class="line">    -F        不响应任何请求直到存储重建</span><br><span class="line">    -N        不使用daemon模式</span><br><span class="line">    -S        在重建期间仔细检查swap分区</span><br><span class="line">    -X        强制进入完全调试模式</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">squidclient [Basic Options] [HTTP Options]</span><br><span class="line">    -s | --quiet    静默模式，不打印输出</span><br><span class="line">    -v | --verbose  显示详细信息，最多-vv</span><br><span class="line">      -v：显示向外发的请求信息</span><br><span class="line">      -vv：显示动作跟踪信息</span><br><span class="line">    -h | --host host     指定将信息发给的主机，默认为localhost</span><br><span class="line">    -l | --local host    指定绑定的本地IP地址，默认为空</span><br><span class="line">    -p | --port port     指定服务端口，默认3128</span><br><span class="line">    -T timeout           指定读写操作的超时时间</span><br><span class="line">    --ping [options]     允许ping模式</span><br><span class="line">    -g count        指定ping包的个数，默认一直ping</span><br><span class="line">    -I interval     指定ping包发送间隔，默认1s</span><br><span class="line"></span><br><span class="line">HTTP Options:</span><br><span class="line">    -a           不包含“accept:header”</span><br><span class="line">    -j hosthdr   Host header content</span><br><span class="line">    -k           保持长连接，默认只接收一个请求就关闭连接</span><br><span class="line">    -m method    指定请求方法，默认GET</span><br><span class="line">    -n           代理协商认证（kerberos）</span><br><span class="line">    -N           www协商认证（kerberos）</span><br><span class="line">    -P file      将指定文件作为请求载荷</span><br><span class="line">    -r           强制缓存重新加载URL</span><br><span class="line">    -t count     跟踪计数缓存跳数</span><br><span class="line">    -u user      代理认证用户名</span><br><span class="line">    -U user      www认证用户名</span><br><span class="line">    -w password  代理认证密码</span><br><span class="line">    -W password  www认证密码</span><br></pre></td></tr></table></figure><h1 id="Squid常规配置"><a href="#Squid常规配置" class="headerlink" title="Squid常规配置"></a>Squid常规配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">http_port    3128  [模式] [options]             #Squid监听的端口</span><br><span class="line"># 若要添加多个端口，用空格隔开</span><br><span class="line">    常用模式：</span><br><span class="line">      accel：加速或反向代理模式</span><br><span class="line">      intercept：支持IP层NAT拦截传输到该Squid端口的流量</span><br><span class="line">      从squid3开始就没有transparent透明模式了</span><br><span class="line"></span><br><span class="line">icp_port     3130              #ICP端口</span><br><span class="line"># ICP是专门运行在代理服务器间交换缓存数据的协议。ICP使用UDP端口3130</span><br><span class="line"></span><br><span class="line">cache_effective_user  squid    #运行squid进程的用户</span><br><span class="line">#squid进程是root启动的，但启动后会由指定的普通用户继续运行</span><br><span class="line">cache_effective_group  squid    #运行squid进程的用户组</span><br><span class="line"></span><br><span class="line">pid_filename /var/run/squid.pid #squid的PID文件位置</span><br><span class="line"># 此文件由root在启动squid时创建</span><br><span class="line"></span><br><span class="line">logformat squid %ts.%03tu %6tr %&gt;a %Ss/%03&gt;Hs %&lt;st %rm %ru %un %Sh/%&lt;A %mt  #指定日志记录格式</span><br><span class="line">access_log /var/log/squid/access.log squid  #日志路径，类型为squid</span><br><span class="line"></span><br><span class="line">cache_mem   8 MB       #cache内存</span><br><span class="line">#设定squid能用多少额外的内存来缓存对象的限制值</span><br><span class="line"></span><br><span class="line">cache_dir  ufs /var/spool/squid 100 16 256  #指定缓存类型为ufs，保存在/var/spool/squid，是默认值</span><br><span class="line">#大小限制为100MB，第1层子目录为16个，第2层子目录为256个</span><br><span class="line"></span><br><span class="line">cache_store_log /var/log/squid/store.log   #数据缓存的日志，是默认值</span><br><span class="line"></span><br><span class="line">maximum_object_size_in_memory 8 KB   #squid保存在内存中的对象最大为8KB</span><br><span class="line">#内存中的对象访问速度最快，但内存有限，需要根据内存大小设置</span><br><span class="line"></span><br><span class="line">maximum_object_size      4096 KB  #最大的缓存对象的字节数4096KB</span><br><span class="line">#只有小于该值的对象才会被缓存，若硬盘足够大，可适度提高</span><br><span class="line"></span><br><span class="line">cache_swap_low  90     #设置Squid缓存空间的使用策略。</span><br><span class="line">cache_swap_high 95     #当缓存中数据占到整个缓存大小的95%时</span><br><span class="line">                       #就会按算法删除缓存中的数据</span><br><span class="line">                       #直到缓存数据占到整个缓存大小的90%</span><br><span class="line">                       #可以最大限度利用缓存空间，但也不会出现空间溢出</span><br><span class="line"></span><br><span class="line">coredump_dir /var/spool/squid  #放置squid进程运行时coredump文件的目录</span><br><span class="line">cache_mgr   root       #Squid管理员用户的Email</span><br><span class="line">visible_hostname  proxy.example.com   #设置对外可见的主机名，会在错误信息中显示</span><br></pre></td></tr></table></figure><blockquote><p><a href="http://www.squid-cache.org/Doc/config/logformat/" target="_blank" rel="noopener">logformat日志格式设置</a></p></blockquote><p>Squid会设置在缓存目录下建立多个目录，每个目录又建立多个子目录，在最里层的目录存放缓存文件，缓存文件是通过对客户端请求的URL进行哈希运算生成的。Squid会在内存建立一张哈希表，记录硬盘中缓存文件配置的情形。</p><p>使用<code>squid -k parse</code>检查配置文件语法，确认没有报错后<code>squid -z</code>初始化缓存目录，会显示<code>Making directories in /var/spool/squid/00</code>等信息，发现，第一层的目录数量是16，第二层目录的数量是256，目录名都是由十六进制标号，与配置文件<code>cache_dir</code>配置的一致。若无法创建，可能是该目录的权限问题。</p><p>再使用<code>squid -N -d1</code>测试，没有报错，则说明启动完成。</p><p>通过浏览器测试，设置代理服务器</p><img src="/2018/05/31/Squid笔记/4.png"><h1 id="Squid访问控制"><a href="#Squid访问控制" class="headerlink" title="Squid访问控制"></a>Squid访问控制</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">acl name type value1 value2...    #设置ACL名字和对象的值</span><br><span class="line">http_access &lt;allow|deny&gt; [!]ACL对象1 ...  #将客户端请求与http_access的对象匹配，指定allow或deny。!为取反。</span><br><span class="line">#若一个请求与所有http_access都不匹配，则执行与最后一条http_access指定的动作相反的动作</span><br></pre></td></tr></table></figure><p>常见的ACL类型：</p><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>src</td><td>源IP地址，可以单个IP地址，可以是地址范围</td></tr><tr><td>dst</td><td>目的IP地址，同上</td></tr><tr><td>myip</td><td>本地网络接口IP地址</td></tr><tr><td>srcdomain</td><td>客户所属的域，Squid会根据客户IP地址进行反向DNS查询</td></tr><tr><td>dstdomain</td><td>服务器所属的域，与客户请求的URL匹配</td></tr><tr><td>time</td><td>时间段</td></tr><tr><td>port</td><td>指向其他计算机的网络端口，即是目标服务器上的端口</td></tr><tr><td>myport</td><td>指向squid服务器的端口，是squid服务器上的端口</td></tr><tr><td>proto</td><td>客户端请求所使用的协议，如http、https、ftp、gopher</td></tr><tr><td>method</td><td>HTTP请求方法</td></tr><tr><td>proxy_auth</td><td>squid认证的用户名</td></tr><tr><td>url_regex</td><td>关于URL的正则表达式（域名）</td></tr><tr><td>urlpath_regex</td><td>关于URL资源的正则表达式（资源路径，不带有域名）</td></tr><tr><td>ident</td><td>指定用户</td></tr></tbody></table><p>acl对象的值间的关系为”或“，只要满足一个就匹配了该acl规则。而http_access与其他规则的设置使用”与“逻辑。squid默认配置拒绝每个请求，因此在使用代理前，必须先添加访问控制规则。</p><p>若value为文件名，对象的值实际上是文件的内容。</p><p>常见案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Squid3已默认定义acl名：all、localhost、manager、to_localhost</span><br><span class="line">    acl all src 0.0.0.0/0</span><br><span class="line">    acl localhost src 127.0.0.1/32</span><br><span class="line">    acl manager proto cache_object   #cache_object是squid自定义的协议，用于访问squid的缓存管理接口</span><br><span class="line">    acl to_localhost dst 127.0.0.1/8</span><br><span class="line">因此以上四个acl名字不能再使用，且可以直接调用，无需再定义</span><br><span class="line"></span><br><span class="line">acl worktime time MTWHF 08:00-17:00   </span><br><span class="line">#时间从周一到周五，早上8点到下午5点</span><br><span class="line">  S-Sun M-Mon T-Tue W-Wed H-Thu F-Fri A-Sat</span><br><span class="line"></span><br><span class="line">acl mynet src 10.1.1.1/24</span><br><span class="line">#源10.1.1.1/24的子网命名为mynet</span><br><span class="line"></span><br><span class="line">acl aim dstdomain .baidu.com .google.com</span><br><span class="line">#匹配指定目的域名</span><br><span class="line"></span><br><span class="line">acl giffile url_regex -i \.gif$</span><br><span class="line">#匹配以.gif结尾的URL</span><br><span class="line"></span><br><span class="line">acl other srcdomain &quot;/etc/squid/other&quot;</span><br><span class="line">#匹配文件中指定的源域名</span><br><span class="line"></span><br><span class="line">acl safe_port port 80</span><br><span class="line">#匹配指定的目标服务器端口</span><br><span class="line"></span><br><span class="line">acl Users ident tom</span><br><span class="line">http_access allow tom</span><br><span class="line">#只允许tom访问</span><br><span class="line"></span><br><span class="line">acl mynet src 10.1.1.1-10.1.1.10</span><br><span class="line">http_access allow mynet</span><br><span class="line">http_access deny all</span><br><span class="line">#仅允许mynet子网访问</span><br><span class="line"></span><br><span class="line">acl user1 src 10.1.1.1</span><br><span class="line">acl user2 src 10.1.1.2</span><br><span class="line">acl user1_time time MTWHT 08:00-12:00</span><br><span class="line">acl user2_time time MTWHT 08:00-13:00</span><br><span class="line">http_access allow user1 user1_time</span><br><span class="line">http_access allow user2 user2_time</span><br><span class="line">#给两个用户分别指定上外网的时间</span><br><span class="line"></span><br><span class="line">acl ftpmp3 url_regex -i &quot;^ftp://.*\.mp3$&quot;</span><br><span class="line">http_access deny ftpmp3</span><br><span class="line">#禁止从任何ftp上下载mp3文件</span><br><span class="line"></span><br><span class="line">acl cgi urlpath_regex -i &quot;^/cgi-bin&quot;</span><br><span class="line">http_access deny cgi</span><br><span class="line">#禁止访问cgi网页</span><br><span class="line"></span><br><span class="line">acl limit maxconn 16</span><br><span class="line">http_access deny limit</span><br><span class="line">#限制同一IP客户端的最大连接数</span><br></pre></td></tr></table></figure><p>squid默认acl配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#所有内网</span><br><span class="line">acl localnet src 10.0.0.0/8</span><br><span class="line">acl localnet src 172.16.0.0/12</span><br><span class="line">acl localnet src 192.168.0.0/16</span><br><span class="line">acl localnet src fc00::/7       </span><br><span class="line">acl localnet src fe80::/10      </span><br><span class="line"></span><br><span class="line">acl SSL_ports port 443      #SSL443端口</span><br><span class="line">acl Safe_ports port 80# 放行http</span><br><span class="line">acl Safe_ports port 21# 放行ftp</span><br><span class="line">acl Safe_ports port 443# 放行https</span><br><span class="line">.....                       #放行的其他服务</span><br><span class="line"></span><br><span class="line">acl CONNECT method CONNECT  #connect方法，是HTTP中用于代理的方法</span><br><span class="line"></span><br><span class="line">http_access deny !Safe_ports        ##只允许本机转发客户机对非Safe_ports的请求</span><br><span class="line">http_access deny CONNECT !SSL_ports #拒绝所有非SSL_ports的CONNECT请求，只允许本机用connect连接非SSL_ports</span><br><span class="line">http_access allow localhost manager #允许localhost使用cache_object协议</span><br><span class="line">http_access deny manager      #拒绝所有其他网络使用cache_object</span><br><span class="line">http_access allow localnet    #允许内网访问</span><br><span class="line">http_access allow localhost   #允许本地访问</span><br><span class="line">http_access deny all         #剩下的都不允许</span><br><span class="line">http_port 3128               </span><br><span class="line">coredump_dir /var/spool/squid    </span><br><span class="line">refresh_pattern ^ftp:144020%10080</span><br><span class="line">refresh_pattern ^gopher:14400%1440</span><br><span class="line">refresh_pattern -i (/cgi-bin/|\?) 00%0</span><br><span class="line">refresh_pattern .020%4320</span><br></pre></td></tr></table></figure><h1 id="Squid多级代理配置"><a href="#Squid多级代理配置" class="headerlink" title="Squid多级代理配置"></a>Squid多级代理配置</h1><p>在大型网络中一台Squid服务器的性能不能应对巨大的访问量，需要构建多级代理服务器，类似与计算机集群，使用ICP交换缓存，形成一个逻辑上的大型Squid服务器。</p><p>代理服务器间的结构可分为：同级结构、层次结构、网状结构。最常见是层次结构。</p><p>需要配置参数<code>cache_peer hostname type http_port icp_port options</code></p><ul><li><code>hostname</code>为另一台Squid服务器的域名或IP地址</li><li><code>type</code>为ICP请求的类型：<code>parent</code>或<code>sibling</code></li><li><code>http_port</code>为对端的Squid监听请求端口</li><li><code>icp_port</code>为对端ICP的端口</li></ul><p>ICP的两种请求类型type：</p><ul><li><code>parent</code>：会把客户端的请求发送给对方，对方的缓存中若有请求的数据，则返回，若没有，则对方向web服务器读取数据，再返回。（类似DNS的递归查询）一般对象处于上一级时使用此类型，因为上一级会更加接近于web服务器。</li><li><code>sibling</code>：不会把客户端请求发给对方，仅仅询问有没有缓存。如果没有，则对方仅仅告诉回复没有，并不会向web服务器请求数据。一般对象处于同等级别时用此类型。de</li></ul><p>常见的options参数：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>proxy-only</td><td>从对方得到的数据不做缓存，默认会做</td></tr><tr><td>weight=n</td><td>指定对方的权重，有多个cache_peer时会按权重选择，默认根据网络响应时间自动选择</td></tr><tr><td>no-query</td><td>不向对方发送ICP请求，只发送HTTP代理请求，一般用于对方不支持ICP或不可用的情况</td></tr><tr><td>default</td><td>与no-query一起用，当对方都不支持ICP时，就用该peer</td></tr><tr><td>no-digest</td><td>不使用内存摘要表查询，直接ICP通信</td></tr><tr><td>login=user:password</td><td>若对方需要认证，就提供用户名和密码</td></tr></tbody></table><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cache_peer system3.example.com parent 3128 3130 proxy-only default</span><br><span class="line">cache_peer system4.example.com sibling 3128 3130 proxy-only</span><br></pre></td></tr></table></figure><p>若要通过规则选择不同的上级代理服务器，达到负载均衡，还需要配置：</p><p><code>cache_peer_domain cache-host domain ...</code></p><p><code>cache_peer_access cache-host allow|deny [!]ACL对象...</code></p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cache_peer system1.example.com parent 3128 3130</span><br><span class="line">cache_peer system2.example.com sibling 3128 3130 proxy-only</span><br><span class="line">cache_peer_domain system1.example.com example</span><br><span class="line">cache_peer_domain system2.example.com !example</span><br><span class="line">#system1为example域的代理服务器，system2为非example域的代理服务器</span><br></pre></td></tr></table></figure><h1 id="Squid实验"><a href="#Squid实验" class="headerlink" title="Squid实验"></a>Squid实验</h1><h2 id="透明二级代理"><a href="#透明二级代理" class="headerlink" title="透明二级代理"></a>透明二级代理</h2><p>环境：</p><ul><li>client1：192.168.1.128</li><li>server1：192.168.1.129</li><li>server2：192.168.1.130,192.168.205.140</li><li>web1：192.168.205.139</li></ul><img src="/2018/05/31/Squid笔记/2.png"><p>server1 上的配置<code>squid.conf</code>添加或修改以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">http_port    3128   accel     #配置为透明代理</span><br><span class="line">icp_port     3130</span><br><span class="line">cache_effective_user  squid</span><br><span class="line">pid_filename /var/run/squid.pid</span><br><span class="line">logformat squid %ts.%03tu %6tr %&gt;a %Ss/%03&gt;Hs %&lt;st %rm %ru %un %Sh/%&lt;A %mt</span><br><span class="line">access_log   /var/log/squid/access.log squid</span><br><span class="line">cache_dir  ufs /var/spool/squid 100 16 256</span><br><span class="line">cache_store_log /var/log/squid/store.log</span><br><span class="line">hosts_file   /etc/hosts           #用于解析IP地址</span><br><span class="line">visible_hostname  system1.example.com  #错误信息中显示的主机名</span><br><span class="line">cache_effective_user  squid    #若不设置user和group，会默认使用nobody</span><br><span class="line">cache_effective_group  squid</span><br><span class="line"></span><br><span class="line">acl PURGE   method PURGE          #purge是squid自定义的方法，用于删除squid缓存中的对象（能让管理员强制删除）</span><br><span class="line">                                  #squid是默认拒绝Purge请求的</span><br><span class="line"></span><br><span class="line">http_access allow localhost manager  #只允许本机使用cache_object协议</span><br><span class="line">http_access allow localhost PURGE    #只允许本机使用purge方法</span><br><span class="line">http_access deny manager PURGE</span><br><span class="line"></span><br><span class="line">icp_access allow all         #允许所有客户机访问ICP端口</span><br><span class="line">http_reply_access allow all  #允许对所有客户机进行请求的回复</span><br></pre></td></tr></table></figure><p>并且需要进行端口转发，即重定向，因为代理服务器需要将客户端发往80端口的数据包改为发往自己的3128端口，实现代理。因此需要开启防火墙firewalld或iptables服务。</p><p>若是使用firewalld，则先要确定是否开启了伪装IP功能（Masquerade）</p><p><code>firewall-cmd --query-masquerade</code>，若为no，则需要开启<code>firewall-cmd --add-masquerade --permanent</code>。</p><p>设置端口转发：<code>firewall-cmd --add-forward-port=port=80:proto=tcp:toport=3128 --permanent</code></p><p>若为iptables，则添加两条规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -i ens33 -p tcp --dport 80 -j --REDIRECT --to-ports=3128</span><br><span class="line">iptables -t nat -A POSTROUTING -o ens36 -s 192.168.205.0/24 MASQUERADE</span><br><span class="line"># ens33为内网卡，ens36为外网卡</span><br></pre></td></tr></table></figure><p>然后打开转发，无论是firewalld还是iptables，都要打开。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf </span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>最后放行80和443端口，放行http和https服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=80/tcp --add-port=443/tcp</span><br><span class="line">firewall-cmd --permanent --add-service=http --add-service=https</span><br></pre></td></tr></table></figure><h2 id="反向二级代理"><a href="#反向二级代理" class="headerlink" title="反向二级代理"></a>反向二级代理</h2><h1 id="cachemgr-cgi管理Squid"><a href="#cachemgr-cgi管理Squid" class="headerlink" title="cachemgr.cgi管理Squid"></a>cachemgr.cgi管理Squid</h1><p>通过web界面管理Squid，需要<code>cachemgr.cgi</code>动态网页文件，存放在<code>/usr/lib64/squid/</code>中。可以将该cgi文件复制到<code>/var/www/cgi-bin</code>中，也可不动，但要注意文件的权限问题，一定要改为<code>apache</code>。然后在httpd的主配置文件中添加，Location配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ScriptAlias &quot;/squidcgi&quot; &quot;/var/www/cgi-bin/cachemgr.cgi&quot;</span><br><span class="line">&lt;Location &quot;/squidcgi&quot;&gt;</span><br><span class="line">    Order deny,allow     #逗号后不能有空格</span><br><span class="line">    Allow from all</span><br><span class="line">&lt;/Location&gt;</span><br></pre></td></tr></table></figure><p>然后浏览器通过<code>主机IP/squidcgi</code>访问。</p><img src="/2018/05/31/Squid笔记/4.png"><p>默认不需要填用户名密码即可登录。若要设置登录用户名密码，只需要在主配置文件中添加<code>cachemgr_password</code>参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cachemgr 密码  行为action</span><br><span class="line">要禁用一个操作，就把密码设为disable，后面跟上要禁止的操作</span><br><span class="line">要允许不输入密码的操作，就把密码设为none，后面跟上允许的操作</span><br><span class="line">action为all表示为所有操作设置相同密码</span><br></pre></td></tr></table></figure><h1 id="Squid日志"><a href="#Squid日志" class="headerlink" title="Squid日志"></a>Squid日志</h1><p>Squid日志不仅记录服务器进程的运行，还记录用户的访问情况、缓存存储状况、缓存访问状况等。</p><p>Squid三个日志：access.log，cache.log，store.log</p><p>和日志文件相关的配置：</p><ul><li><code>cache_log /var/log/squid/cache.log</code>：指定缓存信息日志的路径。包含了缓存的起始配置信息，分类的错误信息，性能警告。</li><li><code>cache_store_log /var/log/squid/store.log</code>：指定对象存储记录日志的路径。包含被写入缓存空间的对象、被从缓存空间清除的对象等。可设为<code>none</code>禁止</li><li><code>cache_swap_log /var/spool/squid/cache_swap.log</code>：指定每个交换日志的路径。包含存储在交换空间的对象元数据。这类日志最好不要删除，否则可能会导致Squid故障。</li><li><code>debug_options ALL,1</code>：控制日志记录内容的多少，第一个参数决定对哪些行为做记录，ALL表示对所有行为做记录，第二个参数表示详细程度，1表示详细程度最低。</li><li><code>log_fqdn</code>：控制access.log日志中客户机地址的记录方式。on表示会记录客户机的域名，off则记录IP地址。开启会增加系统负担</li></ul><ul><li><code>logformat squid %ts.%03tu %6tr %&gt;a %Ss/%03Hs %&lt;st %rm %ru %un %Sh/%&lt;A %mt</code>是在配置文件中日志格式的参数配置。<ul><li><code>%ts.03tu</code>：记录请求完成时间。<code>%ts</code>为相对于Unix纪元（1970-1-1）的秒数，<code>%03tu</code>表示3个宽度的毫秒数，<code>.</code>为写入日志的固定符号。</li><li><code>%6tr</code>：响应时间，表明了Squid处理请求的时间（接收到HTTP请求到响应报文发出），单位毫秒。ICP响应时间一般为0，非常快速。</li><li><code>%&gt;a</code>：记录客户端地址，若开启了<code>log_fqdn</code>，则会记录客户端主机名。还可通过<code>client_netmask</code>隐藏客户端IP的一部分</li><li><code>%Ss/%03Hs</code>：记录请求结果和状态码，<code>%Ss</code>是Squid特有的请求结果码，<code>%03Hs</code>是HTTP状态码</li><li><code>%&lt;st</code>：记录传输的字节数。是整个数据包的大小，会比实际载荷信息大。</li><li><code>%rm</code>：记录请求的方法。HTTP的常见请求和ICP的ICP_QUERY请求</li><li><code>%ru</code>：记录客户端请求的URI。默认不会记录URL中第一个<code>?</code>后所有信息</li><li><code>%un</code>：记录客户端用户身份。Squid使用RFC1413或HTTP的验证头部确认用户身份</li><li><code>%Sh/%&lt;A</code>：记录peer主机（其他代理服务器）信息</li><li><code>%mt</code>：记录MIME类型。从响应的<code>Content-type</code>域获取信息，若没有就使用一个<code>-</code>代替。</li></ul></li><li><code>logfile_rotate</code>：轮询保存的文件数，超过限制就会从头开始覆盖</li></ul><h2 id="日志轮询"><a href="#日志轮询" class="headerlink" title="日志轮询"></a>日志轮询</h2><p>Squid并没有自动轮询的机制，只能使用<code>squid -k rotate</code>命令，并编写脚本通过cron周期执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash </span><br><span class="line">cd /var/log/squid/</span><br><span class="line">[ -f access.log ] &amp;&amp; mv access.log access_$(date +%F).log</span><br><span class="line">squid -k rotate</span><br></pre></td></tr></table></figure><h2 id="Sarg工具分析日志"><a href="#Sarg工具分析日志" class="headerlink" title="Sarg工具分析日志"></a>Sarg工具分析日志</h2><p>Sarg是一个Squid的日志分析工具，输出为html文件。<a href="https://nchc.dl.sourceforge.net/project/sarg/sarg/sarg-2.3.11/sarg-2.3.11.tar.gz" target="_blank" rel="noopener">Sarg下载-tar.gz包</a></p><p>依赖gd库，pcre库。在sarg安装完成后，进入安装目录的<code>bin</code>目录，执行<code>sarg</code>命令，sarg会自动寻找Squid的日志文件，并分析。<code>SARG: Records in file: 595935, reading: 100.00%</code>，然后会生成一个目录，是自动存放在<code>/var/www/html/squid-reports</code>下，目录名为<code>起始日期-结束日期</code>，该目录下有<code>index.html</code></p><p>通过浏览器访问该index文件，数据量相当庞大，并提供图表和日期时间的数据记录</p><img src="/2018/05/31/Squid笔记/5.png"><p>sarg命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sarg [options]</span><br><span class="line">     --convert      将access.log文件转换为易读的日期格式</span><br><span class="line">     -d DATE        指定报告的日志范围dd/mm/yyyy-dd/mm/yyyy</span><br><span class="line">     -e MAIL        将报告发送给指定email</span><br><span class="line">     -f FILE        指定配置文件，默认为安装目录的etc/sarg.conf</span><br><span class="line">     --keeplogs     保留以前生成的每个报告</span><br><span class="line">     -l FILE        指定日志文件</span><br><span class="line">     -n             使用rDNS将IP地址解析成域名</span><br><span class="line">     -o DIR         报告存放目录</span><br><span class="line">     -p             使用IP地址而不是userid</span><br><span class="line">     --split        按-d指定的日期切割日志文件</span><br><span class="line">     -t TIME        指定时间范围[HH:MM 或 HH:MM-HH:MM]</span><br><span class="line">     -u USER        只报告指定用户的行为</span><br><span class="line">     -x             开始分析，且会先输出完整的配置信息</span><br><span class="line">     -z             显示完整的输出信息</span><br></pre></td></tr></table></figure><p>Sarg配置，存放在安装目录的<code>etc/sarg.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">access_log /usr/local/squid/var/logs/access.log  #squid日志路径</span><br><span class="line">output_dir /var/www/html/squid-reports    #报告输出目录</span><br><span class="line">date_format u      #日期格式，u为美国格式mm/dd/yy，e为欧洲格式dd/mm/yy</span><br><span class="line">overwrite_report no   #是否对已存在的日期的报告覆盖</span><br></pre></td></tr></table></figure><h1 id="Squid调优"><a href="#Squid调优" class="headerlink" title="Squid调优"></a>Squid调优</h1><h2 id="调整文件描述符"><a href="#调整文件描述符" class="headerlink" title="调整文件描述符"></a>调整文件描述符</h2><p>Squid在高负载下，需要大量内核资源，又因为Squid是做缓存服务器，所以极度消耗文件描述符，而unix对文件描述符是有限制的（1024），这样会造成极大的性能影响，当squid用完所有文件描述符后，就不能接收新的请求了，并且squid发现文件描述符短缺后，就会发布警告。</p><p>因此，需要先查看文件描述符是否满足使用，大多数情况1024已经足够使用，当出现高负载情况时，则需要更多，因此最好将系统限制的文件描述符数量设为每个进程限制的两倍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a  查看当前的资源限制信息</span><br><span class="line">找到open files，就是同时能打开的文件数量，即文件描述符，默认为1024</span><br><span class="line">优化性能，将此值设为2048</span><br><span class="line">ulimit -Hn 2048 </span><br><span class="line"># -H 设定资源的硬性限制，也就是管理员所设下的限制</span><br><span class="line"># -n 设置同时最多能打开的文件数</span><br></pre></td></tr></table></figure><p>注：<strong>ulimit仅仅作为临时设置，可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。</strong></p><p><strong>若要永久设置，可写入<code>/etc/profile</code>：<code>echo &quot;ulimit -Hn 2048&quot;&gt;&gt;/etc/profile</code> </strong></p><p><strong>或写入<code>/etc/security/limits.conf</code>：<code>echo &quot;*  -  nofile  2048&quot;&gt;&gt;/etc/security/limits.conf</code></strong></p><h2 id="调整临时端口范围"><a href="#调整临时端口范围" class="headerlink" title="调整临时端口范围"></a>调整临时端口范围</h2><p>临时端口是TCP/IP栈分配出连接的本地端口，当squid发起一条连接到另一台服务器，内核给本地socket分配一个端口号。CentOS默认的临时端口范围是32768到60999</p><p>当squid高负载时，若临时端口号短缺，会造成很大的性能影响，因为一些TCP连接在关闭时会进入<code>TIME_WAIT</code>状态，此状态下临时端口不能重用。</p><p>可通过<code>sysctl -a | grep net.ipv4.ip_local_port_range</code>查看</p><p>设置范围4000到65000，<code>sysctl -w net.ipv4.ip_local_port_range=&quot;4000 65000&quot;</code></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li>Linux服务器架设指南（第二版）</li><li>Linux系统管理与网络管理（第二版）</li><li>Linux运维之道（第二版）</li><li>高性能网站构建实战</li><li></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> 代理 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> squid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nagios监控搭建-1</title>
      <link href="/2018/05/31/Nagios%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/05/31/Nagios%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容</p><ul><li><a href="#Nagios概述">Nagios概述</a></li><li><a href="#Nagios搭建">Nagios搭建</a><ul><li><a href="#服务器端">服务器端</a></li><li><a href="#客户端安装">客户端安装</a></li><li><a href="#目录与配置文件概述">目录与配置文件概述</a></li><li><a href="#Nagios监控界面解析">Nagios监控界面解析</a></li><li><a href="#Nagios性能分析图表">Nagios性能分析图表</a></li><li><a href="#邮件告警配置">邮件告警配置</a><a id="more"></a></li></ul></li></ul><p><strong>基于Nagios4.4.1，Nagios-Plugin2.2.1</strong></p><h2 id="Nagios概述"><a href="#Nagios概述" class="headerlink" title="Nagios概述"></a>Nagios概述</h2><p>Nagios是一款用于监控系统和网络的开源应用软件，能有效的监控windows，linux和unix的主机状态。采用C/S结构。Nagios由ANSI C编写。</p><p><strong>Nagios结构</strong><br>分为Nagios Core核心主程序和Nagios Plugins插件。核心只提供很少的监控功能，用户需要给Nagios安装相应插件以搭建完善的监控系统。</p><img src="/2018/05/31/Nagios监控搭建/jiegou.png"><p><strong>Nagios如何工作</strong></p><ul><li>监控：监控关键IT基础架构组件，包括系统指标，网络协议，应用程序，服务，服务器和网络基础架构。</li><li>告警：在关键基础架构组件发生故障和恢复时发送警报，为管理员提供重要事件的通知。警报可以通过电子邮件，短信或自定义脚本提供。</li><li>响应：IT人员可以确认警报并开始解决中断并立即调查安全警报。如果未及时确认警报，则警报可以升级到不同的组。</li><li>报告：报告提供中断，事件，通知和警报响应的历史记录，供以后查看。</li><li>维护：计划停机可防止在计划维护和升级窗口期间发出警报。</li><li>计划：通过趋势和容量规划图表和报告，运维人员可以在发生故障之前识别必要的基础架构升级。</li></ul><p><strong>Nagios特点</strong></p><ul><li>网络服务监控（SMTP、POP3、HTTP、NNTP、ICMP、SNMP、FTP、SSH、端口，URL，丢包，进程数，网络流量、交换机端口流量，路由器，打印机）</li><li>本地和远端主机资源监控（CPU、内存、磁盘、日志、负载uptime、I/O，Raid级别，温度，passwd文件的变化，本地所有文件指纹识别），也包括Windows主机（使用NSClient++ plugin）</li><li>业务数据监控（用户登陆失败次数，用户登陆网站次数，输入验证码失败次数，某个API接口流量并发，网站订单，支付交易数量）</li><li>可以指定自己编写的Plugin通过网络收集数据来监控任何情况（温度、警告……）。可以通过配置Nagios远程执行插件远程执行脚本</li><li>远程监控支持SSH或SSL加通道方式进行监控</li><li>简单的plugin设计允许用户很容易的开发自己需要的检查服务，支持很多开发语言（shell scripts、C++、Perl、ruby、Python、PHP、C#等）</li><li>包含很多图形化数据Plugins（Nagiosgraph、Nagiosgrapher、PNP4Nagios等）</li><li>可并行服务检查</li><li>能够定义网络主机的层次，允许逐级检查，就是从父主机开始向下检查</li><li>当服务或主机出现问题时发出通告，可通过email, pager, sms 或任意用户自定义的plugin进行通知</li><li>能够自定义事件处理机制重新激活出问题的服务或主机</li><li>自动日志循环</li><li>支持冗余监控</li><li>包括Web界面可以查看当前网络状态，通知，问题历史，日志文件等</li></ul><p><strong>Nagios插件概述</strong><br>默认搭建的Nagios服务器只能监控简单的几个项目，而其他服务之类的监控项目都是需要插件来实现，插件可用官方提供的，也可以自己编写。插件是Nagios Core的独立扩展，可以使用Core监控任何事情。<br>插件处理命令行参数，执行特定检查，然后将结果返回给Nagios Core。它们可以是编译的二进制文件（用C，C ++等编写）或可执行的脚本（shell，Perl，PHP等）。</p><p><strong>NRPE概述</strong><br>NRPE 总共由两部分组成:</p><ul><li>check_nrpe 插件，位于监控主机上</li><li>NRPE daemon，运行在远程被监控的 Linux 主机上</li></ul><p>当监控远程主机服务或资源时，工作流程如下：</p><ol><li>nagios会运行check_nrpe插件并指定检查项</li><li>check_nrpe插件会通过ssl连接到远程的NRPE daemon</li><li>NRPE daemon会运行相应的Nagios插件来执行检查动作</li><li>NPRE daemon将检查的结果返回给check_nrpe插件，插件将其递交给Nagios做处理</li></ol><p>NRPE 的检测类型分为两种:</p><ul><li>直接检测：检测的对象是运行NRPE的那台Linux主机的本地资源，直接使用NRPE插件监控远程Linux主机的本地或者私有资源</li><li>间接检测：当运行Nagios的监控主机无法访问到某台被监控主机，但是运行NRPE的机器可以访问得到的时候，运行NRPE的主机就充当一个中间代理，将监控请求发送到被监控对象上</li></ul><p>就如下图中<code>check_disk</code>和<code>check_load</code>是直接检测，<code>check_http</code>和<code>check_ftp</code>是间接检测。<br><img src="/2018/05/31/Nagios监控搭建/nrpe-jiegou.png"></p><h2 id="Nagios搭建"><a href="#Nagios搭建" class="headerlink" title="Nagios搭建"></a>Nagios搭建</h2><p><strong>服务器端需要安装的软件：</strong></p><ol><li>LAMP：因为Nagios需要web端显示，所以需要LAMP的web环境，也可以是LNMP。</li><li>Nagios-core：Nagios的主程序</li><li>Nagios-plugins：Nagios的插件</li><li>NRPE：Nagios的一个功能扩展，可在远程主机上执行插件程序，是客户端程序。</li></ol><p><strong>客户端需要安装的软件</strong></p><ol><li>Nagios-plugins</li><li>NRPE</li></ol><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><ul><li>首先搭建LAMP环境<br><code>yum install httpd php php-gd gd* gcc* glibc* openssl*</code><br>注：gd是图像处理库</li><li>创建用户nagios，创建用户组nagcmd，将apache和nagios都添加到nagcmd副组中。<br><strong>组nagcmd用于从Web接口执行外部命令</strong></li><li>创建安装目录<code>/usr/local/nagios</code>，编译安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">进入nagios-4.4.1解压目录</span><br><span class="line">./configure \</span><br><span class="line">  --prefix=/usr/local/nagios \</span><br><span class="line">  --with-command-group=nagcmd</span><br><span class="line"></span><br><span class="line"> General Options:</span><br><span class="line"> -------------------------</span><br><span class="line">        Nagios executable:  nagios</span><br><span class="line">        Nagios user/group:  nagios,nagios</span><br><span class="line">       Command user/group:  nagios,nagcmd</span><br><span class="line">             Event Broker:  yes</span><br><span class="line">        Install $&#123;prefix&#125;:  /usr/local/nagios</span><br><span class="line">    Install $&#123;includedir&#125;:  /usr/local/nagios/include/nagios</span><br><span class="line">                Lock file:  /run/nagios.lock</span><br><span class="line">   Check result directory:  /usr/local/nagios/var/spool/checkresults</span><br><span class="line">           Init directory:  /lib/systemd/system</span><br><span class="line">  Apache conf.d directory:  /etc/httpd/conf.d</span><br><span class="line">             Mail program:  /usr/bin/mail</span><br><span class="line">                  Host OS:  linux-gnu</span><br><span class="line">          IOBroker Method:  epoll</span><br><span class="line"></span><br><span class="line"> Web Interface Options:</span><br><span class="line"> ------------------------</span><br><span class="line">                 HTML URL:  http://localhost/nagios/</span><br><span class="line">                  CGI URL:  http://localhost/nagios/cgi-bin/</span><br><span class="line"> Traceroute (used by WAP):  /usr/bin/traceroute</span><br><span class="line"></span><br><span class="line">make all \</span><br><span class="line">  &amp;&amp; make install \               # 安装Nagios主程序的CGI和HTML</span><br><span class="line">  &amp;&amp; make install-init \          # 在/lib/systemd/system创建Nagios启动脚本，即可通过systemctl操作</span><br><span class="line">  &amp;&amp; make install-commandmode \   # 配置目录权限</span><br><span class="line">  &amp;&amp; make install-config \        # 安装示例配置文件，在/usr/local/nagios/etc目录</span><br><span class="line">  &amp;&amp; make install-webconf         # 生成配置文件/etc/httpd/conf.d/nagios.conf</span><br></pre></td></tr></table></figure></li></ul><p>至此，Nagios Core安装完成。</p><ul><li><p>下面安装nagios plugins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进入nagios-plugins-2.2.1解压目录</span><br><span class="line">./configure \</span><br><span class="line">  --prefix=/usr/local/nagios </span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">查看/usr/local/nagios/libexec目录下是否有插件文件，若有则安装成功</span><br></pre></td></tr></table></figure></li><li><p>nagios plugins安装后，继续安装NRPE。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">进入nrpe-3.2.1解压目录</span><br><span class="line">./configure</span><br><span class="line">make all \</span><br><span class="line">&amp;&amp; make install \</span><br><span class="line">&amp;&amp; make install-plugin \</span><br><span class="line">&amp;&amp; make install-daemon \</span><br><span class="line">&amp;&amp; make install-config</span><br><span class="line"></span><br><span class="line"> General Options:</span><br><span class="line"> -------------------------</span><br><span class="line"> NRPE port:    5666</span><br><span class="line"> NRPE user:    nagios</span><br><span class="line"> NRPE group:   nagios</span><br><span class="line"> Nagios user:  nagios</span><br><span class="line"> Nagios group: nagios</span><br></pre></td></tr></table></figure></li><li><p>因为可能开启邮件告警功能，所以要启动sendmail服务，不需要做任何配置。<br><code>yum install sendmail*</code><br><code>systemctl enable sendmail</code><br><code>systemctl start sendmail</code></p></li><li><p>也可以使用postfix服务进行邮件告警，同样不需要任何配置<br><code>yum install postfix*</code><br><code>systemctl enable postfix</code><br><code>systemctl start postfix</code><br><strong>注：sendmail和postfix同时只开启一个，一个开启则另一个会自动停止</strong></p></li></ul><p>至此，服务器端核心组件安装完成。</p><ul><li><p>如果要进行汉化，则可以安装中文插件<code>nagios-cn</code>。<br>下载后直接解压进入目录，然后<code>./configure</code>，<code>make &amp;&amp; make install</code>即可。</p></li><li><p>先检查下<code>/usr/local/nagios/bin</code>中是否有命令<code>nagios</code>和<code>nagiostats</code>，如果没有，就将nagios-4.4.1目录中<code>base</code>目录下的<code>nagios</code>命令和<code>nagiostats</code>命令复制到<code>/usr/local/nagios/bin/</code>中，因为通过<code>systemctl</code>启动nagios时，会调用该目录的<code>nagios</code>命令。若不存在会报错无法启动。</p></li><li><p>为配置文件还有nagios和nagiostats命令创软链接。<br><code>ln -s /usr/local/nagios/etc/nagios.cfg /etc/nagios.cfg</code><br><code>ln -s /usr/local/nagios/etc/cgi.cfg /etc/cgi.cfg</code></p></li><li>为nagios默认登录用户nagiosadmin创建http验证密码。<br><code>htpasswd -c /usr/local/nagios/etc/htpasswd.users nagiosadmin</code></li><li><p>将<code>/usr/local/nagios</code>的所有者和所属组都改为<code>nagios</code></p></li><li><p>使用<code>nagios -v /etc/nagios.cfg</code>检查配置文件是否正确。</p></li><li>确保Selinux关闭，确保防火墙放行80端口或关闭。</li><li>启动httpd和nagios以及nrpe服务，并设为开机自启。<br><code>systemctl start httpd nagios nrpe</code><br><code>systemctl enable httpd nagios nrpe</code></li><li>在浏览器上输入<code>IP地址/nagios</code>，会先要求输入htpasswd设置的用户名密码登录验证。登录成功后跳转到Nagios主页面。<img src="/2018/05/31/Nagios监控搭建/nagios-jiemian-main.png"></li></ul><p><strong>服务器端配置NRPE</strong><br><code>ln -s /usr/local/nagios/etc/nrpe.cfg /etc/nrpe.cfg</code></p><ul><li><p>修改<code>commands.cfg</code>文件，添加<code>check_nrpe</code>命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define command &#123;</span><br><span class="line">    command_name check_nrpe</span><br><span class="line">    command_line $USER1$/check_nrpe -H $HOSTADDRESS$ -c $ARG1$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改<code>service.cfg</code>，添加服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define service &#123;</span><br><span class="line">    use local-service</span><br><span class="line">    host_name system3</span><br><span class="line">    service_description users</span><br><span class="line">    check_command check_nrpe!check_users    # 在check_nrpe!后直接使用nrpe.cfg定义的command变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>完成后重启nrpe</p><h3 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><ul><li><p>安装nagios plugins</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进入nagios-plugins-2.2.1解压目录</span><br><span class="line">./configure --prefix=/usr/local/nagios </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li><li><p>安装NRPE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进入nrpe-3.2.1解压目录</span><br><span class="line">./configure</span><br><span class="line">make all \                 构建nrpe和check_nrpe</span><br><span class="line">&amp;&amp; make install \          安装nrpe和check_nrpe</span><br><span class="line">&amp;&amp; make install-plugin \   安装check_nrpe插件</span><br><span class="line">&amp;&amp; make install-daemon \   安装nrpe daemon</span><br><span class="line">&amp;&amp; make install-config     安装nrpe 配置文件</span><br><span class="line">&amp;&amp; make install-init       安装systemd文件</span><br></pre></td></tr></table></figure></li><li><p>查看配置文件<code>/usr/local/nagios/etc/nrpe.cfg</code>，若要添加监控命令，便找到以下配置，按照格式进行添加command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">command[check_users]=/usr/local/nagios/libexec/check_users -w 5 -c 10</span><br><span class="line">command[check_load]=/usr/local/nagios/libexec/check_load -r -w .15,.10,.05 -c .30,.25,.20</span><br><span class="line">command[check_hda1]=/usr/local/nagios/libexec/check_disk -w 20% -c 10% -p /dev/hda1</span><br><span class="line">command[check_zombie_procs]=/usr/local/nagios/libexec/check_procs -w 5 -c 10 -s Z</span><br><span class="line">command[check_total_procs]=/usr/local/nagios/libexec/check_procs -w 150 -c 200</span><br><span class="line"></span><br><span class="line"># command后中括号里内容就是定义的变量，名称可任意指定</span><br></pre></td></tr></table></figure></li><li><p>（可选）修改<code>/etc/services</code>，添加<code>nrpe  5666/tcp  # Nagios_client</code>。</p></li><li>启动nrpe，<code>systemctl start nrpe</code>，并使用<code>ps -ef</code>查看nrpe是否启动。</li><li><p>使用插件<code>/usr/local/nagios/libexec/check_nrpe -H localhost</code>检验nrpe是否启动成功。若成功，会输出NRPE的版本号。</p></li><li><p><strong>修改配置文件<code>/usr/local/nagios/nrpe.cfg</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#server_address=127.0.0.1      # 客户端主机IP地址</span><br><span class="line"></span><br><span class="line"># 添加监控服务器地址，声明合法的NRPE服务对象</span><br><span class="line">allowed_hosts=127.0.0.1,监控服务器地址或域名   </span><br><span class="line"># 若没有在这指定监控服务器地址，则监控服务器无法获取本机的服务信息</span><br></pre></td></tr></table></figure></li><li><p>给命令<code>nrpe</code>和配置文件<code>nrpe.cfg</code>创软链接，并以守护进程启动。<br><code>nrpe -c /etc/nrpe.cfg -d</code><br>也可通过<code>systemctl start nrpe</code>启动。</p></li><li><p>测试nrpe是否成功启动<br><code>/usr/local/nagios/libexec/check_nrpe -H 127.0.0.1</code>，输出NRPE版本号则启动成功。</p></li><li><p>测试nrpe是否能与客户端通信，同样使用<code>check_nrpe</code>指定对端IP地址或域名，输出NRPE版本号则通信正常。<br>若报错</p></li></ul><h3 id="目录与配置文件概述"><a href="#目录与配置文件概述" class="headerlink" title="目录与配置文件概述"></a>目录与配置文件概述</h3><p>在Nagios服务器端安装完后，<code>/usr/local/nagios</code>中有以下目录：<br><code>bin</code>，<code>etc</code>，<code>sbin</code>，<code>share</code>，<code>libexec</code>，<code>var</code>，<code>var/archives</code>，<code>var/rw</code>。<br>其中<code>libexec</code>是存放外部插件的。<code>share</code>是存放网页文件的。<code>var/archives</code>是存放归档日志的。<code>var/rw</code>是存放外部命令的。</p><table><thead><tr><th>配置文件或目录</th><th>说明</th></tr></thead><tbody><tr><td>cgi.cfg</td><td>控制cgi访问的配置文件</td></tr><tr><td>nagios.cfg</td><td>Nagios主配置文件</td></tr><tr><td>resource.cfg</td><td>变量定义文件</td></tr><tr><td>objects</td><td>目录，存放配置文件模板，用于定义Nagios对象</td></tr><tr><td>objects/commands.cfg</td><td>命令定义配置文件，定义的命令可悲其他配置文件使用</td></tr><tr><td>objects/contacts.cfg</td><td>定义联系人和联系人组</td></tr><tr><td>objects/localhost.cfg</td><td>定义监控本地主机</td></tr><tr><td>objects/printer.cfg</td><td>定义监控打印机，默认未开启</td></tr><tr><td>objects/switch.cfg</td><td>定义监控路由器，默认未开启</td></tr><tr><td>objects/templates.cfg</td><td>定义主机、服务，默认未开启</td></tr><tr><td>objects/timeperiods.cfg</td><td>定义监控时间段</td></tr><tr><td>objects/windows.cfg</td><td>定义windows主机，默认未开启</td></tr></tbody></table><p>Nagios配置中涉及到的定义：（建议按以下顺序配置）</p><ol><li>主机、主机组、服务、服务组</li><li>监控命令</li><li>监控时间</li><li>联系人、联系人组</li></ol><p>Nagios监控的主机资源和服务在配置文件中称为对象。<br>建议将Nagios各个定义对象创建独立的配置文件，如：</p><ul><li>创建<code>hosts.cfg</code>定义主机和主机组</li><li>创建<code>services.cfg</code>定义服务和服务组</li></ul><p>其余的对象都用默认文件即可。</p><h4 id="templates-cfg"><a href="#templates-cfg" class="headerlink" title="templates.cfg"></a>templates.cfg</h4><p>定义主机和服务的模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">define contact &#123;             # 定义联系人                    </span><br><span class="line">    name                            generic-contact         ; 联系人名</span><br><span class="line">    service_notification_period     24x7                    ; 服务通知时间，默认24x7任何时间</span><br><span class="line">    host_notification_period        24x7                    ; 主机通知时间，默认24x7任何时间</span><br><span class="line">    service_notification_options    w,u,c,r,f,s             ; 服务发送通知的状态条件</span><br><span class="line">    # w：警告warn u：未知unknown c：紧急criticle r：重新恢复recover </span><br><span class="line">    host_notification_options       d,u,r,f,s               ; 主机发送通知的状态条件</span><br><span class="line">    # d：宕机down u：未知/不可达unreachable r：重新恢复</span><br><span class="line">    service_notification_commands   notify-service-by-email ; 服务发送通知的方式</span><br><span class="line">    host_notification_commands      notify-host-by-email    ; 主机发送通知的方式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define host &#123;                # 定义主机</span><br><span class="line">    name                            generic-host            ; 主机名（对于配置文件，并非系统主机名）</span><br><span class="line">    notifications_enabled           1                       ; 是否开启主机通知，1为开启，2为不开启</span><br><span class="line">    event_handler_enabled           1                       ; 是否开启事件处理</span><br><span class="line">    flap_detection_enabled          1                       ; 是否启用报警延时</span><br><span class="line">    process_perf_data               1                       ; 是否启用数据输出</span><br><span class="line">    retain_status_information       1                       ; 是否在程序重启期间保留状态信息</span><br><span class="line">    retain_nonstatus_information    1                       ; 是否在程序重启期间保留非状态信息</span><br><span class="line">    notification_period             24x7                    ; 主机通知时间，默认任何时间</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define host &#123;                </span><br><span class="line">    name                            linux-server            ; 主机名</span><br><span class="line">    use                             generic-host            ; 引用指定的主机，此处引用了上面定义的主机的配置</span><br><span class="line">    check_period                    24x7                    ; 检查主机的时间段，默认不间断</span><br><span class="line">    check_interval                  5                       ; 检查主机的时间间隔，默认5分钟</span><br><span class="line">    retry_interval                  1                       ; 重试检查时间间隔，默认1分钟</span><br><span class="line">    max_check_attempts              10                      ; 对主机检查的最多次数。并不是检查一次就判断，而是多检查几次才判断是否故障。单位次</span><br><span class="line">    check_command                   check-host-alive        ; 默认检查命令</span><br><span class="line">    notification_period             workhours               ; 发送通知的时间段</span><br><span class="line">    notification_interval           120                     ; 发送通知的间隔，单位分钟</span><br><span class="line">    notification_options            d,u,r                   ; 发送通知的状态条件</span><br><span class="line">    contact_groups                  admins                  ; 联系人组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">后面还有对打印机、交换机的主机定义</span><br><span class="line">然后就是对服务的定义</span><br><span class="line">define service &#123;              # 定义服务</span><br><span class="line">    name                            generic-service         ; 服务名</span><br><span class="line">    active_checks_enabled           1                       ; 是否开启动态检查</span><br><span class="line">    passive_checks_enabled          1                       ; 是否开启主动检查</span><br><span class="line">    parallelize_check               1                       ; 应该并行化活动服务检查（禁用此功能可能会导致严重的性能问题）</span><br><span class="line">    obsess_over_service             1                       ; 默认为1</span><br><span class="line">    check_freshness                 0                       ; 默认为0</span><br><span class="line">    notifications_enabled           1                       ; 是否启用服务通知</span><br><span class="line">    event_handler_enabled           1                       ; 是否启用事件处理</span><br><span class="line">    flap_detection_enabled          1                       ; 是否启用报警延时</span><br><span class="line">    process_perf_data               1                       ; 是否启用数据输出</span><br><span class="line">    retain_status_information       1                       ; 是否在程序重启期间保留状态信息</span><br><span class="line">    retain_nonstatus_information    1                       ; 是否在程序重启期间保留非状态信息</span><br><span class="line">    is_volatile                     0                       ; 是否稳定，0为稳定，1为不稳定</span><br><span class="line">    check_period                    24x7                    ; 检查服务的时间段，默认不间断</span><br><span class="line">    max_check_attempts              3                       ; 对服务检查的最多次数</span><br><span class="line">    check_interval                  10                      ; 检查时间间隔，默认10分钟</span><br><span class="line">    retry_interval                  2                       ; 重试检查时间间隔，默认2分钟</span><br><span class="line">    contact_groups                  admins                  ; 联系人组</span><br><span class="line">    notification_options            w,u,c,r                 ; 发送通知的状态条件</span><br><span class="line">    notification_interval           60                      ; 发送通知的间隔，单位分钟</span><br><span class="line">    notification_period             24x7                    ; 发送通知的时间段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="resource-cfg"><a href="#resource-cfg" class="headerlink" title="resource.cfg"></a>resource.cfg</h4><p>定义变量的模板。变量需要先定义才能在别的配置文件中调用，否则nagios就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 变量$USER1$指定了nagios插件的安装路径</span><br><span class="line">$USER1$=/usr/local/nagios/libexec</span><br><span class="line"># $USER2$定义了事件处理的安装路径</span><br><span class="line">$USER2$=/usr/local/nagios/libexec/eventhandlers</span><br></pre></td></tr></table></figure></p><h4 id="Nagios宏"><a href="#Nagios宏" class="headerlink" title="Nagios宏"></a>Nagios宏</h4><p>Nagios配置有两个特征：继承与引用，在命令行定义中使用宏，通过宏，Nagios可灵活获取主机、服务等对象的信息。在命令执行前，Nagios会对命令进行宏替换。<br>宏分为：默认宏、按需而成的宏、用户自定义宏</p><ul><li><p>默认宏：主机IP地址宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define host&#123;</span><br><span class="line">    host_name        linuxbox</span><br><span class="line">    address         192.168.1.2</span><br><span class="line">    check_command    check_ping</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">define command&#123;</span><br><span class="line">    command_name     check_ping</span><br><span class="line">    command_line     /usr/local/nagios/libexec/check_ping -H $HOSTADDRESS$ -w 100.0,90% -c 200.0,60%</span><br><span class="line">&#125;</span><br><span class="line">在执行时，就会把宏替换为IP地址</span><br></pre></td></tr></table></figure></li><li><p>命令参数宏<br>向命令传递参数，参数指定在对象中定义，用一个<code>!</code>分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define service&#123;</span><br><span class="line">    host_name             linuxbox</span><br><span class="line">    service_description   PING</span><br><span class="line">    check_command         check_ping!200.0,80%!400.0,40%</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">define command&#123;</span><br><span class="line">    command_name    check_ping</span><br><span class="line">    command_line    /usr/local/nagios/libexec/check_ping -H $HOSTADDRESS$ -w $ARG1$ -c $ARG2$</span><br><span class="line">&#125;</span><br><span class="line">在执行时，会将分隔的两个参数替换到命令中的ARG1和ARG2</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：如果要在命令中使用<code>!</code>，<code>\</code>都要使用反斜杠转义</strong></p><p>Nagios可用的所有宏：</p><ul><li>主机宏<br><code>$HOSTNAME$</code>：主机名，取自主机定义中<code>host_name</code><br><code>$HOSTADDRESS$</code>：主机IP地址，取自主机定义中<code>address</code></li><li>服务宏<br><code>$SERVICESTATE$</code>：服务状态描述，三个可能：<code>w</code>，<code>u</code>，<code>c</code><br><code>$SERVICEDESC$</code>：对当前服务的描述</li><li>联系人宏<br><code>$CONTACTNAME$</code>：联系人名，在联系人文件中定义</li><li>通知宏<br><code>$NOTIFICATIONTYPE$</code>：返回状态信息。</li><li>日期宏<br><code>$LONGDATETIME$</code>：当前日期，时间戳</li><li>文件宏<br><code>$LOGFILE$</code>：日志文件保存位置<br><code>$MAINCONFIGFILE</code>：主配置文件保存位置</li><li>其他宏<br><code>$ADMINMAIL$</code>：管理员E-mail地址<br><code>$ARGn$</code>：第n个命令参数，n是数字。最多支持32个参数宏。</li></ul><h4 id="commands-cfg"><a href="#commands-cfg" class="headerlink" title="commands.cfg"></a>commands.cfg</h4><p>定义命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define command &#123;</span><br><span class="line">    command_name    check-host-alive      # 命令名</span><br><span class="line">    # 命令执行</span><br><span class="line">    command_line    $USER1$/check_ping -H $HOSTADDRESS$ -w 3000.0,80% -c 5000.0,100% -p 5</span><br><span class="line">    # 调用插件check_ping，-w为warning警告状态，-c为紧急，80%表示ping的临界值。-p 5表示每次发5个ping包</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="hosts-cfg"><a href="#hosts-cfg" class="headerlink" title="hosts.cfg"></a>hosts.cfg</h4><p>默认不存在，定义主机。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define host &#123;</span><br><span class="line">use           linux-server    # 引用templates.cfg中linux-server的配置</span><br><span class="line">host_name     web             # 主机名</span><br><span class="line">alias         web-system5     # 别名</span><br><span class="line">address       192.168.163.137 # IP地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define hostgroup &#123;</span><br><span class="line">hostgroup_name    web-servers # 主机组名</span><br><span class="line">alias             web-servers # 别名</span><br><span class="line">members           web         # 组成员（填host_name，逗号分隔）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="services-cfg"><a href="#services-cfg" class="headerlink" title="services.cfg"></a>services.cfg</h4><p>默认不存在，定义服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">define service &#123;</span><br><span class="line">use                    local-service  # 引用templates.cfg中local-service的配置</span><br><span class="line">host_name              web   # 主机名</span><br><span class="line">service_description    ping  # 服务描述</span><br><span class="line">check command          check_ping.....  #引用命令</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define servicegroup &#123;     # 服务组，配置类似主机组</span><br><span class="line">servicegroup_name        </span><br><span class="line">alias                    </span><br><span class="line">members               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="contacts-cfg"><a href="#contacts-cfg" class="headerlink" title="contacts.cfg"></a>contacts.cfg</h4><p>定义联系人。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define contact &#123;</span><br><span class="line">contact_name     # 联系人名</span><br><span class="line">use              # 使用templates.cfg中指定模板信息</span><br><span class="line">alias            </span><br><span class="line">email            # 联系人邮箱</span><br><span class="line">&#125;</span><br><span class="line">define contactgroup &#123;</span><br><span class="line">contactgroup_name    # 联系人组名</span><br><span class="line">alias</span><br><span class="line">members</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="timeperiods-cfg"><a href="#timeperiods-cfg" class="headerlink" title="timeperiods.cfg"></a>timeperiods.cfg</h4><p>定义监控时段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">define timeperiod &#123;</span><br><span class="line"></span><br><span class="line">    name                    24x7     #定义时段名</span><br><span class="line"># 之前host和service中的24x7就是引用这里定义的时段名</span><br><span class="line">    timeperiod_name         24x7</span><br><span class="line">    alias                   24 Hours A Day, 7 Days A Week</span><br><span class="line">    # 定义监控时间，若某天不监控则不要写那天</span><br><span class="line">    sunday                  00:00-24:00   </span><br><span class="line">    monday                  00:00-24:00</span><br><span class="line">    tuesday                 00:00-24:00</span><br><span class="line">    wednesday               00:00-24:00</span><br><span class="line">    thursday                00:00-24:00</span><br><span class="line">    friday                  00:00-24:00</span><br><span class="line">    saturday                00:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="cgi-cfg"><a href="#cgi-cfg" class="headerlink" title="cgi.cfg"></a>cgi.cfg</h4><p>控制cgi脚本。用于在web界面执行cgi脚本，如重启nagios进程、关闭通知、停止检测等。<br>以下为修改权限涉及的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">default_user_name=guest</span><br><span class="line">authorized_for_system_information=nagiosadmin          # 验证系统信息</span><br><span class="line">authorized_for_configuration_information=nagiosadmin   # 验证配置信息</span><br><span class="line">authorized_for_system_commands=nagiosadmin             # 验证系统命令</span><br><span class="line">authorized_for_all_services=nagiosadmin                # 验证所有服务</span><br><span class="line">authorized_for_all_hosts=nagiosadmin                   # 验证所有主机</span><br><span class="line">authorized_for_all_service_commands=nagiosadmin        # 验证所有服务命令</span><br><span class="line">authorized_for_all_host_commands=nagiosadmin           # 验证所有主机命令</span><br></pre></td></tr></table></figure></p><h4 id="nagios-cfg"><a href="#nagios-cfg" class="headerlink" title="nagios.cfg"></a>nagios.cfg</h4><p>Nagios的核心配置文件，所有配置文件必须在此文件中引用才有作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">log_file=/usr/local/nagios/var/nagios.log             # 日志文件路径</span><br><span class="line"></span><br><span class="line">cfg_file=/usr/local/nagios/etc/objects/commands.cfg</span><br><span class="line">cfg_file=/usr/local/nagios/etc/objects/contacts.cfg</span><br><span class="line">cfg_file=/usr/local/nagios/etc/objects/timeperiods.cfg</span><br><span class="line">cfg_file=/usr/local/nagios/etc/objects/templates.cfg</span><br><span class="line">cfg_file=/usr/local/nagios/etc/objects/localhost.cfg</span><br><span class="line"># 继续添加配置文件即可启用指定配置文件。</span><br><span class="line"># 也可以直接将文件放入一个目录，然后通过cfg_dir=指定</span><br><span class="line"></span><br><span class="line">object_cache_file=/usr/local/nagios/var/objects.cache  # 指定一个所有对象配置文件的副本文件，也称为对象缓冲文件。</span><br><span class="line"># nagios会将所有对象文件的内容都写入该文件</span><br><span class="line"></span><br><span class="line">resource_file=/usr/local/nagios/etc/resource.cfg  # 指定nagios资源文件的路径，可在nagios.cfg定义多个资源文件</span><br><span class="line">status_file=/usr/local/nagios/var/status.dat  # 指定状态文件，用于保存nagios当前状态、注释、宕机信息等</span><br><span class="line">status_update_interval=10  # 状态文件的更新周期，单位秒，最小1秒</span><br><span class="line">nagios_user=nagios   # nagios进程所属用户</span><br><span class="line">nagios_group=nagios  # nagios进程所属用户组</span><br><span class="line">check_external_commands=1  # 是否允许nagios在web界面执行cgi命令</span><br><span class="line">interval_length=60  # 指定nagios时间单位，默认60s，即nagios配置中所有 时间单位为分钟</span><br></pre></td></tr></table></figure></p><h3 id="Nagios监控界面解析"><a href="#Nagios监控界面解析" class="headerlink" title="Nagios监控界面解析"></a>Nagios监控界面解析</h3><p>左侧菜单栏中<code>Current Status</code>目录如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Tactical Overview    总览</span><br><span class="line">Map                  拓扑图</span><br><span class="line">Hosts                主机</span><br><span class="line">Services             服务</span><br><span class="line">Host Groups          主机组</span><br><span class="line">- Summary            汇总</span><br><span class="line">- Grid               表格</span><br><span class="line">Service Groups       服务组，也分为汇总和表格</span><br><span class="line">Problems             问题故障</span><br><span class="line">- Service(Unhandled) 未解决的服务故障</span><br><span class="line">- Hosts(Unhandled)   未解决的主机故障</span><br><span class="line">- Network Outages    网络整体</span><br></pre></td></tr></table></figure></p><p><code>Reports</code>目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Availability         可用性</span><br><span class="line">Trends               趋势</span><br><span class="line">Alerts               报警</span><br><span class="line">- History            历史</span><br><span class="line">- Summary            汇总</span><br><span class="line">- Histogram          历史图</span><br><span class="line">Notification         通知</span><br><span class="line">Event Log            事件日志</span><br></pre></td></tr></table></figure></p><p><code>System</code>目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comments             注释</span><br><span class="line">Downtime             停机计划</span><br><span class="line">Process Info         进程信息</span><br><span class="line">Performance Info     性能查询</span><br><span class="line">Scheduling Queue     定时查询</span><br><span class="line">Configuration        配置</span><br></pre></td></tr></table></figure></p><h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>Nagios对主机和服务有几个描述的状态</p><ul><li>Hosts<ul><li>Up启动（绿）</li><li>Down未启动（红）</li><li>Unreachable不可达（黄）</li><li>Pending等待（灰色）</li></ul></li><li>Services<ul><li>Ok正常（绿）</li><li>Warning警告（黄）</li><li>Unknown未知（橙）</li><li>Critical紧急（红）</li><li>Pending等待（灰）</li></ul></li></ul><h3 id="Nagios性能分析图表"><a href="#Nagios性能分析图表" class="headerlink" title="Nagios性能分析图表"></a>Nagios性能分析图表</h3><ul><li>需要安装<code>pnp</code>软件包，基于PHP和Perl，利用rrdtool工具将nagios收集的数据绘制成图表。<a href="https://docs.pnp4nagios.org/" target="_blank" rel="noopener"><strong>pnp官网</strong></a><br>首先，需要安装<code>gd</code>库、<code>zlib</code>库、<code>jpeg</code>库<br><code>yum install gd gd-devel zlib zlib-devel jpeg*</code><br>接着安装<code>rrdtool</code>工具<br><code>yum install rrdtool*</code><br>安装<code>perl</code>环境<br><code>yum install perl</code><br>最后去pnp官网下载源码包安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">./configure \</span><br><span class="line">  --with-nagios-user=nagios \</span><br><span class="line">  --with-nagios-group=nagios \</span><br><span class="line">  --with-rrdtool=/usr/bin/rrdtool \</span><br><span class="line">  --with-perfdata-dir=/usr/local/nagios/share/perfdata</span><br><span class="line">make all \</span><br><span class="line">  &amp;&amp; make install \</span><br><span class="line">  &amp;&amp; make install-config \</span><br><span class="line">  &amp;&amp; make install-init \</span><br><span class="line">  &amp;&amp; make install-webconf</span><br><span class="line">或者直接make fullinstall（包含以上所有make）</span><br><span class="line"></span><br><span class="line">  General Options:</span><br><span class="line">  -------------------------         -------------------</span><br><span class="line">  Nagios user/group:                nagios nagios</span><br><span class="line">  Install directory:                /usr/local/pnp4nagios</span><br><span class="line">  HTML Dir:                         /usr/local/pnp4nagios/share</span><br><span class="line">  Config Dir:                       /usr/local/pnp4nagios/etc</span><br><span class="line">  Location of rrdtool binary:       /usr/bin/rrdtool Version 1.7.0</span><br><span class="line">  RRDs Perl Modules:                FOUND (Version 1.6999)</span><br><span class="line">  RRD Files stored in:              /usr/local/nagios/share/perfdata</span><br><span class="line">  process_perfdata.pl Logfile:      /usr/local/pnp4nagios/var/perfdata.log</span><br><span class="line">  Perfdata files (NPCD) stored in:  /usr/local/pnp4nagios/var/spool</span><br><span class="line"></span><br><span class="line">  Web Interface Options:</span><br><span class="line">  -------------------------         -------------------</span><br><span class="line">  HTML URL:                         http://localhost/pnp4nagios</span><br><span class="line">  Apache Config File:               /etc/httpd/conf.d/pnp4nagios.conf</span><br></pre></td></tr></table></figure></li></ul><p>安装完后，将<code>/usr/local/pnp4nagios</code>的所有者和所属组都改为nagios</p><ul><li>配置pnp<br>将<code>/usr/local/pnp4nagios/share</code>目录下所有文件复制到<code>/usr/local/nagios/share/pnp</code>中。<br>将<code>/usr/local/pnp4nagios/etc</code>中<code>npcd.cfg</code>、<code>rra.cfg</code>、<code>process_perfdata.cfg</code>后面的<code>-sample</code>去除（如果有的话）。</li></ul><p>首先修改<code>process_perfdata.cfg</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 指定日志路径</span><br><span class="line">LOG_FILE = /usr/local/pnp4nagios/var/perfdata.log</span><br><span class="line"># 日志输出级别，默认为0，最好改为2，即debug</span><br><span class="line">LOG_LEVEL = 2</span><br><span class="line"># 三个等级：0==slient 1==normal 2==debug</span><br></pre></td></tr></table></figure></p><p>然后将pnp与nagios进行整合，对templcates.cfg配置，添加以下定义。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">define host &#123;</span><br><span class="line">    name                  hosts-pnp</span><br><span class="line">    register              0</span><br><span class="line">    action_url            /nagios/pnp/index.php?host=$HOSTNAME$</span><br><span class="line">    process_perf_data     1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define service &#123;</span><br><span class="line">    name                  services-pnp</span><br><span class="line">    register              0</span><br><span class="line">    action_url            /nagios/pnp/index.php?host=$HOSTNAME$&amp;srv=$SERVICEDESC$</span><br><span class="line">    process_perf_data     1</span><br><span class="line">&#125;</span><br><span class="line"># 注：必须在不应处理其性能数据的每个主机或服务的定义中禁用数据处理（process_perf_data 设为0）。</span><br></pre></td></tr></table></figure></p><p>然后在<code>hosts.cfg</code>和<code>services.cfg</code>和<code>localhost.cfg</code>中要进行数据分析的服务或主机的<code>name</code>参数后加上<code>hosts-pnp</code>或<code>service-pnp</code>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define service &#123;</span><br><span class="line">use                    local-service,serviecs-pnp</span><br><span class="line">host_name              web</span><br><span class="line">service_description    ping</span><br><span class="line">check command          check_ping..... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改nagios.cfg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 开启Nagios数据输出。会将收集到的数据写入文件</span><br><span class="line">process_performance_data=1</span><br><span class="line"></span><br><span class="line"># 取消注释，启用主机和服务的输出功能</span><br><span class="line">host_perfdata_command=process-host-perfdata </span><br><span class="line">service_perfdata_command=process-service-perfdata</span><br><span class="line"></span><br><span class="line">host_perfdata_file=/usr/local/pnp4nagios/var/host-perfdata</span><br><span class="line">service_perfdata_file=/usr/local/pnp4nagios/var/service-perfdata</span><br><span class="line"></span><br><span class="line">host_perfdata_file_template=[HOSTPERFDATA]\t$TIMET$\t$HOSTNAME$\t$HOSTEXECUTIONTIME$\t$HOSTOUTPUT$\t$HOSTPERFDATA$</span><br><span class="line">service_perfdata_file_template=[SERVICEPERFDATA]\t$TIMET$\t$HOSTNAME$\t$SERVICEDESC$\t$SERVICEEXECUTIONTIME$\t$SERVICELATENCY$\t$SERVICEOUTPUT$\t$SERVICEPERFDATA$</span><br><span class="line"></span><br><span class="line">host_perfdata_file_mode=a</span><br><span class="line">service_perfdata_file_mode=a</span><br><span class="line"></span><br><span class="line">host_perfdata_file_processing_interval=0</span><br><span class="line">service_perfdata_file_processing_interval=0</span><br><span class="line"></span><br><span class="line">host_perfdata_file_processing_command=process-host-perfdata-file</span><br><span class="line">service_perfdata_file_processing_command=process-service-perfdata-file</span><br></pre></td></tr></table></figure></p><p>修改commands.cfg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define command &#123;</span><br><span class="line">    command_name    process-host-perfdata-file</span><br><span class="line">    # 将原来的command_line注释，改为如下参数</span><br><span class="line">    command_line    /usr/local/pnp4nagios/libexec/process_perfdata.pl --bulk=/usr/local/pnp4nagios/var/host-perfdata</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define command &#123;</span><br><span class="line">    command_name    process-service-perfdata-file</span><br><span class="line">    # 将原来的command_line注释，改为如下参数</span><br><span class="line">    command_line    /usr/local/pnp4nagios/libexec/process_perfdata.pl --bulk=/usr/local/pnp4nagios/var/service-perfdata</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>重启nagios和httpd<br>进入web端，点击左侧菜单<code>services</code>。进入如下页面<br><img src="/2018/05/31/Nagios监控搭建/services.png"></p><p>点击红框框出的图标，即可进入pnp测试界面<br><img src="/2018/05/31/Nagios监控搭建/pnp-success.png"></p><p>若全部通过，便会提示删除或重命名<code>/usr/local/nagios/share/pnp/install.php</code>。于是将该php文件删除。<code>rm -f /usr/local/nagios/share/pnp/install.php</code></p><p>如果在点击pnp图标时，出现以下报错：</p><img src="/2018/05/31/Nagios监控搭建/1.png"><p>则需要检查<code>nagios.cfg</code>和<code>commands.cfg</code>配置文件，查看<code>commands.cfg</code>配置可知<code>command_name</code>为<code>process-host-perfdata</code>的默认存放路径<code>bulk</code>为<code>/usr/local/pnp4nagios/var/host-perfdata</code>，同理，<code>process-service-perfdata</code>的存放路径为<code>/usr/local/pnp4nagios/var/service-perfdata</code>。</p><p>而在<code>nagios.cfg</code>中<code>host_perfdata_file</code>默认路径为<code>/usr/local/nagios/var/host-perfdata</code>，<code>service_perfdata_file</code>默认路径为<code>/usr/local/nagios/var/service-perfdata</code>，两个文件不一致，导致pnp4nagios无法获取。</p><p>将<code>nagios.cfg</code>的两条配置，改为与<code>commands.cfg</code>的一致即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host_perfdata_file=/usr/local/pnp4nagios/var/host-perfdata</span><br><span class="line">service_perfdata_file=/usr/local/pnp4nagios/var/service-perfdata</span><br></pre></td></tr></table></figure><h3 id="邮件告警配置"><a href="#邮件告警配置" class="headerlink" title="邮件告警配置"></a>邮件告警配置</h3><p>先安装sendmail或postfix，安装完后开启。本篇使用sendmail服务。<br>使用<code>mail</code>命令发送测试邮件。若没有mail命令，需要先下载<code>mailx</code>软件<br><code>mail -s test XXXX@XX.com</code>输入内容完后<code>ctrl+d</code>结束。</p><p>关于邮件告警主要涉及以下几个文件：</p><ul><li><p><code>templates.cfg</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">其中有关于contact的定义</span><br><span class="line">define contact &#123;</span><br><span class="line">    name                            generic-contact         </span><br><span class="line">    service_notification_period     24x7                    </span><br><span class="line">    host_notification_period        24x7                    </span><br><span class="line">    service_notification_options    w,u,c,r,f,s             </span><br><span class="line">    host_notification_options       d,u,r,f,s               </span><br><span class="line">    service_notification_commands   notify-service-by-email </span><br><span class="line">    host_notification_commands      notify-host-by-email    </span><br><span class="line">    register                        0                       </span><br><span class="line">&#125;</span><br><span class="line"># 发送服务通知使用的是notify-service-by-email命令</span><br><span class="line">  发送主机同时使用的是notify-host-by-email命令</span><br></pre></td></tr></table></figure></li><li><p>于是查找<code>commands.cfg</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果不成功，一定要注意到此文件中发送通知的命令</span><br><span class="line">默认使用sendmail命令，若主机没有就不可能发送成功。</span><br><span class="line">需要替换为mail或mailx。还要注意这两个命令的目录，是/bin还是/sbin</span><br><span class="line">define command &#123;</span><br><span class="line">    command_name    notify-host-by-email</span><br><span class="line">    command_line    /usr/bin/printf &quot;%b&quot; &quot;***** Nagios *****\n\nNotification Type: $NOTIFICATIONTYPE$\nHost: $HOSTNAME$\nState: $HOSTSTATE$\nAddress: $HOSTADDRESS$\nInfo: $HOSTOUTPUT$\n\nDate/Time: $LONGDATETIME$\n&quot; | /usr/bin/mail -s &quot;** $NOTIFICATIONTYPE$ Host Alert: $HOSTNAME$ is $HOSTSTATE$ **&quot; $CONTACTEMAIL$</span><br><span class="line">&#125;</span><br><span class="line">define command &#123;</span><br><span class="line">    command_name    notify-service-by-email</span><br><span class="line">    command_line    /usr/bin/printf &quot;%b&quot; &quot;***** Nagios *****\n\nNotification Type: $NOTIFICATIONTYPE$\n\nService: $SERVICEDESC$\nHost: $HOSTALIAS$\nAddress: $HOSTADDRESS$\nState: $SERVICESTATE$\n\nDate/Time: $LONGDATETIME$\n\nAdditional Info:\n\n$SERVICEOUTPUT$\n&quot; | /usr/bin/mail -s &quot;** $NOTIFICATIONTYPE$ Service Alert: $HOSTALIAS$/$SERVICEDESC$ is $SERVICESTATE$ **&quot; $CONTACTEMAIL$</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后通过<code>contacts.cfg</code>设置联系人，在email中填写自己的邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define contact &#123;</span><br><span class="line">    contact_name            nagiosadmin             </span><br><span class="line">    use                     generic-contact         </span><br><span class="line">    alias                   Nagios Admin            </span><br><span class="line">    email                   XXXX@XX.com</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当服务出现重启或故障时，系统会自动发送邮件。</p><img src="/2018/05/31/Nagios监控搭建/youjian.png"></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.cnblogs.com/zhangsubai/p/5732081.html" target="_blank" rel="noopener">Nagios配置安装详解</a><br><a href="http://wiki.jikexueyuan.com/project/linux/nagios.html" target="_blank" rel="noopener">使用 Nagios 搭建监控服务器</a><br><a href="https://library.nagios.com/library/products/nagios-core/documentation/" target="_blank" rel="noopener">Nagios官方文档</a><br><a href="https://docs.pnp4nagios.org/pnp-0.6/config" target="_blank" rel="noopener">Pnp官方配置文档</a><br><a href="https://www.ibm.com/developerworks/cn/linux/1309_luojun_nagios/" target="_blank" rel="noopener">Nagios 监控系统架设全攻略</a><br><a href="https://blog.csdn.net/kepa520/article/details/48541771" target="_blank" rel="noopener">CentOS7安装nagios并配置出图详解</a><br><a href="https://www.cnblogs.com/lixj3/p/7876077.html" target="_blank" rel="noopener">2017年11月最新Nagios4.3.4部署</a><br>高性能Linux服务器构建实战：运维监控、性能调优与集群应用</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
            <tag> Nagios </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ansible基础学习笔记</title>
      <link href="/2018/05/28/Ansible%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/28/Ansible%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下内容</p><ul><li><a href="#Ansible结构">Ansible结构</a></li><li><a href="#Ansible安装">Ansible安装</a></li><li><a href="#Inventory">Inventory</a></li><li><a href="#Ansible常见模块">Ansible常见模块</a></li><li><a href="#Playbook">Playbook</a><a id="more"></a></li><li><a href="#Ansible变量">Ansible变量</a></li><li><a href="#Jinja2过滤器">Jinja2过滤器</a></li></ul><p>Ansible是一个部署一群远程主机的工具，使用SSH实现管理节点和远程节点间的通信，实现批量自动化操作。</p><img src="/2018/05/28/Ansible学习笔记/0.png"><p>Ansible有企业版本的收费软件Ansible Tower，中心化的Ansible管理节点，向管理员提供web接口。实现：1. 管理员在Ansible Tower上使用分享主机的SSH密钥，但不能查看和复制私钥  2. Ansible的web上的所有管理员都可共享Playbook脚本  3. Ansible Tower可收集展示所有主机的Playbook执行情况。</p><p>Ansible Tower提供了一个数据库来存储inventory配置信息，这个数据库可以通过web访问，或通过REST访问。Tower与所有使用的Ansible动态inventory源保持同步，并提供了一个图形化的inventory编辑器。 </p><h1 id="Ansible结构"><a href="#Ansible结构" class="headerlink" title="Ansible结构"></a>Ansible结构</h1><p>Ansible具有以下核心组件：</p><ul><li>ansible core：ansible核心程序</li><li>Host Inventory：主机信息文件</li><li>Playbooks：剧本，用于简便管理主机</li><li>Core Modules：核心模块，Ansible通过模块进行管理</li><li>Custom Modules：自定义模块，补充核心模块的功能</li><li>Connection Plugins：连接插件，用于Ansible和主机的通信</li><li>Plugins：其他各种插件，提供连接或功能接口</li></ul><img src="/2018/05/28/Ansible学习笔记/jiegou.png"><p>Ansible特性：</p><ul><li>基于Python实现，有三个关键模块：Paramiko（ssh连接插件）、PyYAML（YAML语言）、jinja2（定义模板，即Playbook）</li><li>部署简单，轻量级，无需在客户端安装agent，去中心化</li><li>默认使用SSH。1.基于密钥 2.在inventory文件指定密码</li><li>支持自定义模块，支持各种编程语言</li><li>主从模式master和slave</li><li>使用playbook进行主机管理</li><li>幂等性：一种操作重复多次结果相同，只需运行一次playbook就可将需要配置的机器都置为期望状态，同一台机器多次执行一个playbook是安全的</li><li>Ansible是模块化的，通过调用模块来实现管理</li><li>支持多层部署，可通过VM和容器为多层应用程序的部署配置提供支持</li><li>为架构的多个层次带来一致性，借助Ansible可通过编程操作计算架构中从基础设施到应用程序的每一层</li><li>Ansible支持异构IT环境，支持Windows和Linux及多个硬件平台和云平台</li></ul><img src="/2018/05/28/Ansible学习笔记/liucheng.png"><p><strong>实验系统CentOS-7</strong><br><strong>主节点服务器：192.168.163.102</strong><br><strong>从节点服务器：192.168.163.103</strong></p><h1 id="Ansible安装"><a href="#Ansible安装" class="headerlink" title="Ansible安装"></a>Ansible安装</h1><p>首先安装epel-release，能够获得更多的Ansible包资源。  <code>yum install epel-release</code><br>然后安装Ansible  <code>yum install ansible</code></p><p>Ansible有以下配置文件：</p><ul><li><code>/etc/ansible/ansible.cfg</code>  主配置文件</li><li><code>/etc/ansible/hosts</code>  Inventory配置文件</li></ul><p>Ansible配置以ini格式存储数据，Ansible几乎所有配置都可通过Playbook或环境变量重新赋值。当运行Ansible命令时，会按照以下顺序查找并读取配置文件。</p><ol><li><code>ANSIBLE_CONFIG</code>：环境变量指定的路径</li><li><code>./ansible.cfg</code>：当前目录的ansible.cfg配置文件</li><li><code>~/ansible.cfg</code>：家目录的ansible.cfg配置文件</li><li><code>/etc/ansible/ansible.cfg</code>：ansible主配置文件</li></ol><p>Ansible主配置文件中的几个重要参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">inventory = /root/ansible/hosts   # inventory文件的位置</span><br><span class="line">library = /usr/share/my_modules/  # ansible模块位置</span><br><span class="line">forks = 5           # 默认情况下Ansible最多能有多少个进程同时工作，默认5个进程并行处理。</span><br><span class="line">                    # 可以根据控制端性能和被管理节点的数量来确定</span><br><span class="line">sudo_user = root    # 默认执行命令的用户</span><br><span class="line">remote_port = 22    # 指定连接被管理节点的管理端口，默认是22</span><br><span class="line">host_key_checking = False  # 是否检查SSH主机的密钥</span><br><span class="line">timeout = 20        # SSH连接的超时间隔，单位：秒</span><br><span class="line">log_path = /var/log/ansible.log   # Ansible默认不记录日志</span><br><span class="line"># 若开启了日志，则要通过该参数设置日志文件路径</span><br><span class="line"># 模块将会调用被管节点的rsyslog来记录，执行Ansible的用户需要有写入日志的权限</span><br><span class="line">remote_tmp     = ~/.ansible/tmp     # 远程主机的临时文件存放位置</span><br><span class="line">local_tmp      = ~/.ansible/tmp     # 本机的临时文件存放位置</span><br></pre></td></tr></table></figure></p><p>Ansible提供文档命令可查看指定的用法说明<br><code>ansible-doc</code>命令用于查看Ansible帮助文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-h 查看帮助</span><br><span class="line">-l 列出所有Ansible模块</span><br><span class="line">-s &lt;module&gt; 查找指定模块的用法</span><br></pre></td></tr></table></figure></p><p><strong>公钥认证</strong><br>Ansible默认开启公钥认证，Ansible主节点应该与所有要管理的节点进行ssh验证。主要使用以下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen  创建密钥对</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub root@&lt;节点IP地址&gt;</span><br></pre></td></tr></table></figure></p><p>然后在<code>/etc/ansible/hosts</code>添加该节点的IP地址</p><p>如果有个主机重新安装并在<code>/home/.ssh/known_hosts</code>文件中中有了不同的key，就会一直提示错误。<br>若节点主机未进行公钥认证，即没有在该文件中初始化，则每次使用ansible命令时都会要求确认key信息。</p><p>若要禁用ansible确认密钥的行为，可在主配置文件中参数<code>host_key_checking = False</code>设置，也可以通过环境变量<code>ANSIBLE_HOST_KEY_CHECKING=False</code>设置。</p><p><strong>ansible主命令</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ansible  &lt;host-pattern&gt; [options]</span><br><span class="line"># host-pattern可填inventory的组名，ip地址，all（所有主机）</span><br><span class="line"># 一些简单常用参数</span><br><span class="line">-f 设置一次处理的主机个数，即并行执行</span><br><span class="line">-m 设置使用的模块</span><br><span class="line">-a 模块的参数</span><br><span class="line">-i 指定inventory文件</span><br></pre></td></tr></table></figure></p><h1 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a>Inventory</h1><p>Ansible可同时操作属于一个组的多台主机,组和主机之间的关系通过inventory文件配置，默认的文件路径为<code>/etc/ansible/hosts</code>。<br>inventory文件遵循INI文件风格，方括号[]中是组名,用于对系统进行分类,便于对不同系统进行个别的管理。一个系统可以属于不同的组，属于两个组的变量都可以为这台主机所用。组名可自定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 可以直接写要管理的主机IP地址或域名</span><br><span class="line">192.168.163.103</span><br><span class="line"></span><br><span class="line">#也可设置管理组</span><br><span class="line">[test]</span><br><span class="line">192.168.163.103</span><br><span class="line">system[1:5].example.com</span><br><span class="line"># 数字简写模式，表示system1--sysetm5</span><br><span class="line"># 也支持字母简写，system[a:f].example.com</span><br><span class="line"></span><br><span class="line"># 可对每个服务器设置连接类型和连接用户名</span><br><span class="line">localhost  ansible_connection=local</span><br><span class="line">system3.example.com  ansible_connection=ssh  ansible_ssh_user=ansible</span><br><span class="line"></span><br><span class="line"># 可定义变量，可使用变量定义的配置主机变量</span><br><span class="line">host1  http_port=80  maxRequestsPerChild=808</span><br><span class="line"># 也可定义组变量</span><br><span class="line">[test:vars]</span><br><span class="line">ntp_server=ntp.example.com</span><br><span class="line"></span><br><span class="line"># 还可组嵌套，即在其他组中引用一个组</span><br><span class="line"># 这些变量可以给ansible-playbook使用,但不能给ansible使用。</span><br><span class="line">[team1]</span><br><span class="line">host1</span><br><span class="line">[team2]</span><br><span class="line">host2</span><br><span class="line">[test:hosts]</span><br><span class="line">team1</span><br><span class="line">team2</span><br></pre></td></tr></table></figure><p>当Inventory中存在有效主机时，ansible就默认隐式地可以使用<code>localhost</code>作为本机，但inventory中没有任何主机时是不允许使用它的，且<code>all</code>或<code>*</code>所代表的所有主机也不会包含localhost。</p><p>一些常见的Inventory参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ansible_ssh_host    # ansible使用ssh要连接的主机</span><br><span class="line">ansible_ssh_port    # ssh的端口。默认为22</span><br><span class="line">ansible_ssh_user    # ssh登录的用户名。默认为root</span><br><span class="line">ansible_ssh_pass    # ssh登录远程用户时的认证密码</span><br><span class="line"># 不安全，最好使用 --ask-pass</span><br><span class="line">ansible_sudo_pass   # sudo命令输入的root密码（当使用非root用户操作时）</span><br><span class="line"># 不安全，最好使用 --ask-sudo-pass</span><br><span class="line">ansible_connection   # 连接远程主机使用的模式，默认为smart智能模式</span><br><span class="line"># smart：若本地ssh支持持久连接时采用ssh连接，否则采用python的paramiko ssh连接</span><br><span class="line"># paramiko：python的ssh连接库</span><br><span class="line">ansible_ssh_private_key_file   # ssh登录远程用户时的认证私钥文件</span><br><span class="line">ansible_ssh_common_args      # 指定ssh、scp等命令的参数</span><br><span class="line">ansible_shell_type  # 指定远程主机执行命令时的shell解析器，默认为sh</span><br><span class="line">ansible_python_interpreter   # 远程主机上的python解释器路径。默认为/usr/bin/python</span><br></pre></td></tr></table></figure></p><p><strong>Inventory配置文件可以有多个，且可以通过Dynamic Inventory来动态生成</strong><br>只需在ansible的主配置文件中将<code>inventory</code>参数设置为对应的文件或目录即可，如果是目录，那么此目录下的所有文件都是inventory文件。</p><p>可创建多个独立文件用于保存变量，然后在主文件中引用<br><strong>注：这些独立文件的格式为YAML</strong><br>在独立文件<code>/etc/ansible/group_vars/servers</code>中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">ntp_server: ntp.example.com</span><br><span class="line">database_server: system2.example.com</span><br></pre></td></tr></table></figure><p>然后在inventory文件中指定该文件<code>/etc/ansible/group_vars/servers</code><br>可以为一个主机，或一个组，创建一个目录，目录名就是主机名或组名。目录中的可以创建多个文件，文件中的变量都会被读取为主机或组的变量。</p><h1 id="Ansible常见模块"><a href="#Ansible常见模块" class="headerlink" title="Ansible常见模块"></a>Ansible常见模块</h1><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cron 计划任务模块</span><br><span class="line">month         # 指定月份</span><br><span class="line">minute        # 指定分钟</span><br><span class="line">job           # 指定任务（需要state=present）</span><br><span class="line">day           # 指定小时</span><br><span class="line">hour          # 指定小时</span><br><span class="line">weekday       # 周几</span><br><span class="line">name          # 指定名称（默认为*）</span><br><span class="line">user          # 使用的用户身份去执行</span><br><span class="line">special_time  # 指定执行的时间</span><br><span class="line">reboot        # 重启时</span><br><span class="line">yearly        # 每年</span><br><span class="line"># 还有annually  monthly  weekly  daily  hourly</span><br><span class="line">state         # 添加或删除</span><br><span class="line">present       # 安装</span><br><span class="line">absent        # 移除</span><br><span class="line">backup        # 对远程主机上原有任务计划做备份</span><br><span class="line">cron_file     # 使用指定文件替换远程主机上/etc/cron.d/中的任务计划</span><br><span class="line"></span><br><span class="line">例：ansible webserver -m cron -a &apos; minute=&quot;*/10&quot; job=&quot;/bin/echo hello&quot; name=&quot;test&quot; state=present &apos;</span><br></pre></td></tr></table></figure><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">user 用户账号管理</span><br><span class="line">name         # 用户名</span><br><span class="line">uid          # UID</span><br><span class="line">state        # 状态</span><br><span class="line">present      # 添加</span><br><span class="line">absent       # 移除</span><br><span class="line">password     # 设置密码</span><br><span class="line">group        # 所属组</span><br><span class="line">groups       # 附加组（用逗号分隔）</span><br><span class="line">home         # 家目录</span><br><span class="line">createhome   # 是否创建家目录</span><br><span class="line">comment      # 注释</span><br><span class="line">system       # 是否设为系统用户</span><br><span class="line">generate_ssh_key=yes        # 是否加密密码</span><br><span class="line">ssh_key_bits=2048           # 加密密钥长度</span><br><span class="line">ssh_key_file=.ssh/id_rsa    # 密码文件</span><br><span class="line">注：指定password参数时，不能使用后面这一串密码会被直接传送到被管理主机的/etc/shadow文件中，所以需要先将密码字符串进行加密处理。然后将得到的字符串放到password中即可。</span><br><span class="line">默认加密方式是根据/etc/login.defs的ENCRYPT_METHOD指定，默认为SHA512</span><br></pre></td></tr></table></figure><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">group 组管理</span><br><span class="line">gid      # GID</span><br><span class="line">name     # 组名</span><br><span class="line">state    # 状态</span><br><span class="line">system   # 是否是系统组</span><br></pre></td></tr></table></figure><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">copy 复制文件，类似scp，需要关闭所有机器的selinux，否则会报错</span><br><span class="line">src      # 本地源路径</span><br><span class="line">dest     # 远程主机目标路径</span><br><span class="line">owner    # 指定拥有者</span><br><span class="line">group    # 指定所属组</span><br><span class="line">mode     # 设置权限</span><br><span class="line">content  # 取代src=，表示直接用此处信息生成文件内容</span><br><span class="line">backup   # 在覆盖前备份原文件，两个选项（yes | no）</span><br><span class="line">directory_mode    # 递归设置目录权限，默认为系统默认权限</span><br><span class="line">force  # 用于设置当目标主机包含该文件，但内容不同时的操作</span><br><span class="line">       # 若设置为yes，则强制覆盖，若为no，则只有当目标主机的目标位置不存在该文件时，才复制。</span><br><span class="line">       # 默认为yes</span><br><span class="line"># 所有的file模块里的选项都可以在这里使用</span><br><span class="line"># 若出现了有关selinux的报错，可在被控机上安装libselinux-python解决</span><br><span class="line"># ansible all -m yum</span><br></pre></td></tr></table></figure><h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>用法和copy模块用法基本一致，主要用于复制模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">    backup    # 拷贝的同时也创建一个包含时间戳信息的备份文件，默认为no</span><br><span class="line">    dest=     # 目标路径</span><br><span class="line">    force     # 设置为yes (默认)时，将覆盖远程同名文件。设置为no时，忽略同名文件的拷贝</span><br><span class="line">    group     # 设置远程文件的所属组</span><br><span class="line">    owner     # 设置远程文件的所有者</span><br><span class="line">    mode      # 设置远程文件的权限。使用数值表示时不能省略第一位，如0644。</span><br><span class="line">              # 也可以使用&apos;u+rwx&apos;或&apos;u=rw,g=r,o=r&apos;等方式设置</span><br><span class="line">    src=      # ansible控制器上Jinja2格式的模板所在位置，可以是相对或绝对路径</span><br><span class="line">    validate  # 在复制到目标主机后但放到目标位置之前，执行此选项指定的命令。</span><br><span class="line">              # 一般用于检查配置文件语法，语法正确则保存到目标位置。</span><br><span class="line">              # 如果要引用目标文件名，则使用%s，下面的示例中的s%即表示目标机器上的/etc/nginx/nginx.conf。</span><br></pre></td></tr></table></figure></p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">file 设置文件属性</span><br><span class="line">path         # 设置文件路径（必填）</span><br><span class="line">dest         # 设置目的路径</span><br><span class="line">name         # 设置文件名</span><br><span class="line">owner        # 指定拥有者</span><br><span class="line">group        # 指定所属组</span><br><span class="line">mode         # 设置权限</span><br><span class="line">recurse      # 递归设置目录属性</span><br><span class="line">state        # 文件状态</span><br><span class="line">file         # 文件不存在就不会被创建</span><br><span class="line">dictionary   # 若目录不存在，就自动创建</span><br><span class="line">link         # 创建软连接</span><br><span class="line">hard         # 创建硬链接</span><br><span class="line">touch        # 若不存在就自动创建</span><br><span class="line">absent       # 删除文件或目录</span><br><span class="line">src          # 指定源文件，只应用于state=link的情况</span><br><span class="line">force        # 强制创建软链接。</span><br><span class="line">             # 两种情况：1.当源文件不存在，但之后会建立</span><br><span class="line">                        2.要先取消已创建的软链接，再重新创</span><br></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">service 管理服务运行状态</span><br><span class="line">enabled      # 是否开机自启（yes| no）</span><br><span class="line">name         # 指定服务名（必填）</span><br><span class="line">state        # 指定服务状态</span><br><span class="line">started      # 启动</span><br><span class="line">stoped       # 停止</span><br><span class="line">restarted    # 重启</span><br><span class="line">reloaded     # 重新加载</span><br><span class="line">arguments    # 服务参数</span><br><span class="line">pattern      # 设置模式</span><br><span class="line"># 通过status指令来查看服务的状态时</span><br><span class="line"># 若没有响应，就会通过ps指令在进程中根据该模式进行查找</span><br><span class="line"># 如果匹配到，则认为该服务依然在运行</span><br><span class="line">runlevel     # 运行级别</span><br><span class="line">sleep        # 若执行restarted，则在stop和start键沉睡几秒</span><br></pre></td></tr></table></figure><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>若不指定模块，则默认使用command模块。command模块不能解析变量(如$HOME)和某些操作符(“&lt;”, “&gt;”, “|“, “;”以及”&amp;”)，若需要使用以上符号，就要用shell模块。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line">    chdir        # 在执行定义的命令前进入指定目录</span><br><span class="line">    creates      # 创建文件，参数为一个文件或一个glob表达式，若已经存在就不会执行</span><br><span class="line">    removes:     # 删除文件，参数为一个文件或一个glob表达式，若不存在就不会执行</span><br><span class="line">    stdin:       # 可要求输入读取指定值</span><br></pre></td></tr></table></figure></p><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell 在远程主机上运行命令，一般要使用管道符语法时，会使用shell模块。与raw模块类似</span><br><span class="line">例：ansible all -m shell -a &apos;echo hello&apos;</span><br></pre></td></tr></table></figure><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">script 将本地脚本复制到远程主机并运行 </span><br><span class="line">例：ansible  all -m script -a &apos;/tmp/a.sh&apos;</span><br></pre></td></tr></table></figure><h3 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum 安装程序包</span><br><span class="line">    config_file         # yum的配置文件</span><br><span class="line">    disable_gpg_check   # 关闭gpg_check</span><br><span class="line">    disablerepo         # 不启用某个源</span><br><span class="line">    enablerepo          # 启用某个源</span><br><span class="line">    name                # 程序包名</span><br><span class="line">    state               # 设置状态</span><br><span class="line">        present         # 安装</span><br><span class="line">        latest          # 安装</span><br><span class="line">        absent          # 卸载</span><br></pre></td></tr></table></figure><p>注：yum模块是基于python2，若要基于python3安装，需要模块dnf。否则会以下报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   192.168.163.103 | FAILED! =&gt; &#123;</span><br><span class="line">   &quot;changed&quot;: false,</span><br><span class="line">   &quot;msg&quot;: &quot;The Python 2 bindings for rpm are needed for this module. If you require Python 3 support use the `dnf` Ansible module instead.. The Python 2 yum module is needed for this module. If you require Python 3 support use the `dnf` Ansible module instead.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可通过command模块直接安装：<code>ansible 主机 -m command -a &#39;yum -y install 软件&#39;</code></p><h3 id="dnf"><a href="#dnf" class="headerlink" title="dnf"></a>dnf</h3><p>类似yum，但由于yum基于python2，若有依赖于python3的软件包则会报错，因此可用dnf代替，并且dnf的安装速度都有提升。常用参数与yum一致。</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setup 收集远程主机的facts，获取主机信息</span><br><span class="line">    # 每个被管理节点在接受并运行管理命令前，会将自己主机相关信息（如操作系统信息，IP地址等报告给ansible）</span><br><span class="line">    filter     # 过滤器（正则表达式）</span><br><span class="line">    例：ansible 192.168.163.103 -m setup -a &apos;filter=ansible_eth[0-2]&apos;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: group1</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: get system info</span><br><span class="line">      debug: msg=&quot;system = &#123;&#123; ansible_os_family &#125;&#125; kernel = &#123;&#123; ansible_kernel &#125;&#125; ip_addr = &#123;&#123; ansible_all_ipv4_addresses &#125;&#125;&quot;</span><br><span class="line"># 用ansible XXX -m setup就能看到所有变量名</span><br></pre></td></tr></table></figure><p>收集Facts会消耗额外的时间，若不需要，可以在playbook中关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- hosts: group1</span><br><span class="line">  gather_facts: no</span><br></pre></td></tr></table></figure><h3 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">synchronize 使用rsync同步文件</span><br><span class="line">    archive       # 归档，相当于同时开启recursive(递归)、links、perms、times、owner、group、-D选项都为yes ，默认该项为开启</span><br><span class="line">    checksum      # 跳过检测sum值，默认关闭</span><br><span class="line">    compress      # 是否开启压缩，默认yes</span><br><span class="line">    copy_links    # 复制链接文件，默认为no ，注意后面还有一个links参数</span><br><span class="line">    delete        # 删除不存在的文件，默认no</span><br><span class="line">    dest          # 目录路径</span><br><span class="line">    dest_port     # 默认目录主机上的端口 ，默认是22，走的ssh协议</span><br><span class="line">    dirs          # 传速目录不进行递归，默认为no，即进行目录递归</span><br><span class="line">    rsync_opts    # rsync参数部分</span><br><span class="line">    set_remote_user    # 主要用于/etc/ansible/hosts中定义或默认使用的用户-与rsync使用的用户不同的情况</span><br><span class="line">    mode          # push或pull 模块</span><br><span class="line">        # push模式一般用于从本机向远程主机上传文件</span><br><span class="line">        # pull 模式用于从远程主机上取文件</span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mount 设置挂载点</span><br><span class="line">    dump</span><br><span class="line">    fstype     # 必选项，挂载文件的类型</span><br><span class="line">    name       # 必选项，挂载点</span><br><span class="line">    opts       # 传递给mount命令的参数</span><br><span class="line">    src        # 必选项，要挂载的文件</span><br><span class="line">    state      # 必选项present：只处理fstab中的配置</span><br><span class="line">    present    # 只处理fstab中的配置</span><br><span class="line">    absent     # 删除挂载点</span><br><span class="line">    mounted    # 自动创建挂载点并挂载</span><br><span class="line">    umounted   # 卸载</span><br></pre></td></tr></table></figure><h3 id="get-url"><a href="#get-url" class="headerlink" title="get_url"></a>get_url</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get_url    用于从http、ftp、https服务器上下载文件（类似于wget）</span><br><span class="line">sha256sum   # 下载完成后进行sha256 check；</span><br><span class="line">timeout     # 下载超时时间，默认10s</span><br><span class="line">url         # 下载的URL</span><br><span class="line">dest        # 本地存放路径</span><br><span class="line">url_password/url_username    # 主要用于需要用户名密码进行验证的情况</span><br><span class="line">use_proxy   # 使用代理，代理需事先在环境变更中定义</span><br></pre></td></tr></table></figure><p><strong>查看模块用法信息<code>ansible-doc 模块名</code></strong></p><h1 id="Playbook"><a href="#Playbook" class="headerlink" title="Playbook"></a>Playbook</h1><p>一个简单的配置管理和多主机部署系统。Playbook是由一个或多个“Plays”组成的列表。将事先归为一组的主机装扮为通过Ansible的任务Task定义好的角色。任务也就是调用Ansible的模块将多个“play”组织到一个playbook中。playbook的模板使用Python的jinja2模块处理。</p><p>Playbook的组成：</p><ol><li>Inventory</li><li>Modules</li><li>Ad Hoc Commands</li><li>Playbooks，包含以下部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tasks：任务，即调用模块完成的某操作。这是Playbook的核心，定义顺序执行的Action，每个Action调用一个Ansible模块</span><br><span class="line">Variables：变量</span><br><span class="line">Template：模板</span><br><span class="line">Handlers：处理器，由某事件触发执行的操作</span><br><span class="line">Roles：角色</span><br></pre></td></tr></table></figure></li></ol><p><strong>playbook基本组件</strong><br>play的主体部分是task list，task list中各个任务按次序逐个在hosts指定的主机上运行，即在所有主机上完成第一个任务后再按顺序完成第二个，若中途某个主机出现错误，则所有执行的任务都可能回滚。</p><p>建议每个任务都定义一个name标签，且每个task执行一个模块<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span>          <span class="comment"># 指定主机组，也可指定单个主机</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span>    <span class="comment"># 指定远程主机上执行任务的用户（也可用于各个task中）</span></span><br><span class="line"><span class="attr">  sudo:</span> <span class="literal">yes</span>            <span class="comment"># sudo执行命令，也可在task中添加</span></span><br><span class="line"><span class="attr">  sudo_user:</span>           <span class="comment"># sudo身份</span></span><br><span class="line"><span class="attr">  tasks:</span>               <span class="comment"># 任务列表</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">install</span> <span class="string">latest</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      yum:</span> <span class="string">name=httpd</span> <span class="string">state=latest</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">run</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">      service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span>   <span class="comment"># 运行service模块，后面跟上参数选项</span></span><br></pre></td></tr></table></figure></p><h2 id="命令解析"><a href="#命令解析" class="headerlink" title="命令解析"></a>命令解析</h2><p><code>ansible-playbook</code>对yaml文件进行执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook [选项] yml文件</span><br><span class="line">  -f                     # 指定并行进程数，默认为5</span><br><span class="line">  -i 或 --inventory      # 指定Inventory文件</span><br><span class="line">  -e 或 --extra-vars=    # 设置额外的环境变量</span><br><span class="line">  --flush-cache          # 清空收集到的facts缓存</span><br><span class="line">  --list-tasks           # 列出所有将被执行的tasks</span><br><span class="line">  --list-tags            # 列出所有可获得的tags</span><br><span class="line">  --step                 # 每执行一步都进行交互式确认</span><br><span class="line">  --syntax-check         # 检查playbook语法 </span><br><span class="line">  --list-hosts           # 列出执行该playbook会影响的主机</span><br><span class="line">  -v 或 --verbose        # 查看详细输出</span><br></pre></td></tr></table></figure><p><code>ansible-pull</code>拉取指定主机的配置</p><h2 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">    vars:</span> </span><br><span class="line"><span class="attr">      service:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">      package:</span> <span class="string">httpd</span></span><br><span class="line">    <span class="comment"># 或直接在本地创建变量文件，然后在playbook中通过vars_files调用</span></span><br><span class="line"><span class="attr">    vars_files:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">XXX/XXX.yml</span></span><br><span class="line"><span class="attr">    tasks:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">install</span> <span class="string">latest</span> <span class="string">apache</span></span><br><span class="line">      <span class="comment"># 若要通过上面定义的变量引用，则需要两对大括号调用</span></span><br><span class="line"><span class="attr">        yum:</span> <span class="string">name=&#123;&#123;</span> <span class="string">package</span> <span class="string">&#125;&#125;</span> <span class="string">state=latest</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">run</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">        service:</span> <span class="string">name=&#123;&#123;</span> <span class="string">service</span> <span class="string">&#125;&#125;</span> <span class="string">state=started</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 若定义的是一个对象，可直接用中括号或点调用子属性</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">group1</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    foo:</span></span><br><span class="line"><span class="attr">      field1:</span> <span class="string">one</span></span><br><span class="line"><span class="attr">      field2:</span> <span class="string">two</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">echo</span> <span class="string">foo.field1</span></span><br><span class="line">      <span class="comment">#  de<span class="doctag">bug:</span> msg="echo &#123;&#123;foo.field1&#125;&#125;"</span></span><br><span class="line"><span class="attr">      debug:</span> <span class="string">msg="echo</span> <span class="string">&#123;&#123;foo['field1']&#125;&#125;"</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">echo</span> <span class="string">foo.field2</span></span><br><span class="line"><span class="attr">      debug:</span> <span class="string">msg="echo</span> <span class="string">&#123;&#123;foo.field2&#125;&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[echo</span> <span class="string">foo.field1]</span> <span class="string">*********************************************************</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"echo one"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[echo</span> <span class="string">foo.field2]</span> <span class="string">*********************************************************</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"echo two"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>简单试验分析：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">创建test.yml</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">system3</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">      command:</span> <span class="string">'echo hello'</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">create</span> <span class="string">user</span></span><br><span class="line"><span class="attr">      user:</span> <span class="string">name=apache</span> <span class="string">password=redhat</span> <span class="string">state=present</span> <span class="string">uid=1003</span></span><br><span class="line"></span><br><span class="line"><span class="string">root@system2</span> <span class="string">~</span> <span class="string">&gt; ansible-playbook test.yml</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">PLAY [system3] *****************************************************************</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TASK [Gathering Facts] *********************************************************</span></span><br><span class="line"><span class="string"></span><span class="attr">ok:</span> <span class="string">[192.168.163.103]</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[echo</span> <span class="string">hello]</span> <span class="string">**************************************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[192.168.163.103]</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[create</span> <span class="string">user]</span> <span class="string">*************************************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[192.168.163.103]</span></span><br><span class="line"></span><br><span class="line"><span class="string">PLAY</span> <span class="string">RECAP</span> <span class="string">*********************************************************************</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.163</span><span class="number">.103</span>            <span class="string">:</span> <span class="string">ok=3</span>    <span class="string">changed=2</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># changed说明发生了改变。</span></span><br><span class="line"><span class="comment"># 若再次执行一遍，会出现以下改变</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[echo</span> <span class="string">hello]</span> <span class="string">**************************************************************</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[192.168.163.103]</span></span><br><span class="line"></span><br><span class="line"><span class="string">TASK</span> <span class="string">[create</span> <span class="string">user]</span> <span class="string">*************************************************************</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[192.168.163.103]</span></span><br><span class="line"></span><br><span class="line"><span class="string">PLAY</span> <span class="string">RECAP</span> <span class="string">*********************************************************************</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.163</span><span class="number">.103</span>            <span class="string">:</span> <span class="string">ok=3</span>    <span class="string">changed=1</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span>  </span><br><span class="line"><span class="comment"># 创建用户不再是changed，而是ok，而输出打印hello仍然为changed。</span></span><br><span class="line"><span class="comment"># 因为用户已创建了，就不会再创建，这体现了playbook的幂等性。而打印文字并不符合只需要执行一遍的特性。</span></span><br></pre></td></tr></table></figure><h2 id="register"><a href="#register" class="headerlink" title="register"></a>register</h2><p>register为注册变量，即：将任务执行的结果当做一个变量的值，待后面的任务使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">group1</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - shell:</span> <span class="string">ls</span></span><br><span class="line"><span class="attr">      register:</span> <span class="string">result</span></span><br><span class="line"><span class="attr">    - debug:</span> <span class="string">msg="&#123;&#123;</span> <span class="string">result.stdout</span> <span class="string">&#125;&#125;"</span></span><br><span class="line"><span class="comment"># 就能输出在对端主机ls得到的结果</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[debug]</span> <span class="string">*******************************************************************</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"anaconda-ks.cfg"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">'<span class="template-variable">&#123;&#123;group&#125;&#125;</span>'</span>    <span class="comment"># 一定要加引号（无论是单引号还是双引号），否则会产生YAML陷阱，报错</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">'<span class="template-variable">&#123;&#123;user&#125;&#125;</span>'</span></span><br><span class="line">  <span class="string">.....</span></span><br></pre></td></tr></table></figure><p>在执行ansible-playbook时添加参数<code>--extra-vars &quot;group=group1 user=root&quot;</code></p><h2 id="notify与handler"><a href="#notify与handler" class="headerlink" title="notify与handler"></a>notify与handler</h2><p>当远端发生改动时，playbooks本身可以识别这种改动,并且有一个基本的事件系统,可以响应这种改动。<br>notify会在playbook的每一个task结束时触发,即使有多个不同的task通知发生了改动（changed），notify只会被触发一次。<br>Handlers也是task的列表，若notify有定义，则handlers一定要有对应的处理方法。handlers主要用在重启服务，或系统重启。</p><p>一个handler最多只执行一次，并且<strong>在所有task都执行完后再执行</strong>，即handler是按照定义的顺序执行的，并不是按照task的调用顺序执行的。如果有多个任务调用同一个handler，则也只执行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- hosts: test</span><br><span class="line">    tasks:</span><br><span class="line">      - name: install apache</span><br><span class="line">        yum: name=httpd state=latest</span><br><span class="line">        notify: yum error    # 关注可能发生的错误（不一定是错误），类似抛出异常</span><br><span class="line">        # 若notify有多个，可通过列表定义</span><br><span class="line">          - yum error</span><br><span class="line">          - httpd error  # 定义了多个，则handler也要有对应处理</span><br><span class="line">    handlers:            # 当关注的资源发生变化时采取的措施</span><br><span class="line">      - name: yum error  # 当有notify抛出，也要有对应的解决方案，name要与对应的notify的名字一致。</span><br><span class="line">        service: name=httpd state=restarted</span><br></pre></td></tr></table></figure><h2 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h2><p>三种逻辑控制语句：</p><ul><li><code>when</code>：条件判断，类似if</li><li><code>loop</code>：（迭代）循环，类似while</li><li><code>block</code>：将几个任务组成一个代码块，以便针对一组操作的异常进行处理</li></ul><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>当需要根据变量等信息判断是否需要执行某task时，则需要条件判断</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    when:</span> <span class="string">ansible_fqdn</span> <span class="string">==</span> <span class="string">'system3.example.com'</span></span><br><span class="line"><span class="comment"># 在task后添加when子句即可进行条件测试，when语句支持jinja2语法</span></span><br><span class="line"><span class="comment"># when语句中还能使用Jinja2的很多'filter'</span></span><br><span class="line"></span><br><span class="line"><span class="string">执行结果：</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[echo</span> <span class="string">hello]</span> <span class="string">**************************************************************</span></span><br><span class="line"><span class="attr">skipping:</span> <span class="string">[192.168.163.104]</span></span><br><span class="line"><span class="attr">changed:</span> <span class="string">[192.168.163.103]</span></span><br><span class="line"></span><br><span class="line"><span class="string">PLAY</span> <span class="string">RECAP</span> <span class="string">*********************************************************************</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.163</span><span class="number">.103</span>            <span class="string">:</span> <span class="string">ok=2</span>    <span class="string">changed=1</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.163</span><span class="number">.104</span>            <span class="string">:</span> <span class="string">ok=1</span>    <span class="string">changed=0</span>    <span class="string">unreachable=0</span>    <span class="string">failed=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经过判断system4不满足when条件，所以skipping跳过，而system3满足，所以changed</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用and、or、not进行逻辑连接或判断，==、!=、&gt;、&lt;、&gt;=、&lt;=进行算数比较</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用is</span> <span class="string">exists或is</span> <span class="string">not</span> <span class="string">exists判断指定的文件是否存在，且可通过not取反</span></span><br><span class="line"><span class="string">即not</span> <span class="string">XXX</span> <span class="string">is</span> <span class="string">exists</span> <span class="string">等于</span> <span class="string">XXX</span> <span class="string">is</span> <span class="string">not</span> <span class="string">exists</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用defined、undefined、none判断变量是否已定义，以及变量是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用success或succeeded、failure或failed、change或changed、skip或skipped分别判断任务返回状态是否为成功、任务返回状态是否为失败、任务返回状态是否为改变、任务返回状态是否为跳过</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用file、directory、link、mount判断路径是否为一个文件、目录、链接、挂载点</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用lower、upper判断字符串是否为纯小写、纯大写</span></span><br><span class="line"></span><br><span class="line"><span class="string">可使用even、odd判断数值是否为偶数、奇数，可用divisibleby(num)判断是否可以整除数值num</span></span><br><span class="line"></span><br><span class="line"><span class="string">可用version(version值,'算数比较符')比较版本与指定值的大小</span></span><br><span class="line"></span><br><span class="line"><span class="string">可用string、number分别判断值是否为字符串或数字</span></span><br><span class="line"></span><br><span class="line"><span class="string">可用subset、superset（版本2.5及以上）|issubset、issuperset（版本2.5以下）判断一个list是否是另一个list的子集或父集</span></span><br></pre></td></tr></table></figure><h3 id="迭代（循环）"><a href="#迭代（循环）" class="headerlink" title="迭代（循环）"></a>迭代（循环）</h3><p>重复同类的task时使用。item定义迭代，with_items定义循环列表。<br>with_items中的列表值可以使字典，若是字典，引用时要使用item.键名</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">列表形式</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">apache</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">php</span></span><br><span class="line"><span class="string">字典形式</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#123;name:</span> <span class="string">apache,</span> <span class="attr">conf:</span> <span class="string">/etc/httpd.conf&#125;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&#123;name:</span> <span class="string">php,</span> <span class="attr">conf:</span> <span class="string">/etc/php.ini&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">试验：</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">create</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">name=&#123;&#123;item&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line"><span class="attr">  with_items:</span> </span><br><span class="line"><span class="bullet">    -</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">lisi</span></span><br><span class="line"><span class="string">就相当于</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">name=zhangsan</span> <span class="string">state=present</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">name=lisi</span> <span class="string">state=present</span></span><br><span class="line"></span><br><span class="line"><span class="string">或者在vars中定义列表，然后使用with_items调用</span></span><br><span class="line"><span class="attr">vars:</span> </span><br><span class="line">  <span class="string">user_list=['zhangsan',</span> <span class="string">'lisi'</span><span class="string">]</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">  - user:</span> <span class="string">name=&#123;&#123;item&#125;&#125;</span> <span class="string">state=present</span></span><br><span class="line"><span class="attr">    with_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; user_list &#125;&#125;</span>"</span></span><br><span class="line">    </span><br><span class="line"><span class="string">嵌套循环</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span> <span class="string">msg="&#123;&#123;</span> <span class="string">item.0</span> <span class="string">&#125;&#125;</span> <span class="string">&#123;&#123;</span> <span class="string">item.1</span> <span class="string">&#125;&#125;"</span></span><br><span class="line"><span class="comment">#或 -de<span class="doctag">bug:</span> msg="layer1: &#123;&#123;item[0]&#125;&#125; layer2: &#123;&#123;item[2]&#125;&#125;"</span></span><br><span class="line"><span class="attr">      with_nested:</span>      <span class="comment"># 使用with_nested进行嵌套循环</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">['1',</span> <span class="string">'2'</span><span class="string">]</span>    <span class="comment"># 这个循环用item.0表示</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">['4',</span> <span class="string">'5'</span><span class="string">]</span>    <span class="comment"># 这个循环用item.1表示</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[debug]</span> <span class="string">*******************************************************************</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">(item=[u'1',</span> <span class="string">u'4'])</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"1 4"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">(item=[u'1',</span> <span class="string">u'5'])</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"1 5"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">(item=[u'2',</span> <span class="string">u'4'])</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"2 4"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">(item=[u'2',</span> <span class="string">u'5'])</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"2 5"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">文件列表循环</span></span><br><span class="line"><span class="string">在当前目录下创建demo目录，并在其中创建httpd_1.conf和httpd_2.conf，编写Playbook</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - debug:</span> <span class="string">msg="&#123;&#123;</span> <span class="string">item</span> <span class="string">&#125;&#125;"</span> </span><br><span class="line"><span class="attr">      with_fileglob:</span>     <span class="comment"># 使用with_fileglob进行文件列表循环</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./demo/*</span>       <span class="comment"># 要循环的文件路径</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[debug]</span> <span class="string">*******************************************************************</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">(item=/root/./demo/httpd_1.conf)</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "item":</span> <span class="string">"/root/./demo/httpd_1.conf"</span><span class="string">,</span> </span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"/root/./demo/httpd_1.conf"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">(item=/root/./demo/httpd_2.conf)</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "item":</span> <span class="string">"/root/./demo/httpd_2.conf"</span><span class="string">,</span> </span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"/root/./demo/httpd_2.conf"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Block块"><a href="#Block块" class="headerlink" title="Block块"></a>Block块</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">多个Action组成block块，可进行一个块的执行</span></span><br><span class="line"><span class="attr">  tasks:</span> </span><br><span class="line"><span class="attr">  - debug:</span></span><br><span class="line"><span class="attr">      msg:</span> <span class="string">"task1 not in block"</span></span><br><span class="line"><span class="attr">  - block:</span></span><br><span class="line"><span class="attr">      - debug:</span></span><br><span class="line"><span class="attr">          msg:</span> <span class="string">"task2 in block"</span></span><br><span class="line"><span class="attr">      - debug:</span></span><br><span class="line"><span class="attr">          msg:</span> <span class="string">"task3 in block"</span></span><br><span class="line"><span class="attr">    when:</span> <span class="number">2</span> <span class="string">&gt; 1</span></span><br><span class="line"><span class="string"># block块中的when是用于判断block块是否执行的条件</span></span><br></pre></td></tr></table></figure><p>但Block块更常见的用法是“错误处理”。当某任务出错时，能够执行指定的其他任务。作用与<code>when XXX is failed</code>一致。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">  tasks:</span> </span><br><span class="line"><span class="attr">    - block:</span> </span><br><span class="line"><span class="attr">        - shell:</span> <span class="string">"ls ./aaa"</span>        <span class="comment"># 该目录不存在，会出错</span></span><br><span class="line"><span class="attr">      rescue:</span>       <span class="comment"># 一旦出错就会调用rescue任务，类似except，处理异常</span></span><br><span class="line"><span class="attr">        - debug:</span> </span><br><span class="line"><span class="attr">            msg:</span> <span class="string">"caught an error"</span>  </span><br><span class="line"><span class="attr">      always:</span>       <span class="comment"># 总是会执行的语句，类似finally</span></span><br><span class="line"><span class="attr">        - debug:</span></span><br><span class="line"><span class="attr">            msg:</span> <span class="string">"this always executes"</span></span><br><span class="line"><span class="string">结果：</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[command]</span> </span><br><span class="line"><span class="attr">fatal:</span> <span class="string">......</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[debug]</span> </span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"caught an error"</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">TASK</span> <span class="string">[debug]</span> </span><br><span class="line"><span class="attr">ok:</span> <span class="string">[172.16.246.133]</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    "msg":</span> <span class="string">"this always executes"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>通过配置模板，可将配置文件中的参数按照inventory文件中变量以及ansible facts中变量动态赋值，使得每个指定的主机的配置都是定制的。<br>首先要创建一个templates目录。<code>mkdir /etc/ansible/templates</code><br>将配置文件放入该目录，并最好改名为<code>xxx.conf.j2</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">以httpd为例，修改配置文件/etc/ansible/templates/httpd.conf.j2</span></span><br><span class="line"><span class="string">Listen</span> <span class="string">&#123;&#123;</span> <span class="string">http_port</span> <span class="string">&#125;&#125;</span>    <span class="comment"># 使用inventory定义变量</span></span><br><span class="line"><span class="string">User</span> <span class="string">&#123;&#123;</span> <span class="string">username</span> <span class="string">&#125;&#125;</span>       <span class="comment"># 同上</span></span><br><span class="line"><span class="string">Group</span> <span class="string">&#123;&#123;</span> <span class="string">groupname</span> <span class="string">&#125;&#125;</span>     <span class="comment"># 同上</span></span><br><span class="line"><span class="string">ServerName</span> <span class="string">&#123;&#123;</span> <span class="string">ansible_fqdn</span> <span class="string">&#125;&#125;</span>    <span class="comment"># 使用facts变量</span></span><br><span class="line"></span><br><span class="line"><span class="string">然后修改/etc/ansible/hosts文件</span></span><br><span class="line"><span class="string">[test]</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.163</span><span class="number">.103</span> <span class="string">http_port=8081</span> <span class="string">username=system3</span> <span class="string">groupname=system3</span> </span><br><span class="line"><span class="number">192.168</span><span class="number">.163</span><span class="number">.104</span> <span class="string">http_port=8082</span> <span class="string">username=system4</span> <span class="string">groupname=system4</span> </span><br><span class="line"></span><br><span class="line"><span class="string">然后在playbook中将本地的配置文件复制到远端，以下是完整试验</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    service:</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">alter</span> <span class="string">config</span></span><br><span class="line"><span class="attr">    template:</span> <span class="string">src=/etc/ansible/templates/httpd.conf.j2</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    notify:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">start</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">    service:</span> <span class="string">name=&#123;&#123;</span> <span class="string">service</span> <span class="string">&#125;&#125;</span> <span class="string">enabled=true</span> <span class="string">state=started</span> </span><br><span class="line"><span class="attr">  handlers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">    service:</span> <span class="string">name=&#123;&#123;</span> <span class="string">service</span> <span class="string">&#125;&#125;</span> <span class="string">state=restarted</span></span><br><span class="line"></span><br><span class="line"><span class="string">执行ansible-playbook</span> <span class="string">test.yml。之后查看103和104主机的httpd配置文件</span></span><br><span class="line"><span class="string">system3和system4上，httpd配置文件都更改成功。以下为system3上的配置</span></span><br><span class="line"><span class="string">Listen</span> <span class="number">8081</span></span><br><span class="line"><span class="string">Include</span> <span class="string">conf.modules.d/*.conf</span></span><br><span class="line"><span class="string">User</span> <span class="string">system3</span></span><br><span class="line"><span class="string">Group</span> <span class="string">system3</span></span><br><span class="line"><span class="string">ServerAdmin</span> <span class="string">root@localhost</span></span><br><span class="line"><span class="string">ServerName</span> <span class="string">system3.example.com</span></span><br></pre></td></tr></table></figure></p><h3 id="tags标签"><a href="#tags标签" class="headerlink" title="tags标签"></a>tags标签</h3><p>可以为playbook中的每个任务都打上标签，标签的主要作用是可以在ansible-playbook中设置只执行被打上tag的任务或忽略被打上tag的任务。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">install</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">  yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">apache</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">install</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  yum:</span> <span class="string">name=mysql-server</span> <span class="string">state=present</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">mysql</span></span><br><span class="line"><span class="string">当执行playbook时，可通过--tags=</span> <span class="string">运行打上指定tag的task</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">test.yml</span> <span class="bullet">--tags="apache"</span> <span class="string">则只运行安装打上apache标签的task</span></span><br><span class="line"><span class="string">ansible-playbook</span> <span class="string">test.yml</span> <span class="bullet">--skip-tags="apache"则会跳过执行apache标签的task</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">always</span></span><br><span class="line"><span class="string">打上always标签的task总会被执行，不管是否指定了--tags="XXX"</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-tags</span> <span class="string">tagged</span>    <span class="comment"># 会执行所有打上tag的task，不管打上的是什么标签</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-tags</span> <span class="string">untagged</span>  <span class="comment"># 会执行所有没有打标签的task</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-tags</span> <span class="string">all</span>       <span class="comment"># 执行所有任务，无论是否打标签</span></span><br></pre></td></tr></table></figure></p><h3 id="include和roles"><a href="#include和roles" class="headerlink" title="include和roles"></a>include和roles</h3><p>如果把所有play都写在一个playbook中，会导致文件不易阅读。ansible可以将多个不同任务分别写在不同的playbook中，然后使用include将其包含进去，实现Playbook的重用。roles也是一种整合playbook的方式。include的维护成本较高，重用能力有限，而role更加灵活，且可以重用一组文件。</p><h4 id="include"><a href="#include" class="headerlink" title="include"></a>include</h4><p>使用include语句引用task文件的方法，可允许你将一个配置策略分解到更小的文件中，将tasks从其他文件拉取过来（handlers也是tasks）。即include可以导入两种文件：导入task、导入playbook。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">导入task：</span></span><br><span class="line"><span class="string">创建一个单独的yml配置文件，a.yml</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">echo</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">echo</span> <span class="string">'hello'</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">echo</span> <span class="string">value</span></span><br><span class="line"><span class="attr">    command:</span> <span class="string">echo</span> <span class="string">&#123;&#123;value&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">在主playbook中便可通过include引用该文件</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - include:</span> <span class="string">a.yml</span> <span class="string">value='hello'</span></span><br><span class="line">       <span class="comment"># 可以直接在文件名后传参数</span></span><br><span class="line">       <span class="comment"># 也可以通过vars传参</span></span><br><span class="line"><span class="attr">  tasks:</span> </span><br><span class="line"><span class="attr">    - include:</span> <span class="string">a.yml</span></span><br><span class="line"><span class="attr">      vars:</span> </span><br><span class="line"><span class="attr">        value:</span> <span class="string">hello</span></span><br><span class="line"></span><br><span class="line"><span class="string">导入playbook：</span></span><br><span class="line"><span class="string">并不在task中通过include调用yml了，而是直接在最外层导入playbook</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">test</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"><span class="attr">- include:</span> <span class="string">test1.yml</span></span><br><span class="line"><span class="attr">- include:</span> <span class="string">apache.yml</span> <span class="string">http_port=8000</span>  <span class="comment"># 传参方式与上面一样</span></span><br><span class="line"></span><br><span class="line"><span class="string">在include中使用tags</span></span><br><span class="line"><span class="attr">- include:</span> <span class="string">test1.yml</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">[aaa,</span> <span class="string">bbb]</span></span><br></pre></td></tr></table></figure></p><h4 id="roles"><a href="#roles" class="headerlink" title="roles"></a>roles</h4><p>角色，封装playbook，实现复用性，能够根据层次型结构自动加载变量文件、tasks以及handlers等。<br>roles就是通过分别将变量、文件、任务、模板以及处理器放置于单独的目录中，然后通过include调用的一种机制。roles一般用于基于主机构建服务的场景中，也可以使用于构建守护进程的场景中。</p><p>创建role的步骤：</p><ol><li>在playbooks目录中创建roles目录</li><li>在roles目录中创建角色名的目录</li><li>在每个角色命令的目录中创建files、handlers、meta、tasks、templates、vars目录。若用不到的目录也可不创</li><li>在playbook中调用各角色</li></ol><p>roles中各目录：</p><ul><li><code>tasks</code>目录：至少包含一个main.yml，其定义了此角色的任务列表，此文件可用include包含其他task目录</li><li><code>files</code>目录：存放有copy或script等模块调用的文件</li><li><code>templates</code>目录：template模块会自动在此文件中寻找jinja2模板</li><li><code>handlers</code>目录：此目录中应包含一个main.yml，定义此角色用到的handler</li><li><code>yml</code>文件：用于定义此角色用到的个handler，</li><li><code>vars</code>目录：应包含一个main.yml，定义此角色用到的变量</li><li><code>meta</code>目录：应包含一个main.yml，定义此角色的特殊设定和依赖关系</li><li><code>defaults</code>目录：应包含一个main.yml，为当前角色设定默认变量时使用此目录</li></ul><p>案例目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">roles</span><br><span class="line">├── test1</span><br><span class="line">│   ├── files</span><br><span class="line">│   ├── handlers</span><br><span class="line">│   ├── meta</span><br><span class="line">│   ├── tasks</span><br><span class="line">│   ├── templates</span><br><span class="line">│   └── vars</span><br><span class="line">└── test2</span><br><span class="line">    ├── files</span><br><span class="line">    ├── handlers</span><br><span class="line">    ├── meta</span><br><span class="line">    ├── tasks</span><br><span class="line">    ├── templates</span><br><span class="line">    └── vars</span><br></pre></td></tr></table></figure></p><p>将要编写的task文件存放在tasks目录中，编写main.yml。<br>将httpd的配置文件复制到files目录中。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">install</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">  yum:</span> <span class="string">name=httpd</span> <span class="string">state=present</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">install</span> <span class="string">config</span></span><br><span class="line"><span class="attr">  copy:</span> <span class="string">src=httpd.conf</span> <span class="string">dest=/etc/httpd/conf/httpd.conf</span> </span><br><span class="line">  <span class="comment"># 这里copy的源可直接写文件名，会自动定位到files目录中</span></span><br><span class="line"><span class="attr">  tags:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">conf</span></span><br><span class="line"><span class="attr">  notify:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">start</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">  service:</span> <span class="string">name=httpd</span> <span class="string">state=started</span></span><br></pre></td></tr></table></figure></p><p>然后在handlers中添加handler文件，在目录中创建main.yml<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">restart</span> <span class="string">httpd</span></span><br><span class="line"><span class="attr">  service:</span> <span class="string">name=httpd</span> <span class="string">state=restarted</span></span><br></pre></td></tr></table></figure></p><p>在于roles平级的目录中创建site.yml文件（名字可自定义），就是主配置文件。roles后面也可跟上参数，也可跟上条件判断。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- hosts:</span> <span class="string">system1</span></span><br><span class="line"><span class="attr">  remote_port:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">  roles:</span> </span><br><span class="line"><span class="bullet">    -</span> <span class="string">test1</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">system3</span></span><br><span class="line"><span class="attr">  roles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test2</span></span><br><span class="line"><span class="attr">- hosts:</span> <span class="string">system4</span></span><br><span class="line"><span class="attr">  roles:</span> </span><br><span class="line"><span class="bullet">    -</span> <span class="string">test1</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">test2</span></span><br></pre></td></tr></table></figure></p><p>带参数的role</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a.yml和roles的目录结构</span><br><span class="line">a.yml</span><br><span class="line">roles/</span><br><span class="line">└── myrole</span><br><span class="line">    └── tasks</span><br><span class="line">        └── main.yml</span><br><span class="line"></span><br><span class="line">在main.yml中指定task</span><br><span class="line">---</span><br><span class="line">  - debug: msg=&quot;&#123;&#123; param &#125;&#125;&quot;</span><br><span class="line">在a.yml中的配置如下：</span><br><span class="line">---</span><br><span class="line">- hosts: group1</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - role: myrole</span><br><span class="line">      param: &quot; task first&quot;</span><br><span class="line">    - role: myrole</span><br><span class="line">      param: &quot; task second&quot;</span><br><span class="line">执行结果：</span><br><span class="line">TASK [myrole : debug] </span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot; task first&quot;</span><br><span class="line">&#125;</span><br><span class="line">TASK [myrole : debug] </span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot; task second&quot;</span><br><span class="line">&#125;</span><br><span class="line">会循环遍历a.yml中设置指定参数执行</span><br></pre></td></tr></table></figure><p>role的默认参数defaults，在myrole中创建defaults目录，并创建main.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">roles/</span><br><span class="line">└── myrole</span><br><span class="line">    ├── defaults</span><br><span class="line">    │   └── main.yml</span><br><span class="line">    └── tasks</span><br><span class="line">        └── main.yml</span><br><span class="line">在defaults中的main.yml中只要配置</span><br><span class="line">---</span><br><span class="line">param: &quot;default param&quot;</span><br><span class="line">将a.yml中的myrole下的参数配置删除</span><br><span class="line">roles:</span><br><span class="line">    - myrole</span><br><span class="line">再执行，就会调用defaults中的指定参数</span><br><span class="line">TASK [myrole : debug]</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;default param&quot;</span><br><span class="line">&#125;</span><br><span class="line">但执行速度会变慢</span><br></pre></td></tr></table></figure><p>role与when的结合：当满足条件时才采用指定值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">roles: </span><br><span class="line">  - role: myrole</span><br><span class="line">    param: &quot;myrole param&quot;</span><br><span class="line">  - role: myrole</span><br><span class="line">    when: 2&gt;1</span><br><span class="line">结果：</span><br><span class="line">TASK [myrole : debug] </span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;myrole param&quot;</span><br><span class="line">&#125;</span><br><span class="line">TASK [myrole : debug]</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;default param&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在role中使用tags</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roles: </span><br><span class="line">  - role: myrole</span><br><span class="line">    tags: [&apos;aaa&apos;, &apos;bbb&apos;]</span><br></pre></td></tr></table></figure><p>role和tasks的执行顺序</p><ol><li>pre_tasks：是在最先执行的task</li><li>roles：roles会在tasks前执行</li><li>tasks</li><li>post_tasks：最后执行的task</li></ol><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><ul><li>若要使command或shell的成功返回值不为0，有以下两种方式<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr"> - name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">   shell:</span> <span class="string">/usr/bin/somecommand</span> <span class="string">||</span> <span class="string">/bin/true</span></span><br><span class="line"><span class="string">或</span></span><br><span class="line"><span class="attr">tasks:</span></span><br><span class="line"><span class="attr"> - name:</span> <span class="string">run</span> <span class="string">this</span> <span class="string">command</span> <span class="string">and</span> <span class="string">ignore</span> <span class="string">the</span> <span class="string">result</span></span><br><span class="line"><span class="attr">   shell:</span> <span class="string">/usr/bin/somecommand</span></span><br><span class="line"><span class="attr">   ignore_errors:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Ansible变量"><a href="#Ansible变量" class="headerlink" title="Ansible变量"></a>Ansible变量</h1><p>Ansible有三个组成部分：</p><ul><li>Global：作用域为全局。在以下方面定义：<ul><li>Ansible配置文件中定义</li><li>环境变量</li><li>ansible及ansible-playbook命令行传入的变量</li></ul></li><li>Play：作用域为Play（一个Playbook由多个Play组成）。在以下方面定义：<ul><li>Play中vars关键词定义的变量</li><li>通过模块include_vars定义的变量</li><li>role在文件default/main.yml和vars/main.yml中定义的变量</li></ul></li><li>Host：作用域为某个主机。在以下方面定义：<ul><li>定义在主机Inventory中的变量</li><li>主机的系统变量</li><li>注册变量</li></ul></li></ul><p><strong>Ansible所有变量的优先级（从高到低）：</strong></p><ul><li><p><strong>extra vars</strong>：通过命令传入的变量</p></li><li><p><strong>task vars</strong>：仅在该任务中使用的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - XXXX</span><br><span class="line">    vars:</span><br><span class="line">      XXX: XXX</span><br></pre></td></tr></table></figure></li><li><p><strong>block vars</strong>：只在Playbook的任务中某个block定义的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">....</span><br><span class="line">  - block: </span><br><span class="line">    - XXX: XXXX</span><br><span class="line">    vars: </span><br><span class="line">      XXX: XXX</span><br></pre></td></tr></table></figure></li><li><p><strong>role include vars</strong>：在<code>tasks/main.yml</code>中，通过include加载的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- name: xxx</span><br><span class="line">  include_vars: &quot;XXX.yml&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>role and include vars</strong>：role的变量。在<code>vars/main.yml</code>中定义的变量</p></li><li><p><strong>set_facts</strong>：这是一个模块，通过该模块加入一些Facts变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- set_fact:</span><br><span class="line">  XXX: XXX</span><br></pre></td></tr></table></figure></li><li><p><strong>registered vars</strong>：注册变量</p></li><li><p><strong>play vars_files</strong>：将变量单独放在一个文件中，通过关键字<code>var_files</code>从文件中加载的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var_files:</span><br><span class="line">  - XXX.yml</span><br></pre></td></tr></table></figure></li><li><p><strong>play vars_prompt</strong>：需要用户在执行Playbook时输入的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vars_prompt:</span><br><span class="line">  - name: &quot;yourname&quot;</span><br><span class="line">tasks: </span><br><span class="line">  - debug: msg=&quot;your name is &#123;&#123;yourname&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">在执行Playbook时传参</span><br><span class="line">ansible-playbook a.yml -e &apos;yourname=zhangsan&apos;</span><br></pre></td></tr></table></figure></li><li><p><strong>play vars</strong>：Playbook中的<code>vars</code>关键字下定义的参数</p></li><li><p><strong>host facts</strong>：Ansible在执行Playbook时，收集到的远程主机的信息</p></li><li><p><strong>playbook host_vars</strong>：Playbook同级子目录<code>host_vars</code>中文件内定义的变量</p></li><li><p><strong>playbook group_vars</strong>：Playbook同级子目录<code>group_vars</code>中文件内定义的变量</p></li><li><p><strong>inventory host_vars</strong>：可在两个地方定义。一是在inventory文件中直接定义，二是在Inventory文件的同级子目录<code>host_vars</code>中<strong>与host同名的文件</strong>中定义</p></li><li><p><strong>inventory group_vars</strong>：可在两个地方定义。一是在inventory文件中直接定义，二是在Inventory文件的同级子目录<code>group_vars</code>中<strong>与group同名的文件</strong>中定义</p></li><li><p><strong>inventory vars</strong>：Inventory文件中定义的变量</p></li><li><p><strong>role defaults</strong>：role的默认变量，在<code>defaults/main.yml</code>中定义</p></li></ul><h1 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h1><p>lookup既能读取Ansible管理节点上文件系统的文件内容，还能读取数据库内容。</p><ul><li><p>lookup读取文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vars: </span><br><span class="line">  contents: &quot;&#123;&#123; lookup(&apos;file&apos;, &apos;data/test.txt&apos;) &#125;&#125;&quot;</span><br><span class="line">将data/test.txt中的内容赋给变量contents，file指定读取的对象类型是文件</span><br></pre></td></tr></table></figure></li><li><p>lookup生成随机密码，若文件不存在，会自动创建，并将生成的密码存入。若文件存在，则直接读取作为密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vars: </span><br><span class="line">  password: &quot;&#123;&#123; lookup(&apos;password&apos;, &apos;/etc/password/zhangsan length=6&apos;) &#125;&#125;&quot;</span><br><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;password &#123;&#123;password&#125;&#125;&quot;</span><br><span class="line">  </span><br><span class="line">执行结果：</span><br><span class="line">TASK [debug]</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;password BWNcQ2 &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lookup读取环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;&#123;&#123; lookup(&apos;env&apos;, &apos;HOME&apos;) &#125;&#125;&quot;</span><br><span class="line">  </span><br><span class="line">结果：</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;/root&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lookup读取Linux命令执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;&#123;&#123; lookup(&apos;pipe&apos;, &apos;uname -r&apos;) &#125;&#125;&quot;</span><br><span class="line">  </span><br><span class="line">结果：</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;4.8.6-300.fc25.x86_64&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lookup读取template变量替换后的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;&#123;&#123; lookup(&apos;template&apos;, &apos;./httpd.conf.j2&apos;) &#125;&#125;&quot;</span><br></pre></td></tr></table></figure></li><li><p>lookup读取配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">demo.ini配置文件：</span><br><span class="line">[global]</span><br><span class="line">port = 873</span><br><span class="line">.....</span><br><span class="line">[rsync_test]</span><br><span class="line">comment = rsync test</span><br><span class="line">path = /root/rsync_test</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;global-port &#123;&#123; lookup(&apos;ini&apos;, &apos;port section=global file=./demo.ini&apos;) &#125;&#125;&quot;</span><br><span class="line">  - debug: msg=&quot;rsync_test-path &#123;&#123; lookup(&apos;ini&apos;, &apos;path section=rsync_test file=./demo.ini&apos;) &#125;&#125;&quot;</span><br><span class="line"># lookup的第二个参数分为几个部分：要查的字段  section=节的名称  file=文件名 </span><br><span class="line">若是properties文件，则需要添加参数type=properties</span><br><span class="line">完整的几个参数：</span><br><span class="line">参数名            默认值               含义</span><br><span class="line">type             ini                 文件类型</span><br><span class="line">file             ansible.ini         文件名</span><br><span class="line">section          global              节</span><br><span class="line">re               False               字段的正则表达式</span><br><span class="line">default          &quot;&quot;                  字段不存在时的返回值</span><br><span class="line"> </span><br><span class="line">执行结果：</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;global-port 873&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;rsync_test-path /root/rsync_test&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lookup读取CSV文件的指定单元</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">csv文件：</span><br><span class="line">name       age   sex</span><br><span class="line">zhangsan   22    male</span><br><span class="line">lisi       23    male</span><br><span class="line"></span><br><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;&#123;&#123;lookup(&apos;csvfile&apos;, &apos;lisi file=./demo.csv delimiter=, col=0&apos;)&#125;&#125;&quot;</span><br><span class="line"># 获取lisi的第0列，即名字lisi</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;lisi&quot;</span><br><span class="line">&#125;</span><br><span class="line">支持的参数：</span><br><span class="line">参数名      默认值        含义</span><br><span class="line">file       ansible.csv  文件名</span><br><span class="line">col        1            列号（从0开始计数）</span><br><span class="line">delimiter  TAB          CSV文件的分隔符</span><br><span class="line">default    &quot;&quot;           元素不存在时的返回值</span><br><span class="line">encoding   utf-8        CSV文件的编码</span><br></pre></td></tr></table></figure></li><li><p>lookup读取DNS解析的值。可以向DNS服务器查询指定域的DNS记录，可查询任何DNS记录（包括正向和反向）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - debug: msg=&quot;ipv4 address of baidu.com  &#123;&#123; lookup(&apos;dig&apos;, &apos;baidu.com&apos;) &#125;&#125;&quot;</span><br><span class="line">  - debug: msg=&quot;txt record of baidu.com  &#123;&#123; lookup(&apos;dig&apos;, &apos;baidu.com&apos;, &apos;qtype=TXT&apos;) &#125;&#125;&quot;</span><br><span class="line">  - debug: msg=&quot;txt record of baidu.com &#123;&#123; lookup(&apos;dig&apos;, &apos;baidu.com./TXT&apos;) &#125;&#125;&quot;</span><br><span class="line">  - debug: msg=&quot;MX record of 163.com &#123;&#123; lookup(&apos;dig&apos;, &apos;163.com./MX&apos;, &apos;wantlist=True&apos;) &#125;&#125;&quot;</span><br><span class="line">  </span><br><span class="line">需要安装dnspython模块，直接pip install 即可</span><br><span class="line">执行结果：</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;ipv4 address of &apos;baidu.com&apos;   220.181.57.216,123.125.115.110&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;txt record of &apos;baidu.com&apos;  v=spf1 include:spf1.baidu.com include:spf2.baidu.com include:spf3.baidu.com a mx ptr -all,google-site-verification=GHb98-6msqyx_qqjGl5eRatD3QTHyVB6-xQ3gJB5UwM&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;txt record of &apos;baidu.com&apos; v=spf1 include:spf1.baidu.com include:spf2.baidu.com include:spf3.baidu.com a mx ptr -all,google-site-verification=GHb98-6msqyx_qqjGl5eRatD3QTHyVB6-xQ3gJB5UwM&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;MX record of &apos;163.com&apos; 50 163mx00.mxmail.netease.com.,10 163mx01.mxmail.netease.com.,10 163mx03.mxmail.netease.com.,10 163mx02.mxmail.netease.com.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">反向解析：</span><br><span class="line">- debug: msg=&quot;fqdn of &apos;8.8.8.8&apos; &#123;&#123; lookup(&apos;dig&apos;, &apos;8.8.8.8/PTR&apos;) &#125;&#125;&quot;</span><br><span class="line">结果：</span><br><span class="line">ok: [172.16.246.133] =&gt; &#123;</span><br><span class="line">    &quot;msg&quot;: &quot;fqdn of &apos;8.8.8.8&apos; google-public-dns-a.google.com.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Jinja2过滤器"><a href="#Jinja2过滤器" class="headerlink" title="Jinja2过滤器"></a>Jinja2过滤器</h1><p>Jinja2是Python的web开发中常用的模板语言，也被用于管理配置文件。Jinja2是Flask作者仿Django模板开发的模板引擎。但Jinja2具有更好的性能，更加灵活，具有很好的可读性。</p><ul><li>格式化数据</li></ul><ul><li>强制定义变量<br>对于未定义变量，Ansible默认行为是fail，也可关闭。</li></ul><ul><li>未定义变量默认值<br>Jinja2提供一个有用default过滤器，设置默认变量值。比强制定义变量更好。</li></ul><ul><li>忽略未定义变量和参数<br>可使用default过滤器忽略未定义的变量和模块参数</li></ul><p>Jinja2的三种语法：</p><ul><li><p>控制结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% %&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;# #&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Jinja语法"><a href="#Jinja语法" class="headerlink" title="Jinja语法"></a>Jinja语法</h2><p>Jinja2控制结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if ... %&#125;</span><br><span class="line">&#123;% elif ... %&#125;</span><br><span class="line">&#123;% else %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>Jinja2的for循环：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for .. in .. %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>for循环中的特殊变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td>loop.index</td><td>当前循环的次数（从1开始计数）</td></tr><tr><td>loop.index0</td><td>当前循环的次数（从0开始计数）</td></tr><tr><td>loop.revindex</td><td>到循环结束的次数（从1开始计数）</td></tr><tr><td>loop.revindex0</td><td>到循环结束的计数（从0开始计数）</td></tr><tr><td>loop.first</td><td>如果是第一次迭代，为True</td></tr><tr><td>loop.last</td><td>如果是最后一次迭代，为True</td></tr><tr><td>loop.length</td><td>序列中的项目数</td></tr><tr><td>loop.cycle</td><td>在一串序列间取值的辅助函数</td></tr></tbody></table><p>Jinja2的宏。类似函数，将行为抽象成可重复调用的代码块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% macro input(name, type=&apos;text&apos;, value=&apos;&apos;) %&#125;</span><br><span class="line">  &lt;input type=&apos;&#123;&#123; type &#125;&#125;&apos; name=&apos;&#123;&#123; name &#125;&#125;&apos; value=&apos;&#123;&#123; value &#125;&#125;&apos;&gt;</span><br><span class="line">&#123;% endmacro %&#125;</span><br></pre></td></tr></table></figure><p>宏的调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&#123;&#123; input(&apos;username&apos;, value=&apos;user&apos;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&#123;&#123; input(&apos;password&apos;, &apos;password&apos;) &#125;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">&lt;p&gt;&lt;input type=&apos;text&apos;, name=&apos;username&apos;, value=&apos;user&apos;&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;input type=&apos;password&apos;, name=&apos;password&apos;&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>Jinja2继承。若Jinja2仅用于配置文件，则基本用不到继承功能，而在网页开发中，继承相当强大，常用于配置模板文件，在Django和Flask中会被大量使用，减少重复代码的开发编写，使html文件更加简洁易读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block block块名 %&#125;</span><br><span class="line">&#123;% endblock block块名 %&#125; </span><br><span class="line">在endblock中block块名可以不加，但为了阅读性最好加上</span><br><span class="line"></span><br><span class="line">在html文件的最前面应该添加要继承的模板文件</span><br><span class="line">&#123;% extends &quot;xxx.html&quot; %&#125;</span><br><span class="line"></span><br><span class="line">继承模板中指定块的内容</span><br><span class="line">&#123;% block xxx %&#125;</span><br><span class="line">&#123;&#123; super() &#125;&#125;</span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ul><li><p><code>quote</code>：给字符串加上引号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; str | quote &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>default</code>：为没有定义的变量提供默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; variable | default(&apos;xxxx&apos;) &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>omit</code>：忽略变量的占位符。常与dafault合用，当定义了参数时则会调用该参数，而若没有该参数时，则不会传入任何值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; variable | default(omit) &#125;&#125;</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">- file: dest=&#123;&#123; item.path &#125;&#125; state=touch mode=&#123;&#123; item.mode|default(omit) &#125;&#125;</span><br><span class="line">  with_items:</span><br><span class="line">    - path: /tmp/demo1    # demo1没有设置mode，因此mode不会传入任何值。omit起到为有值的item项占位</span><br><span class="line">    - path: /tmp/demo2    # demo2的path和mode都有</span><br><span class="line">      mode: &quot;0664&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>mandatory</code>：强制变量必须定义，否则报错。Ansible默认若变量没有定义，则使用未定义的变量会报错。也可以在Ansible配置文件中修改参数<code>error_on_undefined_vars = False</code>，即使遇到未定义变量，也不会报错。若要强制约束一个变量必须定义，则可以使用<code>mandatory</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; undefined_variable | mandatory &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bool</code>：判断变量是否为布尔类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; variable | bool &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ternary</code>：Playbook的条件表达式。类似(A?B:C)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; 条件判断 | ternary(&quot;满足时采用的值&quot;, &quot;不满足时采用的值&quot;) &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>basename</code>、<code>dirname</code>、<code>expanduser</code>、<code>realpath</code>、<code>relpath</code>、<code>splitext</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; path | basename &#125;&#125;      获取路径中的文件名</span><br><span class="line">&#123;&#123; path | dirname &#125;&#125;       获取文件的目录</span><br><span class="line">&#123;&#123; path | expanduser &#125;&#125;    当前用户目录</span><br><span class="line">&#123;&#123; path | realpath &#125;&#125;      获取链接文件所指文件的真实路径</span><br><span class="line">&#123;&#123; path | relpath &#125;&#125;       获取相对于某一根目录的相对路径</span><br><span class="line">&#123;&#123; path | splitext &#125;&#125;      把文件名用点号分割成多个部分</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  vars:</span><br><span class="line">    conf_path: &quot;/etc/httpd.conf&quot;</span><br><span class="line">    yml_path: &quot;~/a.yml&quot;</span><br><span class="line">  tasks:</span><br><span class="line">    - debug: msg=&quot;&#123;&#123; conf_path | basename &#125;&#125;&quot;</span><br><span class="line">    - debug: msg=&quot;&#123;&#123; conf_path | dirname &#125;&#125;&quot;</span><br><span class="line">    - debug: msg=&quot;&#123;&#123; yml_path | expanduser &#125;&#125;&quot;</span><br><span class="line">    - debug: msg=&quot;&#123;&#123; yml_path | realpath &#125;&#125;&quot;</span><br><span class="line">    - debug: msg=&quot;&#123;&#123; yml_path | relpath(&apos;/home&apos;) &#125;&#125;&quot;</span><br><span class="line">    - debug: msg=&quot;&#123;&#123; conf_path | splitext &#125;&#125;&quot;</span><br><span class="line">    </span><br><span class="line">执行结果：</span><br><span class="line">    &quot;msg&quot;: &quot;httpd.conf&quot;      #/etc/httpd.conf的文件名</span><br><span class="line">    &quot;msg&quot;: &quot;/etc&quot;            #/etc/httpd.conf文件所在目录名</span><br><span class="line">    &quot;msg&quot;: &quot;/root/a.yml&quot;     #~/a.yml，用实际用户替代~</span><br><span class="line">    &quot;msg&quot;: &quot;/root/~/a.yml&quot;   #仅对链接文件有效，指向真实文件的路径</span><br><span class="line">    &quot;msg&quot;: &quot;../root/~/a.yml&quot; #~/a.yml相对于指定路径的相对路径</span><br><span class="line">    &quot;msg&quot;: &quot;(u&apos;/etc/httpd&apos;, u&apos;.conf&apos;)&quot;  #分隔文件与所在目录</span><br></pre></td></tr></table></figure><p>若是Windows系统，Ansible提供的路径过滤器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; path | win_basename &#125;&#125;       # 获取文件名</span><br><span class="line">&#123;&#123; path | win_dirname &#125;&#125;        # 获取文件所在目录路径</span><br><span class="line">&#123;&#123; path | win_splitdrive &#125;&#125;     # 将路径分隔成多个部分</span><br></pre></td></tr></table></figure></li><li><p><code>b64encode</code>、<code>b64decode</code>、<code>to_uuid</code>、<code>hash</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; string | b64encode &#125;&#125;       # 将字符串转化为base64格式</span><br><span class="line">&#123;&#123; string | b64decode &#125;&#125;       # 将字符串（base64格式）解码</span><br><span class="line">&#123;&#123; string | to_uuid &#125;&#125;         # 将字符串转变为UUID</span><br><span class="line">&#123;&#123; string | hash(&apos;sha1&apos;) &#125;&#125;    # 使用sha1求出字符串的哈希，还可用md5、blowfish求</span><br><span class="line">&#123;&#123; string | checksum &#125;&#125;        # 使用checksum求哈希</span><br><span class="line">&#123;&#123; string | password_hash(&apos;&apos;) &#125;&#125;  # 使用哈希算法求密码的hash</span><br></pre></td></tr></table></figure></li><li><p>判断是否是合法IP地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; ip_addr_str | ipaddr &#125;&#125;    # 判断IP地址是否合法</span><br><span class="line">&#123;&#123; ip_addr_str | ipv4 &#125;&#125;      # 返回ipv4地址</span><br><span class="line">&#123;&#123; ip_addr_str | ipv6 &#125;&#125;      # 返回ipv6地址</span><br><span class="line">&#123;&#123; ip_addr_str | ipaddr(&apos;address&apos;) &#125;&#125;  # 返回纯ip地址（不带掩码）</span><br></pre></td></tr></table></figure></li><li><p><code>to_datetime</code>：字符串类型时间转换为时间戳</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; date_str | to_datetime &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Json操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">  vars:</span><br><span class="line">    value:</span><br><span class="line">      - key1: &quot;value1&quot;</span><br><span class="line">      - key2: &quot;value2&quot;</span><br><span class="line">  tasks:</span><br><span class="line">    - name: outputfile /tmp/b.txt</span><br><span class="line">      blockinfile:</span><br><span class="line">        dest: /tmp/b.txt</span><br><span class="line">        block: |</span><br><span class="line">          &#123;&#123; value | to_json &#125;&#125;</span><br><span class="line">          ------------------------</span><br><span class="line">          &#123;&#123; value | to_yaml &#125;&#125;</span><br><span class="line">          ------------------------</span><br><span class="line">          &#123;&#123; value | to_nice_json &#125;&#125;</span><br><span class="line">          ------------------------</span><br><span class="line">          &#123;&#123; value | to_nice_yaml &#125;&#125;</span><br><span class="line"></span><br><span class="line">执行结果：在指定的主机上查看/tmp/b.txt</span><br><span class="line">[&#123;&quot;key1&quot;: &quot;value1&quot;&#125;, &#123;&quot;key2&quot;: &quot;value2&quot;&#125;]</span><br><span class="line">------------------------</span><br><span class="line">- &#123;key1: value1&#125;</span><br><span class="line">- &#123;key2: value2&#125;</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;key1&quot;: &quot;value1&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &#123;</span><br><span class="line">        &quot;key2&quot;: &quot;value2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line">------------------------</span><br><span class="line">-   key1: value1</span><br><span class="line">-   key2: value2</span><br></pre></td></tr></table></figure></li><li><p>在Json对象中搜索符合条件的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  vars:</span><br><span class="line">    host_group:</span><br><span class="line">      cluster1:</span><br><span class="line">        - name: &quot;host1&quot;</span><br><span class="line">        - name: &quot;host2&quot;</span><br><span class="line">  tasks:</span><br><span class="line">    - debug: var=item</span><br><span class="line">      with_items: &quot;&#123;&#123; host_group | json_query(&apos;cluster1[*].name&apos;) &#125;&#125;&quot;</span><br><span class="line">      </span><br><span class="line">执行结果：</span><br><span class="line">ok: [172.16.109.132] =&gt; (item=host1) =&gt; &#123;</span><br><span class="line">    &quot;item&quot;: &quot;host1&quot;</span><br><span class="line">&#125;</span><br><span class="line">ok: [172.16.109.132] =&gt; (item=host2) =&gt; &#123;</span><br><span class="line">    &quot;item&quot;: &quot;host2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="http://www.ansible.com.cn/index.html" target="_blank" rel="noopener">Ansible中文权威指南</a><br><a href="https://linux.cn/article-4215-3.html" target="_blank" rel="noopener">Ansible ：一个配置管理和IT自动化工具</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/7576137.html#ansible" target="_blank" rel="noopener">Ansible系列</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxNTcyNzAyOQ==&amp;mid=2650960643&amp;idx=1&amp;sn=ba6a46d24f181eeb1308087830648cd8&amp;chksm=800973d9b77efacf2e0cc0ad2a4c015b7c67b511f1cb1786f4c74f2243e69e97da2955dce681&amp;mpshare=1&amp;scene=23&amp;srcid=0626IdjKI6mMzTfKSPwq6Dua#rd" target="_blank" rel="noopener">大神带你 20 分钟学会 Ansible！</a><br><a href="https://www.cnblogs.com/ilurker/p/6421624.html" target="_blank" rel="noopener">Ansible详解（一）</a><br><a href="https://www.cnblogs.com/ilurker/p/6421637.html" target="_blank" rel="noopener">Ansible详解（二）</a></p><p><a href="http://www.zsythink.net/archives/category/%E8%BF%90%E7%BB%B4%E7%9B%B8%E5%85%B3/ansible" target="_blank" rel="noopener">朱双印个人日志-Ansible</a></p><p>Linux集群与自动化运维</p><p>Ansible快速入门技术原理与实战</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 监控 </tag>
            
            <tag> 自动化 </tag>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LVS负载均衡学习笔记</title>
      <link href="/2018/05/27/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/27/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇笔记包含以下内容</p><ul><li><a href="#LVS原理">LVS原理</a><ul><li><a href="#LVS集群的通用体系结构">LVS集群的通用体系结构</a></li><li><a href="#三种IP负载均衡技术">三种IP负载均衡技术</a></li><li><a href="#LVS两种调度方式与八种算法">LVS两种调度方式与八种算法</a></li></ul></li><li><a href="#KeepAlived原理">KeepAlived原理</a></li><li><p><a href="#LVS与KeepAlived搭建">LVS与KeepAlived搭建</a></p><ul><li><a href="#NAT模式搭建">NAT模式搭建</a></li><li><a href="#DR模式搭建">DR模式搭建</a><a id="more"></a></li></ul></li><li><p><a href="#使用piranha配置LVS">使用piranha配置LVS</a></p></li></ul><h1 id="LVS原理"><a href="#LVS原理" class="headerlink" title="LVS原理"></a>LVS原理</h1><p>LVS（Linux Virtual Server）Linux虚拟服务器是由章文嵩于1998年开发的负载均衡软件，提供<strong>传输层</strong>和<strong>应用层</strong>的负载均衡，传输层的负载均衡工具为IPVS，应用层的负载均衡工具为KTCPVS。</p><h2 id="LVS集群的通用体系结构"><a href="#LVS集群的通用体系结构" class="headerlink" title="LVS集群的通用体系结构"></a>LVS集群的通用体系结构</h2><p>LVS集群采用三层结构：</p><ul><li><p>负载调度器（load balancer）：整个集群的前端机，将网络请求无缝调度到真实服务器上，使服务器集群的结构对客户透明。因为所有的操作都是在Linux内核完成的，调度开销很小，所以具有很高的吞吐率。</p></li><li><p>服务器池（server pool）：是一组真正执行客户请求的服务器。服务器池的结点数目是可变的，可以在服务器池中增加服务器来满足不断增长的请求负载。对大多数网络服务来说，请求间不存在很强的相关性，请求可以在不同的结点上并行执行。</p></li><li><p>共享存储（shared storage）：为服务器池提供一个共享的存储区，通常是数据库、网络文件系统或者分布式文件系统，这样很容易使得服务器池拥有相同的内容，提供相同的服务。需要一个分布式锁管理器（Distributed Lock Manager）来保证应用程序在不同结点上并发访问的一致性。 </p><img src="/2018/05/27/LVS负载均衡笔记/1.png"></li></ul><p>前端负载均衡器称为Director Server（DR），后端的实际服务器称为Real Server(RS)，IP虚拟服务器软件称为IP Virtual Server（IPVS），IPVS工作在Linux内核中。在调度器的实现技术中，IP负载均衡技术的效率是最高的。</p><p><strong>LVS的几种IP地址</strong></p><ul><li>VIP：virtual IP，DR上接收外网数据包的网卡IP地址</li><li>DIP：director IP，DR上转发数据包到RS的网卡IP地址</li><li>RIP：real IP，RS的IP地址</li><li>CIP：client IP，客户端IP地址</li></ul><p><strong>为什么要用共享存储？</strong><br>共享存储是可选的，但若网络服务需要相同的内容，应该使用共享存储，否则无共享结构的代价会很大，每台服务器需要一样大的存储空间，任何更新需要涉及每一台服务器，系统的维护代价会非常高。分布式文件系统提供良好的<strong>伸缩性和可用性</strong>，分布式文件系统<strong>在每台服务器使用本地硬盘作Cache</strong>，可以使得访问分布式文件系统的速度接近于访问本地硬盘。 </p><p><strong>如何实现高可用性？</strong><br>调度器上有资源监测进程时刻监视各个服务器结点的健康状况，当服务器对<strong>ICMP ping不可达</strong>时或者网络服务在<strong>指定的时间内没有响应</strong>时，资源监测进程会通知内核将该服务器<strong>从调度列表中删除</strong>。一旦监测到服务器恢复工作，通知调度器将其加入调度列表，管理员也可通过命令随时向调度列表添加或移除服务器。<br>调度器存在单点故障问题，因此需要对调度器进行主从备份，并用HeartBeat机制进行主从故障监测。当从调度器不能听得主调度器的心跳时，从调度器通过ARP欺骗 （Gratuitous ARP）来接管集群对外的VIP，同时接管主调度器的工作来提供负载调度服务。当主调度器恢复后，有两种<strong>恢复机制</strong>。第一种为<strong>主调度器自动变成从调度器（类似抢占）</strong>，另一种为<strong>从调度器释放VIP，主调度器收回VIP继续提供负载调度服务</strong>。<br>当主调度器失效时，<strong>主调度器上所有已建立连接的状态信息将丢失，已有连接会中断。</strong>客户需要重新连接从调度器，从调度器才会将新连接调度到各个服务器上。因此，调度器在内核中实现了一种高效同步机制，将主调度器的状态信息及时同步到从调度器。当从调度器接管时，绝大部分已建立的连接会持续下去。 </p><h2 id="三种IP负载均衡技术"><a href="#三种IP负载均衡技术" class="headerlink" title="三种IP负载均衡技术"></a>三种IP负载均衡技术</h2><ul><li><p><strong>VS/NAT</strong>：调度器重写请求报文的目标地址，根据预设算法，将请求分派给实际服务器，实际服务器在响应报文通过调度器时，报文的源地址被重写，再返回给客户。<br><strong>优点：</strong>节约IP地址，能对内部进行伪装<br><strong>缺点：</strong>效率低，返回给请求方的流量需经过DR且请求和响应报文都要DR进行地址的重写，当客户端请求增多时，DR的处理能力会成为瓶颈<br>完整过程：</p><ol><li>PC向调度器发送请求报文，调度器收到后根据调度算法选择后端的实际服务器，将报文中目的IP与目的端口改写为实际服务器的IP地址与端口，并进行转发。</li><li>实际服务器收到后，进行处理，将结果返回给调度器</li><li>调度器再将源IP地址与源端口改回为调度器的IP和端口，回复给PC。</li></ol><img src="/2018/05/27/LVS负载均衡笔记/NAT-huanjing.png" title="NAT-huanjing"><img src="/2018/05/27/LVS负载均衡笔记/NAT-baowen.png" title="NAT-baowen"><p><strong>数据包流向：客户端–&gt;调度器–&gt;实际服务器–&gt;调度器–&gt;客户端</strong></p></li><li><p><strong>VS/TUN</strong>（IP Tunneling）：调度器将请求报文通过IP隧道转发到实际服务器，实际服务器将响应报文直接回复给客户，调度器仅需处理请求报文，将请求报文的地址重写，无需重写响应报文的地址，极大解放了调度器，集群系统的最大吞吐量能提高10倍。</p><p><strong>IP隧道技术：</strong>又称为IP封装技术，可以将带有源和目标IP地址的数据报文使用新的源和目标IP进行<strong>第二次封装</strong>，这样这个报文就可以发送到一个指定的目标主机上</p><p>由于多个RS都共享一个隧道IP（为VIP），所以需要通过ARP进行IP地址解析出MAC，而为了不让RS响应ARP请求导致出现错误，必须对RS进行抑制操作，这样只有DR进行ARP响应，也就让PC认为DR就是实际服务器。</p><p><strong>注：</strong>由于调度器不会对IP报文进行修改，所以TCP报文中的目的端口也不会修改，因此要求RS与DR的端口号必须一致</p><p>完整过程：</p><ol><li>PC发送请求给调度器，调度器进行调度算法选择后端的实际服务器，将原报文进行第二次封装，源地址变为DIP，目的地址变为RIP，然后通过IP隧道发给指定实际服务器。</li><li>实际服务器处理完数据后直接回复给PC</li></ol><p>实际服务器的RIP和DR的DIP可以不处于同一物理网络中，且RIP必须可以和公网通信，即集群节点可以跨互联网实现。<br>实际服务器的隧道接口上需要配置VIP地址，以便接收DR转发的数据包，以及作为响应报文的源IP。<br>DR给RS时需要借助隧道，隧道外层的IP头部的源IP是DIP，目标IP是RIP。而RS响应给客户端的IP头部是根据隧道内层的IP头分析得到的，源IP是VIP，目标IP是CIP。这样客户端就无法区分这个VIP到底是DR的还是服务器组中的。</p><p>VS/TUN模式一般会用来负载调度缓存服务器组，这些缓存服务器一般放置在不同网络环境，可以就近返回数据给客户端。在请求对象不能在缓存服务器本地找到的情况下，缓存服务器要向源服务器发请求，将结果取回，最后将结果返回给客户。</p><img src="/2018/05/27/LVS负载均衡笔记/TUN-huanjing.png" title="TUN-huanjing"><img src="/2018/05/27/LVS负载均衡笔记/TUN-baowen.png" title="TUN-baowen"><p><strong>数据包流向：客户端–&gt;调度器–&gt;实际服务器–&gt;客户端</strong></p></li><li><p><strong>VS/DR</strong>（Direct Routing）：与VS/TUN类似，但调度器改写的是数据包的目的MAC地址，通过链路层进行负载分担。此法没有IP隧道的开销，但要求调度器与实际服务器<strong>必须在同一网段</strong>，也就是说RIP可用公网地址。</p><p>完整过程：</p><ol><li>PC向调度器发送请求，调度器根据调度算法选择后端实际服务器，将数据帧的目的MAC改写为该实际服务器的MAC地址，并转发。</li><li>实际服务器收到后处理完数据后直接将结果回复给PC</li></ol><p><strong>注：</strong>因为与VS/TUN类似，直接修改以太网帧，所以对于IP报文不会做修改，因此<strong>RS的端口号必须与DR一致</strong>。且<strong>RS上必须配置VIP（通过配置环回口IP地址），VIP为网卡别名的IP地址，仅用于回复数据包时使用作为源地址，不能用于通信</strong>。由于流出接口为RIP所在网卡接口，因此源MAC地址为RIP所在接口的MAC地址。且<strong>并不支持端口映射。</strong></p><img src="/2018/05/27/LVS负载均衡笔记/DR-baowen.png" title="DR-baowen"><p><strong>数据包流向：客户端–&gt;调度器–&gt;实际服务器–&gt;客户端</strong></p></li></ul><p><strong>三种模式的比较</strong><br>DR和TUN模式的性能高于NAT，因为不需要DR对响应报文的操作<br>DR性能高于TUN，因为不需要维护IP隧道<br>DR中调度器和实际服务器必须在同一个网段中，TUN可实现跨网段负载均衡。</p><p>只有NAT支持端口映射，DR与TUN都不支持。</p><p><strong>为什么VS/TUN与VS/DR要在环回口L0上配置VIP，能不能在出口网卡上配置VIP？</strong><br>在环回口上配置VIP使得RS能通过路由收到请求数据包，并将结果返回给客户。不可以将VIP配置在出口网卡上，否则真实服务器会响应客户端的ARP请求，客户端上的ARP表就会记录真实服务器的MAC，造成混乱，LB就失效了。必须保证路由器只保存DR上的VIP对应的MAC，即只允许DR进行ARP响应。<br>在环回口配置VIP后，还需要设置<code>arp_ignore=1</code>和<code>arp_announce=2</code>来隐藏RS上的VIP。<strong>应该在配置VIP之前就设置arp参数，防止配置VIP后、设置arp抑制之前被外界主机发现。</strong></p><blockquote><p><code>arp_ignore</code>：接收到ARP请求时的响应级别。默认为0。</p><ul><li>0：响应目的地址是本地任意网卡上的所有IP地址的包</li><li>1：只响应目的地址恰好是入网卡的IP地址的包</li></ul><p><code>arp_announce</code>：将自己的地址向外通告时的通告级别。默认为0。</p><ul><li>0：使用本地任意接口上的任意地址向外通告</li><li>1：尽量避免使用本地属于对方子网的IP地址向外通告</li><li>2：总是使用最佳本地地址向外通告</li></ul><p><strong>arp_announce为2的含义</strong>：在此模式下将<strong>忽略这个IP数据包的源地址</strong>并尝试选择<strong>能与该地址通信的本地地址</strong>。<strong>首要</strong>是选择所有网络接口的子网中包含该数据包目标IP地址的本地地址，如果没有发现合适的地址，将选择当前的发送网络接口或其他有可能接收到该ARP回应的网络接口来进行发送。</p><p>且这两项<strong>对所有参与集群调度的网卡都要设置</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.conf.all.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.ens33.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.lo.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.all.arp_announce=2</span><br><span class="line">sysctl -w net.ipv4.conf.ens33.arp_announce=2</span><br><span class="line">sysctl -w net.ipv4.conf.lo.arp_announce=2</span><br></pre></td></tr></table></figure><p><strong>IPVS如何解决HTTPS连接问题？</strong><br>当客户访问HTTPS服务时，会先建立一个SSL连接，来交换对称公钥加密的证书并协商一个SSL Key，来加密以后的会话。<strong>在SSL Key的生命周期内，后续的所有HTTPS连接都使用这个SSL Key，所以同一客户的不同HTTPS连接也存在相关性</strong>。IPVS调度器提供了持久服务的功能，使得在设定的时间内，来自同一IP地址的不同连接会被发送到集群中同一个服务器结点，可以很好地解决客户连接的相关性问题。 </p><p><strong>可伸缩的缓存服务</strong><br>调度器一般使用IP隧道方法（VS/TUN）来架构缓存集群，因为缓存服务器可能在不同地方，而调度器与缓存服务器池可能不在同一个物理网段。若请求对象不能在本地找到，缓存服务器会向源服务器发请求，将结果取回并返回给客户。<br>使用此方法，调度器只调度网页缓存服务器，而缓存服务器将响应数据直接返回给客户，调度器只需要调度一次请求，其余三次都由缓存服务器直接访问Web服务器完成。<br>缓存服务器间有专用的组播通道，通过ICP（Internet Cache Protocol）协议交互信息。当一台Cache服务器在本地硬盘中未命中当前请求时，它可以通过ICP查询其他Cache服务器是否有请求对象的副本，若存在，则从邻近的Cache服务器取该对象的副本，这样可以进一步提高Cache服务的命中率。 </p><p><strong>可伸缩邮件服务</strong><br>服务器池有LDAP服务器和一组邮件服务器，调度器将SMTP、POP3、IMAP4和HTTP/HTTPS请求流负载较均衡地分发到各邮件服务器上。系统中可能的瓶颈是LDAP服务器，可对LDAP服务中B+树的参数进行优化。<br>若分布式文件系统没有多个存储结点间的负载均衡机制，则需要相应的邮件迁移机制来避免邮件访问的倾斜。 </p><h2 id="LVS两种调度方式与八种算法"><a href="#LVS两种调度方式与八种算法" class="headerlink" title="LVS两种调度方式与八种算法"></a>LVS两种调度方式与八种算法</h2><p><strong>两种调度方式</strong></p><ul><li>静态调度：仅根据调度算法进行调度，不管实际服务器的系统负载</li><li>动态反馈调度：会根据实际服务器的系统负载及性能，计算出可以调度的服务器对象</li></ul><p><strong>八种算法</strong></p><ul><li>静态调度<ul><li><strong>轮询</strong>（Round Robin）：调度器将请求根据调度算法按顺序轮流分配到实际服务器。调度器均等地对待每一台服务器，不管服务器上实际的连接数和系统负载。</li><li><strong>加权轮询</strong>（Weighted Round Robin）：根据实际服务器的不同处理能力调度访问请求。使处理能力强的服务器处理更多访问流量，调度器自动询问实际服务器负载情况，并动态调整权值。</li><li><strong>目标地址散列</strong>（Destination Hashing）：将请求的目标地址作为散列键，从静态分配的散列表中找出对应的服务器。</li><li><strong>源地址散列</strong>（Source Hashing）：将请求的源地址作为散列键，从静态分配的散列表中找出对应服务器。</li></ul></li><li>动态反馈调度<ul><li><strong>最少连接</strong>（Least Connections）：动态将网络请求调度到已建立的连接数最少的服务器上。计算方法：活跃连接数active*256+非活跃连接数inactive</li><li><strong>加权最少连接</strong>（Weighted Least Connections）：当集群中服务器性能差异较大的情况下使用。具有较高权值的服务器将承受较大比例的活动连接负载。调度器可以自动问询真实服务器的负载情况并动态调整权值。<strong>此算法为默认调度算法。</strong>计算方法：(active*256+inactive)/weight</li><li><strong>基于局部性最少连接</strong>（Locality-Based Least Connections）：针对IP地址的负载均衡，用于缓存集群系统。根据请求的IP地址找出该目标IP地址最近使用的服务器，若该服务器不可用，则用最少连接原则选出一个可用的服务器。该算法维护的是从一个目标IP地址到<strong>一台</strong>服务器的映射。</li><li><strong>带复制的基于局部性最少连接</strong>（Locality-Based Least Connections with Replication）：针对IP地址的负载均衡，根据请求的目标IP地址找出与之对应的服务器组，按最小连接原则选出一台服务器。若该服务器超载，就在集群中按最小连接原则选出一台服务器，添加到服务器组中。该算法维护的是从一个目标IP地址到<strong>一组</strong>服务器的映射。</li></ul></li></ul><h1 id="KeepAlived原理"><a href="#KeepAlived原理" class="headerlink" title="KeepAlived原理"></a>KeepAlived原理</h1><p>KeepAlived用于RS的健康状态检查与LB主从之间的故障转移（Failover）实现。 Keepalived实现了一组健康检查器，根据其健康状况动态自适应地维护和管理负载平衡的服务器池。使用VRRP实现高可用性，VRRP是路由器故障转移的基础实现方法。此外，keepalived实现了一组到VRRP有限状态机的挂钩，提供低级别的高速协议交互。每个Keepalived框架可以独立使用或一起使用，以提供弹性基础设施。</p><p>Keepalived采用纯ANSI/ISO C编写，围绕一个中央I/O多路复用器提供实时网络设计（Realtime Networking Design）。设计重点是在所有元素之间提供均匀的模块化功能。</p><p>为了确保鲁棒性和稳定性，守护进程keepalived分为3个不同的进程： </p><ul><li>一个精简的父进程负责分支子进程的监控</li><li>两个子进程，一个负责VRRP框架，另一个负责健康检查</li></ul><p>每个子进程都有自己的调度I/O多路复用器，这样VRRP调度抖动得到了优化，因为VRRP调度比健康检查者更关键。这种拆分设计可最小化健康检查外部库的使用情况，并将其自身行为降至最低，使主机闲置，从而避免由其本身造成的故障。</p><p>父进程监视框架称为<strong>Watchdog</strong>，每个子进程打开一个套接字，当守护进程引导时，父进程连接到套接字并向子进程周期（5s）发送hello包。若父进程无法向子进程套接字发送hello，则只要重启子进程即可。</p><p>Watchdog设计的优点：<br>从父进程发送到子进程的hello数据包通过I/O多路复用器调度程序完成，这样可以检测到子进程调度框架中的死循环并能通过使用sysV信号来检测死亡的子进程。</p><p>Keepalived使用四个Linux内核组件：</p><ul><li>LVS框架：使用getsockopt和setsockopt调用来获取和设置套接字上的选项。</li><li>Netfilter框架：支持NAT和伪装（ Masquerading）的IPVS代码。</li><li>Netlink接口：设置和删除网络接口上的VRRP虚拟IP。</li><li>组播：通过组播地址224.0.0.18发送VRRP通告。</li></ul><h2 id="LVS-KeepAlived搭建"><a href="#LVS-KeepAlived搭建" class="headerlink" title="LVS+KeepAlived搭建"></a>LVS+KeepAlived搭建</h2><p>首先在DR上安装依赖工具包<code>libnl3-devel</code>、<code>popt-static</code>，然后安装<code>ipvsadm</code>。<br><code>ipvsadm</code>是ipvs的命令行管理工具，可以定义、删除、查看virtual service和Real Server的属性。</p><p>可通过<code>grep -i &#39;ip_vs&#39; /boot/config-内核版本号</code>查看是否内核中编译了IPVS功能</p><p><a href="http://www.linuxvirtualserver.org/software/index.html" target="_blank" rel="noopener">ipvsadm的下载地址</a><br>也可以通过yum安装，安装完成后启动并设置开机自启<br><code>systemctl enable ipvsadm</code>,<code>systemctl start ipvsadm</code></p><p>ipvsadm命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm选项中，大写选项管理虚拟服务virtual service，小写选项管理关联了虚拟服务的真实服务器RealServer</span><br><span class="line">1. 管理virtual service</span><br><span class="line">    -A --add-service    # 添加virtual service</span><br><span class="line">        -t --tcp-service 服务器IP[:端口]    # TCP服务</span><br><span class="line">        -u --udp-service 服务器IP[:端口]    # UDP服务</span><br><span class="line">        -f --fwmark-service 防火墙标记      # 防火墙标记</span><br><span class="line">        -s --scheduler 算法                # 指定算法</span><br><span class="line">    -E   # 修改，参数与-A一致</span><br><span class="line">    -D   # 删除，参数与-A一致</span><br><span class="line">        -t|-u|-f</span><br><span class="line">    -C   # 清空所有虚拟服务（IPVS规则）</span><br><span class="line">    -L   # 查看所有虚拟服务</span><br><span class="line">        -n 数字格式显示主机地址和端口</span><br><span class="line">        --stats 显示更详细的统计信息（连接数、入站包、出站包量等）</span><br><span class="line">        --rate  显示速率（每秒连接数CPS、每秒入站包个数InPPS、出站包个数OutPPS等）且是实时的</span><br><span class="line">        --timeout 显示会话超时时间（tcp、tcpfin、udp）</span><br><span class="line">        -c    显示当前IPVS的连接状况，实时的</span><br><span class="line">        --sort   排序，是实时的</span><br><span class="line">    -S   # 保存IPVS规则，并输出到屏幕。可通过 &gt;文件，导入到文件</span><br><span class="line">    -R   #载入之前的规则（要指定规则文件）。一般通过 &lt;文件，导入规则</span><br><span class="line">    </span><br><span class="line">2. 管理RealServer</span><br><span class="line">    -a   # 添加real server</span><br><span class="line">        -r 指定RS的IP地址和端口</span><br><span class="line">        -g DR模式</span><br><span class="line">        -i TUN模式</span><br><span class="line">        -m NAT模式</span><br><span class="line">        -t|-u|-f</span><br><span class="line">        -w 权重</span><br><span class="line">    -e   # 编辑real server</span><br><span class="line">    -d   # 删除real server</span><br></pre></td></tr></table></figure></p><h3 id="VS-NAT模式搭建"><a href="#VS-NAT模式搭建" class="headerlink" title="VS/NAT模式搭建"></a>VS/NAT模式搭建</h3><p>实验环境：</p><ul><li>Client：192.168.205.151</li><li>VIP：192.168.205.152</li><li>DIP：172.16.184.130</li><li>RIP1：172.16.184.131</li><li>RIP2：172.16.184.132</li></ul><img src="/2018/05/27/LVS负载均衡笔记/2.png"><p>Client和RS都采用单网卡，但非同一网段。DR采用双网卡，一张连接Client，一张连接RS。且此实验RS要用host-only网卡，需要设置网关</p><p><code>route add default gw 172.16.184.130</code></p><p>确保Server3和Server4的网关配置生效，否则无法给Client连接。</p><p><strong>注：一定要将网卡配置为静态IP地址，不能使用DHCP获取，否则配置的网关会自动消失。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.16.184.130  0.0.0.0         UG    0      0        0 ens36</span><br><span class="line">172.16.184.0    0.0.0.0         255.255.255.0   U     100    0        0 ens36</span><br><span class="line"># ip route </span><br><span class="line">default via 172.16.184.130 dev ens36 </span><br><span class="line">172.16.184.0/24 dev ens36  proto kernel  scope link  src 172.16.184.131  metric 100</span><br></pre></td></tr></table></figure><p>Client请求过程：Client向DR发请求包，VIP接收，经过ip_forward转发到DIP，然后根据算法选择RS，将数据包发往RS。<br>RS响应过程：RS向DR发响应包，DR的DIP接收响应包，经过ip_forward转发到VIP，最后将包回复给Client。<br><strong>因为VIP与DIP不是一个网段，所以DR上要开启ip_forward</strong>，并且要注意iptables与ipvs不可同时配置。</p><p><code>echo &quot;net.ipv4.ip_forward=1&quot; &gt;&gt; /etc/sysctl.conf &amp;&amp; sysctl -p</code> </p><p>在Server2上配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A -t 192.168.205.152:80 -s rr</span><br><span class="line">ipvsadm -a -t 192.168.205.152:80 -r 172.16.184.131 -m</span><br><span class="line">ipvsadm -a -t 192.168.205.152:80 -r 172.16.184.131 -m</span><br></pre></td></tr></table></figure><p>通过<code>ipvsadm -nL</code>查看LVS服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ipvsadm -Ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.205.152:80 rr</span><br><span class="line">  -&gt; 172.16.184.131:80            Masq    1      0          0         </span><br><span class="line">  -&gt; 172.16.184.132:80            Masq    1      0          0</span><br></pre></td></tr></table></figure><p>LVS需要服务器间的时间同步，因此需要在Server2上配置chronyd服务。修改<code>/etc/chronyd.conf</code>，添加更新源。然后<code>chronyc sources -v</code>自动同步。</p><p>然后在Server3和Server4的chronyd配置文件中修改更新源<code>server 192.168.205.152 iburst</code>并自动更新。</p><p>在Client上多次访问<code>192.168.205.152</code>，因为选择的算法是轮询，所以会有以下现象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># curl 192.168.205.152</span><br><span class="line">Server 3</span><br><span class="line"># curl 192.168.205.152</span><br><span class="line">Server 4</span><br><span class="line"># curl 192.168.205.152</span><br><span class="line">Server 3</span><br><span class="line"># curl 192.168.205.152</span><br><span class="line">Server 4</span><br></pre></td></tr></table></figure><p>在Server2上查看<code>ipvsadm -L --stats</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ipvsadm -L --stats</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port               Conns   InPkts  OutPkts  InBytes OutBytes</span><br><span class="line">  -&gt; RemoteAddress:Port</span><br><span class="line">TCP  server2:http                        7       34       20     2235     2240</span><br><span class="line">  -&gt; server3:http                        3       14        8      918      896</span><br><span class="line">  -&gt; server4:http                        4       20       12     1317     1344</span><br></pre></td></tr></table></figure><p>修改为wrr算法。在Server2上修改IPVS规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -E -t 192.168.205.152:80 -s wrr</span><br><span class="line">ipvsadm -e -t 192.168.205.152:80 -r 172.16.184.131:80 -m -w 5</span><br><span class="line">ipvsadm -e -t 192.168.205.152:80 -r 172.16.184.132:80 -m -w 3</span><br></pre></td></tr></table></figure><p>Client上访问几次，再在Server2上查看，可发现访问Server3和Server4的包数量比例大约为5:3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ipvsadm -L -n</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.205.152:80 wrr</span><br><span class="line">  -&gt; 172.16.184.131:80            Masq    5      0          22        </span><br><span class="line">  -&gt; 172.16.184.132:80            Masq    3      0          13</span><br></pre></td></tr></table></figure><h3 id="VS-DR模式搭建"><a href="#VS-DR模式搭建" class="headerlink" title="VS/DR模式搭建"></a>VS/DR模式搭建</h3><p>环境：</p><ul><li>DR的VIP：172.16.246.140</li><li>DIP：172.16.246.134</li><li>RIP1：172.16.246.135</li><li>RS1的VIP：172.16.246.140</li><li>RIP2：172.16.246.136</li><li>RS2的VIP：172.16.246.140</li></ul><p>一定要确保DR和RS在同一个交换机上，即都在同一个网段，以及VIP都要在同一个网段。</p><img src="/2018/05/27/LVS负载均衡笔记/3.png"><p>首先在DR上配置，创建网卡别名<code>ens33:0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig ens33:0 172.16.246.140 netmask 255.255.255.0 broadcast 172.16.246.255 up  # 这是临时的，切要确保地址都是静态的，否则过一段时间配的地址会自动删除</span><br><span class="line"></span><br><span class="line"># ifconfig </span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.246.134  netmask 255.255.255.0  broadcast 172.16.246.255</span><br><span class="line">......</span><br><span class="line">ens33:0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.16.246.140  netmask 255.255.255.0  broadcast 172.16.246.255</span><br><span class="line">        ether 00:0c:29:bf:f9:0c  txqueuelen 1000  (Ethernet)</span><br></pre></td></tr></table></figure><p>在两个后端RS服务器上<code>ping</code>DR上的这两个地址，测试能够联通</p><p>然后在RS上配置IP地址，也确保为静态IP。并且需要将RS的内核参数<code>arp_ignore</code>和<code>arp_announce</code>分别调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.conf.all.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.ens33.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.lo.arp_ignore=1</span><br><span class="line">sysctl -w net.ipv4.conf.all.arp_announce=2</span><br><span class="line">sysctl -w net.ipv4.conf.ens33.arp_announce=2</span><br><span class="line">sysctl -w net.ipv4.conf.lo.arp_announce=2</span><br></pre></td></tr></table></figure><p>然后在环回口上配置VIP，保证DR、RS的VIP相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig lo:0 172.16.246.140 netmask 255.255.255.255 boardcast 172.16.246.140 up</span><br><span class="line"># 一定要设置netmask为255.255.255.255，否则连接可能出问题</span><br></pre></td></tr></table></figure><p>并且配置路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">route add -host 172.16.246.140 dev lo:0</span><br><span class="line"></span><br><span class="line"># route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">172.16.246.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33</span><br><span class="line">s3              0.0.0.0         255.255.255.255 UH    0      0        0 lo</span><br></pre></td></tr></table></figure><p>在DR上篇配置路由<code>route addd -host 172.16.246.140 dev ens33:0</code></p><p>确保RS与DR的防火墙都放行了http以及对应端口。</p><p>在DR上配置LVS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipvsadm -A -t 172.16.246.140:80 -s wlc</span><br><span class="line">ipvsadm -a -t 172.16.246.140:80 -r 172.16.246.135 -g -w 3</span><br><span class="line">ipvsadm -a -t 172.16.246.140:80 -r 172.16.246.136 -g -w 4</span><br></pre></td></tr></table></figure><p>在宿主机上测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># curl 172.16.246.140</span><br><span class="line"></span><br><span class="line"># ipvsadm -L</span><br><span class="line">....</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  s1:http wlc</span><br><span class="line">  -&gt; rs1:http                     Route   3      0          13        </span><br><span class="line">  -&gt; rs2:http                     Route   4      0          17</span><br></pre></td></tr></table></figure><blockquote><p>参考文档<br><a href="http://www.linuxvirtualserver.org/zh/index.html" target="_blank" rel="noopener">LVS中文官方文档</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/8451982.html#1-lvs-" target="_blank" rel="noopener">骏马金龙LVS系列文章</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193749&amp;idx=1&amp;sn=9321bf2c628b8d60913336ff6592f823&amp;chksm=8c99f4cfbbee7dd9e580eac24a5d481993a09bc93720dddc70d602e38e923012e1d7b245a76e&amp;mpshare=1&amp;scene=23&amp;srcid=0528GJKDr5wutmhQnNTVwG1H#rd" target="_blank" rel="noopener">负载均衡的原理</a><br>高性能网站构建实战<br><a href="https://mp.weixin.qq.com/s?__biz=MzA4NzQzMzU4Mg==&amp;mid=2652921952&amp;idx=1&amp;sn=c9e4cee313f9052095d499d5be41c2dd&amp;chksm=8bed4861bc9ac1778610eace025dfa685e661f04b53b539666b597d649e3429be01048242010&amp;mpshare=1&amp;scene=23&amp;srcid=0710bpqIBIAZyCVTrxFmag58#rd" target="_blank" rel="noopener">Linux之虚拟服务器LVS搭建</a></p><p><a href="http://blog.51cto.com/manito/590937" target="_blank" rel="noopener">lvs arp问题配置误区</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> LVS </tag>
            
            <tag> keepalived </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Wireshark学习笔记</title>
      <link href="/2018/05/18/wireshark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/18/wireshark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<img src="/2018/05/18/wireshark学习笔记/wireshark_logo.png" title="wireshark_logo"><p><strong>基于wireshark v2.4.5</strong><br>本篇包含以下内容</p><ul><li><a href="#基本操作">基本操作</a><ul><li><a href="#抓包过滤器">抓包过滤器</a></li></ul></li><li><a href="#高级功能">高级功能</a></li><li><a href="#tshark命令使用">tshark命令使用</a><a id="more"></a></li></ul><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>两种过滤器：</p><ul><li>捕获过滤器 Capture Filter：也称抓包过滤器，使用伯克利包过滤语言（BPF），依赖于BPF的库（libpcap，Winpcap），用于限制抓的包，即抓包前的设定</li><li>显示过滤器 Display Capture：用于限制已经抓的包的显示，即抓包后的设定</li></ul><h3 id="捕获过滤器"><a href="#捕获过滤器" class="headerlink" title="捕获过滤器"></a>捕获过滤器</h3><ol><li>type（类型）限定词<br> host、net、port、portrange</li><li>dir（方向）限定词<br> src、dst</li><li>proto（协议）限定词<br> ether、arp、icmp、ip、tcp、udp、http、ftp</li></ol><p>逻辑运算：<code>&amp;&amp;</code>或<code>and</code>（与）、<code>||</code>或<code>or</code>（或）、<code>!</code>或<code>not</code>（非）<br>过滤器基本语法<br><code>[protocol] [direction] [host] [value] [logical operations] [other expression]</code></p><p>捕获–&gt;捕获过滤器 有常用的语法案例<br><img src="/2018/05/18/wireshark学习笔记/buhuo1.PNG" title="buhuo1"></p><p>常用过滤表达式举例：<br><code>ether</code></p>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基础学习笔记</title>
      <link href="/2018/05/17/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/17/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇笔记主要包含以下内容<br><img src="/2018/05/17/Redis学习笔记/redis-logo.png"></p><ul><li><a href="#Redis介绍">Redis介绍</a></li><li><a href="#Redis安装">Redis安装</a></li><li><a href="#Redis数据类型">Redis数据类型</a></li><li><a href="#排序">排序</a><a id="more"></a></li><li><a href="#发布与订阅">发布与订阅</a></li><li><a href="#事务">事务</a></li><li><a href="#过期时间">过期时间</a></li><li><a href="#持久化">持久化</a></li><li><a href="#Redis优化技术">Redis优化技术</a><ul><li><a href="#管道">管道</a></li><li><a href="#内部编码优化">内部编码优化</a></li><li><a href="#性能测试">性能测试</a></li></ul></li><li><a href="#集群">集群</a></li><li><a href="#管理">管理</a></li><li><a href="#Redis配置文件常用参数">Redis配置文件常用参数</a></li><li><a href="#在Docker上搭建Redis">在Docker上搭建Redis</a></li><li><a href="#FAQ">FAQ</a></li><li><a href="#Redis报错问题">Redis报错问题</a></li></ul><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>Redis（Remote Dictionary Server）是由C语言写成的高性能key-value非关系型数据库。<br>为了保证效率，Redis的数据都缓存在内存中，并周期性地将更新的数据写入磁盘，或将修改写入记录文件，在此基础上实现了主从同步。</p><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><ul><li>因为Redis是由C语言写的，所以要装gcc。<br><code>yum install gcc</code></li><li>安装jemalloc，用于动态内存分配，是malloc的一个优化版本<br><code>yum install jemalloc</code></li><li>安装工具命令语言TCL<br><code>yum install tcl</code></li><li>解压redis包到<code>/usr/local</code>，进入后<code>make &amp;&amp; make install</code>即可编译安装，可先<code>make test</code>检查是否出错</li><li>建立软连接，redis的命令都存放在<code>/usr/local/redis/src/</code>目录下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/redis/src/redis-server /bin/redis-server</span><br><span class="line">ln -s /usr/local/redis/src/redis-cli /bin/redis-cli</span><br><span class="line">ln -s /usr/local/redis/src/redis-benchmark /bin/redis-benchmark</span><br><span class="line">ln -s /usr/local/redis/redis.conf /etc/redis.conf</span><br></pre></td></tr></table></figure></li></ul><p>如果可用内存十分小，最好要设置内核参数<code>vm.overcommit_memory</code>为1。</p><p><code>overcommit_memory</code>指定了内核针对内存分配的策略：</p><ul><li><code>0</code>：内核将检查是否有足够可用内存供应用进程使用。若不足，会报错</li><li><code>1</code>：内核允许分配所有物理内存，不管当前内存状态。</li><li><code>2</code>：内核允许分配<strong>超过</strong>所有物理内存和swap之和的内存大小。</li></ul><p><code>echo &quot;vm.overcommit_memory=1&quot; &gt;&gt; /etc/sysctl.conf</code>并且<code>sysctl -p</code></p><p><strong>redis命令</strong></p><ul><li><p><code>redis-server</code>用于开启redis服务器端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[redis.conf文件路径] 设置配置文件路径，即可按照指定配置启动redis-server</span><br><span class="line">--[配置参数]  设置指定参数</span><br><span class="line">例：--port=6378</span><br><span class="line">-v 查看redis版本</span><br></pre></td></tr></table></figure></li><li><p><code>redis-cli</code>开启客户端命令行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-h [hostname]  指定要连接的redis服务器主机名，默认127.0.0.1</span><br><span class="line">-p [port] 指定服务器端口，默认6379</span><br><span class="line">-s [socket] 指定服务器socket，会覆盖主机名和端口</span><br><span class="line">-a [password] 设置连接redis服务器时要用的密码</span><br><span class="line">-u [uri] 设置服务器的URI</span><br><span class="line">shutdown 关闭redis</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：</strong>若要让redis默认在后台启动，可修改配置文件中<code>daemonize 参数</code>，若为no，则是前台启动，若为yes，则是后台启动</p><ul><li><code>redis-check-aof</code>与<code>redis-check-rdb</code>：用于检测持久化状态或进行修复</li></ul><p><strong>redis-cli基本操作</strong><br><code>exists [key]</code> 查看键是否存在，存在返回1，否则返回0<br><code>del [key]</code> 删除键<br><code>type [key]</code> 返回键的数据类型<br><code>keys [pattern]</code> 返回符合指定匹配规则的键，支持glob风格通配符格式。<br><code>rename [old-key] [new-key]</code> 重命名键<br><code>dbsize</code> 返回当前数据库的键数量<br><code>expire [key] [time]</code> 指定键的生存时间（单位秒），返回1说明设置成功。未设置默认键的生存时间是无穷，会一直占用空间。<br><code>ttl [key]</code> 返回键的剩余生存时间，-1表示永久，-2表示不存在（已删除）<br><code>select [db-num]</code> 选择数据库编号</p><blockquote><p>0为默认，从1开始会在端口后显示，最大为15，即最多有16个数据库。若超出范围，虽会显示该编号，但是仅会对15号数据库操作。</p></blockquote><p><code>move [key] [db-num]</code> 将指定键移动到指定数据库（不是复制）<br><code>flushdb</code> 删除当前数据库中所有键<br><code>flushall</code> 删除所有数据库的所有键</p><p><strong>glob风格通配符</strong></p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配一个字符</td></tr><tr><td>*</td><td>匹配任意个字符</td></tr><tr><td>[]</td><td>匹配括号建的任一字符</td></tr></tbody></table><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><ul><li><p><strong>字符串String</strong>：可包含任意数据，包括图片和序列化对象，单个值上限512MB</p></li><li><p><strong>列表List</strong>：<strong>双向链表</strong>，通过push和pop从链表头部或尾部添加删除元素，因此即可用作栈也可用作队列，且都是双向的</p></li><li><p><strong>哈希Hash</strong>：也称散列，字符串类型的键值对的映射表，<strong>适合存储对象</strong>，每个Hash可存储2^32-1个键值对。</p><p>新建的hash对象以zipmap来存储，zipmap本身不是hash table，但相比正常的hash，可以节省hash自身需要的元数据存储开销。</p><p>zipmap的增删改的复杂度都是O(n)，但是一般对象的field都不多，所以速度也较快。若field或value的大小超出一定限制，则redis会自动将zipmap替换为正常的hash实现。</p><p>可通过配置文件的<code>hash-max-ziplist-entries</code>和<code>hash-max-ziplist-value</code>设置限制大小，单位字节。默认entries设为512，value设为64</p></li><li><p><strong>集合Set</strong>：字符串类型的无序集合，通过Hash表实现，所有操作的复杂度都为O(1)，最多可包含2^32-1个键值对</p></li><li><p><strong>有序集合Sorted Set</strong>：也称ZSet，每个元素都会关联一个double类型的分数，称为权。redis正是通过权来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但权却可以重复。</p></li></ul><p><strong>redis-cli操作</strong></p><ul><li><p><strong>字符串</strong><br><code>set [key] [value]</code> 设置键值</p><p><code>setnx [key] [value]</code>：设置键值，若key已存在，则不会修改该值，并返回0</p><p><code>setex [key] [expire time][value]</code>：设置键值以及有效时间</p><p><code>mset [key1] [value1] [key2] [value2] ...</code> 同时设置多个键值</p><p><code>msetnx</code>：设置多个键值，但若key存在，则不会修改值</p><p><code>get [key]</code> 获取键值<br><code>mget [key1] [key2] ...</code>同时获取多个键的值<br><code>getrange [key] [start] [end]</code> 返回键中字符串值的子字符串<br><code>setrange [key] [start] [end]</code> 设置字符串值的子串值<br><code>getset [key] [value]</code> 设置键的值并返回旧值<br><code>strlen [key]</code> 返回该键的字符串值的长度<br><code>incr [key]</code> 设置键值自增，返回新值<br><code>decr [key]</code> 设置键值自减，返回新值<br><code>incrby [key] [value]</code> 设置键值自增指定value，返回新值<br><code>descby [key] [value]</code> 设置键值自减指定value，返回新值<br><code>append [key] [value]</code> 指定键追加值value，返回新值长度<br><code>substr [key] [start] [end]</code> 取字符串（字符编号从0开始）</p></li><li><p><strong>列表</strong><br><code>lpush [list] [member1] [member2]...</code> 在list头部添加元素<br><code>rpush [list] [member1] [member2]...</code> 在list尾部添加元素<br><code>lpop [list]</code> 在list头部删除元素，返回删除元素<br><code>rpop [list]</code> 在list尾部删除元素，返回删除元素</p><p><code>linsert [list] before|after [指定值][value]</code>：在指定list的特定位置前或后添加字符串value</p><p><code>lset [list][index][value]</code>：设置指定下标的值</p><p><code>lrem [list][num][value]</code>：删除list中num个和value值一致的值。若num&gt;0，则从头开始删，若num&lt;0，则从尾开始删，若num为0，删除全部</p><p><code>llen [list]</code> 返回list的长度<br><code>lindex [list] [index]</code> 获取列表中对应索引的元素<br><code>lrange [list] [start] [end]</code> 返回list指定区间的元素（编号从0开始）<br><code>ltrim [list] [start] [end]</code> 截取list，只保留截取区间的元素</p></li><li><p><strong>集合</strong><br><code>sadd [set] [member1] [member2]...</code> 添加集合元素<br><code>srem [set] [member1] [member2]...</code> 删除集合元素</p><p><code>spop [set] [value]</code>：删除指定value</p><p><code>scard [set]</code> 返回集合元素个数<br><code>smove [set1] [set2] [value]</code> 将指定元素从set1移到set2<br><code>sismember [set] [value]</code> 判断该元素是否属于指定集合<br><code>smembers [set]</code> 返回集合中所有元素</p><p><code>srandmember [set]</code>：随机返回set中的一个值</p><p><code>sinter [set1] [set2]</code> 返回集合的交集<br><code>sinterstore [set3] [set1] [set2]</code> 将集合的交集存储到set3集合中<br><code>sunion [set1] [set2]</code> 返回集合的并集<br><code>sunionstore [set3] [set1] [set2]</code> 将集合的并集存储到key3集合中<br><code>sdiff [set1] [set2]</code> 返回集合的差集<br><code>sdiffstore [key3] [key1] [key2]</code> 将集合的差集存储到key3集合中</p></li><li><p><strong>有序集合</strong><br><code>zadd [key] [score1] [member1]...</code> 向有序集合添加成员并设置权值<br><code>zrem [key] [member]</code> 删除集合元素<br><code>zincrby [key] [incr] [member]</code> 设置元素的增加值<br><code>zrank [key] [member]</code> 返回指定元素的下标（从小到大）<br><code>zrevrank [key] [member]</code> 返回指定元素的下标（从大到小）<br><code>zrange [key] [start] [end]</code> 返回集合的指定区间元素<br><code>zrevrange [key] [start] [end]</code> 返回集合的指定区间元素（逆序）</p><p><code>zrangebyscore [key][start][end]</code>：返回score在指定范围间的元素。可在最后添加参数<code>withscores</code>返回该元素的score</p><p><code>zcount [key][start][end]</code>：返回score在指定范围内的元素个数</p><p><code>zcard [key]</code> 返回集合元素个数<br><code>zscore [key] [member]</code> 返回元素的权值<br><code>zremrangebyrank [key] [start] [end]</code> 删除集合中给定排名区间的元素</p><p><code>zremrangebyscore [key][start][end]</code>：删除集合中score在指定范围内的元素</p></li><li><p><strong>哈希</strong><br><code>hset [table] [column] [value]</code> 设置字段column的值</p><p><code>hsetnx [table][column][value]</code>：设置字段值，若字段存在则不会修改值，并返回0</p><p><code>hget [table] [column]</code> 获取字段的值<br><code>hmset [table] [column1] [value1]...</code> 设置多个字段的值<br><code>hmget [table] [column1] [column2]...</code> 获取多个字段的值<br><code>hincrby [table] [column] [incr]</code> 字段增加指定值<br><code>hexists [table] [column]</code> 字段是否存在</p><p><code>hlen [table]</code>：返回指定hash的字段数</p><p><code>hdel [table] [column]...</code> 删除表中字段<br><code>hdel [table]</code> 删除表<br><code>hkeys [table]</code> 返回表的所有字段<br><code>hvals [table]</code> 返回表的所有值<br><code>hgetall [table]</code> 返回表的所有字段与值</p></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Redis支持对list、set、sorted set的排序。<br><code>sort [key] [BY partten][LIMIT offset count][GET pattern][ASC|DESC][ALPHA][STORE dstkey]</code></p><ul><li><p>sort默认排序为从小到大，若要按照字母顺序排可选择<code>ALPHA</code>选项，<code>ALPHA</code>可以和<code>ASC</code> <code>DESC</code>一起用。<br>  在对有序集合类型排序时会忽略元素的分数，只针对元素自身的值进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; lpush list1 1 2 3 4</span><br><span class="line">&gt; sort list1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;2&quot;</span><br><span class="line">3) &quot;3&quot;</span><br><span class="line">4) &quot;4&quot;</span><br><span class="line"></span><br><span class="line">&gt; lpush list2 a b c A B C</span><br><span class="line">&gt; sort list2 alpha</span><br><span class="line">1) &quot;a&quot;</span><br><span class="line">2) &quot;A&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;B&quot;</span><br><span class="line">5) &quot;c&quot;</span><br><span class="line">6) &quot;C&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>BY partten</code> 设置条件进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; sort list1 by a*</span><br></pre></td></tr></table></figure></li><li><p><code>LIMIT offset count</code> 表示跳过前offset个元素，并获取之后的countge元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; sort list2 alpha limit 2 3</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;B&quot;</span><br><span class="line">3) &quot;c&quot;</span><br></pre></td></tr></table></figure></li><li><p><code>GET pattern</code> </p></li></ul><h2 id="发布与订阅"><a href="#发布与订阅" class="headerlink" title="发布与订阅"></a>发布与订阅</h2><p>发布/订阅是一种消息通信模式，主要目的是解除消息发布者与消息订阅者的耦合。</p><p>订阅者可以通过<code>subscribe</code>和<code>psubscribe</code>命令向redis server订阅自己感兴趣的消息类型，redis将消息类型称为频道(channel)。<br>当发布者通过<code>publish</code>命令向redis server发送特定类型的消息时，该频道的全部订阅者都会收到此消息。这里消息的传递是多对多的。一个订阅者可以订阅多个频道,也可以向多个频道发送消息。<br><code>publish [channel] [message]</code>向指定频道发布信息<br><code>subscribe [channel]</code> 订阅频道<br>实验：开启两个终端<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 终端2</span><br><span class="line">&gt; SUBSCRIBE chan1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;chan1&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure></p><p>此时该终端处于订阅状态，该状态下客户端不可使用除<code>subscribe</code>、<code>unsubscribe</code>、<code>psubscribe</code>、<code>punsubscribe</code>以外的命令。<br>在订阅频道后客户端会收到三种类型的回复，每种回复都包含三个值。<br>第一个值为消息类型。有以下三种消息类型</p><ul><li><p><strong>subscribe</strong>：表示订阅成功的反馈信息。此时第二个值为订阅的频道名，第三个值为当前客户端订阅的频道数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 终端2</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;chan1&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure></li><li><p><strong>message</strong>：表示接收到的消息。此时第二个值为产生消息的频道，第三个值为消息的内容<br>另一个终端在该频道发布消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 终端1</span><br><span class="line">&gt; PUBLISH chan1 hello</span><br><span class="line"># 终端2</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;chan1&quot;</span><br><span class="line">3) &quot;hello&quot;</span><br></pre></td></tr></table></figure></li><li><p><strong>unsubscribe</strong>：表示成功取消订阅某个频道。此时第二个值为对应频道名，第三个值为当前频道数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 频道2</span><br><span class="line">&gt; UNSUBSCRIBE chan1</span><br><span class="line">1) &quot;unsubscribe&quot;</span><br><span class="line">2) &quot;chan1&quot;</span><br><span class="line">3) (integer) 0</span><br></pre></td></tr></table></figure></li></ul><p><code>unsubscribe</code>命令可退订频道，若不指定频道则退订所有频道</p><p><strong>按照规则订阅</strong><br>使用<code>psubscribe</code>订阅符合指定规则的频道。规则支持glob风格的通配符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 频道2</span><br><span class="line">&gt; PSUBSCRIBE chan*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;chan*&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line"># 频道1</span><br><span class="line">&gt; PUBLISH chan2 hello</span><br><span class="line">&gt; PUBLISH chan100 hello</span><br><span class="line"># 频道2</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;chan*&quot;</span><br><span class="line">3) &quot;chan2&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;chan*&quot;</span><br><span class="line">3) &quot;chan100&quot;</span><br><span class="line">4) &quot;hello&quot;</span><br></pre></td></tr></table></figure></p><p>频道2收到了任意以<code>chan</code>开头的频道的信息<br>第一个值：表示该信息的通过<code>psubscribe</code>命令订阅得到的<br>第二个值：订阅使用的通配符<br>第三个值：收到消息的具体频道名<br>第四个值：收到的消息内容</p><p><code>punsubscribe</code>命令可退订规则，若不指定频道则退订所有规则，且只会退订由规则加入的频道，并不会退订<code>subscribe</code>加入的频道。退订的规则必须严格匹配，与订阅时的一致。</p><p>发布订阅存在的问题：</p><ul><li>如果订阅者读取消息的速度很慢，会使得消息不断积压在发布者的输出缓存区中，造成内存占用过多；</li><li>如果订阅者在执行订阅的过程中网络出现问题，那么就会丢失断线期间发送的所有消息。</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务的原理是先将属于一个事务的命令发送给Redis，使Redis依次执行这些命令。</p><p>使用<code>multi</code>开启事务，之后的所有操作都属于该事务，直到提交<code>exec</code>，在事务中若有失误，可通过<code>discard</code>回滚，取消事务中所有操作。使用事务可保证一个事务内不会有其他的客户端的命令的插入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; set num1 11</span><br><span class="line">OK</span><br><span class="line">&gt; set num2 abc</span><br><span class="line">OK</span><br><span class="line">&gt; set num3 111</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; incr num1</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr num2</span><br><span class="line">QUEUED</span><br><span class="line">&gt; incr num3</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec</span><br><span class="line">1) (integer) 12</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) (integer) 112</span><br></pre></td></tr></table></figure></p><p>可见，事务中若有错误命令，仅会影响该命令，不会影响接下来的命令的执行。</p><p>事务的所有操作都是在事务提交时操作并一起返回值的，而有时需要先获得一条命令的返回值，再根据这个值执行下一条命令，即前一条命令的返回值需要作为后一条命令的参数。于是需要另一条命令<code>watch</code>，用于监视一个或多个键，一旦其中一个键被修改了，之后的事务都不会执行，监控一直持续到事务提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt; set key 1</span><br><span class="line">OK</span><br><span class="line">&gt; watch key</span><br><span class="line">OK</span><br><span class="line">&gt; set key 2     # 由于这里key被修改，于是之后的事务不会执行</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; incr key</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec</span><br><span class="line">(nil)</span><br><span class="line">&gt; get key</span><br><span class="line">&quot;2&quot;</span><br><span class="line"></span><br><span class="line"># 若在开启监视后，事务开启前，该键未被修改，则事务中对该键的操作仍有效</span><br><span class="line">&gt; set key 1</span><br><span class="line">OK</span><br><span class="line">&gt; watch key</span><br><span class="line">OK</span><br><span class="line">&gt; multi</span><br><span class="line">OK</span><br><span class="line">&gt; incr key</span><br><span class="line">QUEUED</span><br><span class="line">&gt; exec</span><br><span class="line">1) (integer) 2</span><br></pre></td></tr></table></figure></p><p>在执行<code>exec</code>后会取消对所有键的监视，若不想在执行事务中的命令也可使用<code>unwatch</code>命令取消监控。</p><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>在实际开发中会遇到有时效的数据，过了一定时间就应该清除，在Redis中可使用<code>expire</code>设置一个键的过期时间，到达该时间后Redis会自动删除该键。<br><code>expire &lt;key&gt; &lt;time&gt; （时间单位：秒，且必须是整数）</code><br>返回值为1表示设置成功，0表示未成功或键不存在。</p><p>若要设置更加精确的时间，可用命令<code>pexpire</code>，单位：毫秒。<br>可使用<code>ttl</code>命令查看指定键的剩余时间。若该键被删除了，则返回值为-2，若未设置该键的过期时间，，则返回-1。<br>可使用<code>persist &lt;key&gt;</code>命令取消设置指定键的过期时间，成功则返回1，否则（键不存在，或键原来就没有过期时间设置）返回0。</p><p><strong>注：</strong><code>set</code>或<code>getset</code>命令对键重新赋值也会清除过期时间。</p><p>若<code>watch</code>监视一个没有过期时间的键，该键到期自动删除后并不会被<code>watch</code>认为该键被修改。</p><p>命令<code>expireat &lt;key&gt; &lt;time&gt;</code> 用Unix时间作为过期时间（1970年1月1日到现在的秒数）<br>命令<code>pexpireat &lt;key&gt; &lt;time&gt;</code>同上，但单位为毫秒</p><p>当Redis用作缓存系统时，可以限制Redis能够使用的最大内存，并让Redis按照一定规则淘汰不需要的缓存键。<br>修改配置文件<code>maxmemory</code>参数，限制最大可用内存大小（单位：字节）。当超出限制后，Redis会根据<code>maxmemory-policy</code>参数指定的策略删除键直到Redis占用的内存小于指定内存。</p><p>以下为Redis提供的策略规则：</p><table><thead><tr><th>规则名</th><th>作用</th></tr></thead><tbody><tr><td>volatile-lru</td><td>使用LRU算法删除一个键（只对设置了过期时间的键起作用）</td></tr><tr><td>allkeys-lru</td><td>使用LRU算法删除一个键（会不断删除）</td></tr><tr><td>volatile-random</td><td>随机删除一个键（只对设置了过期时间的键起作用）</td></tr><tr><td>allkeys-random</td><td>随机删除一个键</td></tr><tr><td>volatile-ttl</td><td>删除过期时间最近的一个键</td></tr><tr><td>noeviction</td><td>不开启策略</td></tr></tbody></table><blockquote><p>LRU算法：Least Recently Used 最近最少使用。该算法认为最近最少使用的键在未来一段时间内也不会被用到，即当需要空间时这些键是可以被删除的。</p></blockquote><p><strong>注：</strong>实际上，Redis不会准确将整个数据库中最久未使用的键删除，而是每次从数据库中随机取5个键（可修改）并删除其中最久未被使用的键。随机取的键个数可通过配置文件的<code>maxmemory-samples</code>参数设置。默认为5个能产生最优的结果。10个最接近LRU算法的要求，但会消耗更多的CPU资源。3个会更快，但并不准确。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>redis为了内部数据安全考虑，会把数据以文件形式保存一份在硬盘中，服务器重启后会自动将数据还原到内存中，将数据保存到硬盘称为持久化。<br>持久化分为以下两种：</p><ul><li>快照持久化（snap shotting），也称RDB</li><li>AOF持久化（append only file）</li></ul><p><strong>RDB</strong><br>默认开启，一次性将所有数据保存在硬盘中，整个数据库只保存为一个文件，便于数据迁移，也便于数据库毁坏后的恢复。<br>在开始初始化时，唯一要做到的只是fork出子进程，再由子进程完成持久化工作，极大避免了服务进程执行IO操作，而父进程仍然处理客户端的请求，实现性能最大化。相较于AOF，若数据集很大，RDB的启动效率会很高。</p><p><strong>若要保证数据的高可用性，最大限度避免数据丢失，则不宜选择RDB。因为依靠子进程完成持久化，所以当数据集较大时，可能会导致整个服务器延时增大。</strong></p><p>写时复制策略保证了在fork的时刻虽然生成了两份内存副本，但内存的占用量并不会增加一倍，因此需要确保linux系统允许应用申请超过可用内存的空间。可通过<code>/etc/sysctl.conf</code>中修改<code>vm.overcommit_memory</code>参数为1。</p><p>当快照时，若写入操作交到，造成fork前后差异较大，是会使内存使用量显著超过实际数据大小的，因为内存不仅保存了当前数据库数据，还保存了快照时的内存数据。</p><p><strong>快照方式</strong></p><ul><li><strong>根据配置规则自动进行快照</strong><br>redis目录中的dump.rdb就是快照持久化的数据备份文件。<br>配置文件<code>/etc/redis.conf</code>的RDB参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 设置备份频率</span><br><span class="line">save 900 1     # 900秒中有一个键发生变化就触发RDB备份</span><br><span class="line">save 300 10    # 300秒中有10个键发生变化就触发RDB备份</span><br><span class="line">save 60 10000  # 60秒中有10000个键发生变化就触发RDB备份</span><br><span class="line"></span><br><span class="line">dbfilename dump.rdb  # 备份数据库文件名</span><br><span class="line">dir ./               # 备份数据库文件存放位置</span><br></pre></td></tr></table></figure></li></ul><p>在RDB中可实现精细持续化，将每个修改的键保存，频率可达到秒级。</p><p>只有当快照结束时，新的rdb文件才会覆盖旧的文件，而在备份过程中，redis是不会修改原rdb文件的，即任何时刻rdb文件都是完整的。于是可通过定时备份rdb文件实现redis数据库备份。<br>rdb文件是经过压缩的二进制格式，<br>可通过配置文件的<code>rdbcompression yes</code>参数禁用来压缩节省CPU占用。</p><p>Redis启动后会读取RDB文件，将数据从硬盘载入内存。通常一个记录1000万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20-30秒。</p><ul><li><p><strong>使用<code>save</code>或<code>bgsave</code>命令快照</strong><br><code>save</code>命令：Redis会同步进行快照，快照时会自动阻塞所有来自客户端的请求。若数据量大会导致Redis长时间无法访问，在生产环境中尽量不要用。<br><code>bgsave</code>命令：推荐使用，可在后台异步快照，快照时Redis仍能响应客户端请求。可通过<code>lastsave</code>命令查看快照是否完成，返回unix时间戳。</p></li><li><p><strong>执行<code>flushall</code>命令</strong><br>Redis会清空数据库中所有数据。无论清空数据库过程中是否触发了自动快照条件，只要自动快照条件不为空，redis就会执行一次快照。若未指定自动快照条件，则<code>flushall</code>并不会执行快照。</p></li><li><p><strong>执行复制（replication）时</strong><br>当设置了主从模式时，Redis会在复制初始化时自动执行快照，并生成RDB文件，并不需要定义快照条件或手动执行。</p></li></ul><p><strong>AOF</strong><br>将用户执行的写指令都备份到日志文件中，还原数据就是执行写指令。AOF可带来更高的数据安全性，即持久性。<br><strong>注：开启AOF持久化会清空redis数据库所有数据，所以若要选择AOF持久化，应该在安装完redis服务器后就要立刻开启。</strong></p><p>Redis有三种同步策略：每秒同步，每修改同步，不同步。</p><ul><li>每秒同步为异步持久化，效率高。若服务器突然宕机，则在这一秒中的数据会丢失。</li><li>每修改同步为同步持久化，每次数据发生变化就会立刻记录到磁盘中，效率低。</li></ul><p>该机制对日志文件的写入操作采用append模式，即使在写入过程中出现宕机，也不会破坏日志中已写入的数据，在Redis重启后可通过命令<code>redis-check-aof</code>解决数据一致性问题。<br>当日志过大时，Redis会自动启用重写rewrite机制，以append模式不断将修改数据写入老磁盘文件，并会创建一个新文件用于记录期间哪些修改命令被执行，保证了数据持久性。</p><p>对于相同数量的数据集，AOF文件通常比RDB文件大。AOF的运行效率通常慢于RDB，但其中每秒同步的效率较高。</p><p>配置文件<code>/etc/redis.conf</code>的AOF参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 若要开启AOF，将此项改为yes</span><br><span class="line">appendonly no </span><br><span class="line"></span><br><span class="line"># 还可设置AOF的备份文件位置</span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line"></span><br><span class="line"># 设置同步机制，三种机制always，everysec，no。</span><br><span class="line"># always：每修改同步</span><br><span class="line"># everysec：每秒同步，默认</span><br><span class="line"># no：同步禁用</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure></p><p>AOF是将Redis客户端向Redis发送的所有命令全部记录下来，这就造成了有很多冗余无用的命令，如<code>SELECT</code>等也会记录，随着执行命令的增多，AOF文件的大小也会逐渐增大。<br>因此，Redis提供了优化策略，可在配置文件中修改以下两个参数：<br><code>auto-aof-rewrite-percentage 100</code>：设置当目前AOF文件的大小超过上一次AOF文件大小的指定百分比时就会再次进行重写，若之前未重写过，则会根据启动时的AOF文件大小作依据。<br><code>auto-aof-rewrite-min-size 64mb</code>：限制允许重写的最小AOF文件大小。</p><p>若不满足重写条件，可通过命令<code>bgrewriteaof</code>手动重写。</p><h2 id="Redis优化技术"><a href="#Redis优化技术" class="headerlink" title="Redis优化技术"></a>Redis优化技术</h2><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>客户端使用TCP与服务器建立连接，若执行较多的命令，每个命令的往返时延累加起来对性能有一定的影响。在执行多个命令时每条命令都需要等待上一条命令执行完（即收到Redis的返回结果）才能执行。<br>Redis支持管道（pipelining），可一次性发送多条命令并在执行后一次性返回结果。通过减少客户端与服务器的通信次数来实现降低往返时累计值。<br><strong>注：</strong>每一组中的命令都不能依赖之前命令的执行结果。</p><h3 id="内部编码优化"><a href="#内部编码优化" class="headerlink" title="内部编码优化"></a>内部编码优化</h3><p>Redis为每种数据类型都提供了两种内部编码的方式，并且会自动根据实际情况进行编码的转变，对于开发者而言是透明的。其中一种为复杂度是O(1)的编码，而当键的元素个数大时，变会采用复杂度为O(n)的编码。<br>可通过<code>object encoding &lt;key&gt;</code>查看指定键的编码方式。</p><p>Redis的每个键值都是使用一个redisObject的结构体保存的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> notused:<span class="number">2</span>;  <span class="meta"># not used</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;     <span class="meta"># lru时间</span></span><br><span class="line">    <span class="keyword">int</span> refcount;        # 存储某个键值被引用的数量</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure></p><p>每个数据类型的编码</p><table><thead><tr><th>数据类型</th><th>内部编码方式</th><th>object encoding命令结果</th></tr></thead><tbody><tr><td>字符串</td><td>REDIS_ENCODING_RAW</td><td>“raw”</td></tr><tr><td></td><td>REDIS_ENCODING_INT</td><td>“int”</td></tr><tr><td></td><td>REDIS_ENCODING_EMBSTR</td><td>“embstr”</td></tr><tr><td>散列</td><td>REDIS_ENCODING_HT</td><td>“hashtable”</td></tr><tr><td></td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr><tr><td>列表</td><td>REDIS_ENCODING_LINKEDLIST</td><td>“linkedlist”</td></tr><tr><td></td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr><tr><td>集合</td><td>REDIS_ENCODING_HT</td><td>“hashtable”</td></tr><tr><td></td><td>REDIS_ENCODING_INTSET</td><td>“intset”</td></tr><tr><td>有序集合</td><td>REDIS_ENCODING_SKIPLIST</td><td>“skiplist”</td></tr><tr><td></td><td>REDIS_ENCODING_ZIPLIST</td><td>“ziplist”</td></tr></tbody></table><blockquote><p>EMBSTR字符串编码方式与RAW类似，都是基于sdshdr实现。</p></blockquote><ul><li>字符串类型<br>Redis使用<code>sdshdr</code>类型变量存储<br>一个键值能被多个键引用，Redis会预先建立10000个分别存储从0到9999的redisObject型的变量对象，若设置的键值在10000以内，则该键就会直接引用这个共享对象，并不会再建立一个redisObject对象了。</li></ul><blockquote><p>当配置文件设定了<code>macmemory</code>Redis可用最大空间后，就不会使用共享对象，因为对于每个键值都需要使用一个redisObject记录LRU信息</p></blockquote><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>Redis集群主要用于防止单点故障，以及解决存储、性能瓶颈问题。</p><h3 id="复制（主从）"><a href="#复制（主从）" class="headerlink" title="复制（主从）"></a>复制（主从）</h3><p>Redis提供的复制功能，可实现当一台数据库中的数据更新后，自动将更新的数据同步到其他数据库上。因此，将数据库分为主数据库（master）与从数据库（slave）。<br>主数据库可进行读写操作，当数据更新时将更新的数据同步到从数据库。而从数据库一般为只读操作，接收主数据库的同步数据。一个从数据库只能有一个主数据库。从数据库默认只读，若创建键会报错。</p><p>在一台主机上模拟主从数据库<br>首先启动主数据库<code>redis-server /etc/redis.conf</code><br>然后可直接通过命令<code>redis-server --port 6666 --slaveof 127.0.0.1 6379</code>再打开一个数据库，并作为从数据库<br>连接到从数据库<code>redis-cli -p 6666</code>并执行<code>INFO replication</code>，查看从数据库的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>在主数据库上创建键，在从数据库上就能得到该键了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key1 123</span><br><span class="line">127.0.0.1:6666&gt; get key1</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure></p><p>也可通过修改数据库的配置文件将该数据库设为从数据库<br>在redis<strong>从服务器</strong>上修改配置文件参数<br><code>bind &lt;主服务器IP&gt;</code><br><code>slaveof &lt;主服务器IP&gt; &lt;主服务器端口&gt;</code><br>主数据库上不需要任何配置。</p><p>还可在一个已开启的数据库中输入命令<code>slaveof &lt;ip-addr&gt; &lt;port&gt;</code>将本数据库设为指定主数据库的从数据库。若该数据库已是其他数据库的从数据库了，则这条命令会取消与原主数据库的同步，而与新指定的主数据库同步。还可通过命令<code>slaveof no one</code>使当前数据库停止接收主数据库同步，并转变为主数据库。</p><p>主从同步流程：</p><ol><li>当一个从数据库启动后，会向主数据库发送SYNC命令。</li><li>主数据库收到SYNC后，会在后台保存RDB快照，并将快照与缓存的命令都发送给从数据库。</li><li>从数据库收到后载入快照，并将执行缓存命令。<br><strong>1到3步称为复制初始化</strong></li><li>复制初始化完成后，主数据库每当收到写命令后就会将命令同步到从数据库。</li></ol><p>当主从数据库断开连接并重连后，Redis提供有条件的增量数据传输，主数据库只需将断线期间执行的命令传送给从数据库即可。</p><p>试验同步：<br>先使用telnet伪装成一个从数据库与主数据库通信<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># telnet 127.0.0.1 6379</span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br></pre></td></tr></table></figure></p><p>然后在从数据库中使用<code>ping</code>确认与主数据库的连接，若正常则主数据库会返回<code>PONG</code>。<br>再输入<code>REPLCONF listening-port 6666</code>说明自己端口号。<br>开始同步<code>SYNC</code>，此时telnet的界面会出现以下信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* Slave 127.0.0.1:6666 asks for synchronization</span><br><span class="line">* Starting BGSAVE for SYNC with target: disk</span><br><span class="line">* Background saving started by pid 4079</span><br><span class="line">* DB saved on disk</span><br><span class="line">* RDB: 6 MB of memory used by copy-on-write</span><br><span class="line">* Background saving terminated with success</span><br><span class="line">* Synchronization with slave 127.0.0.1:6666 succeeded</span><br></pre></td></tr></table></figure></p><p>默认从数据库会使用同步前的数据响应客户端请求，可以在从数据库上修改配置文件参数<code>slave-serve-stale-data</code>为no，使从数据库再同步完成前对所有命令都返回错误（除<code>INFO</code>和<code>SLAVEOF</code>）。<br>复制同步阶段会贯穿整个主从同步始终，直到主从关系终止。</p><p><strong>乐观复制：</strong>允许一定时间内主从数据库的内容不一致，但最终是会同步的。主从数据库的数据同步是异步的，会产生主从数据库数据不一致的时间窗口（即网络传输的时间加上命令执行的时间），因此，主数据库是不知道命令最终同步给多少个数据库的。Redis提供配置文件参数限制至少同步给的从数据库的数量时，主数据库才是可写的。<br><code>min-slaves-to-write 3</code> 表示有3个以上的从数据库连接到主数据库时，主数据库才是可写的。<br><code>min-slaves-max-lag 10</code> 表示允许从数据库失去与主数据库连接的最长时间。若从数据库最后一次与主数据库的联系（即发送<code>replconf ack</code>命令）的时间小于该值，则认为从数据库仍与主数据库连接，否则就断开主从连接。这一特性默认关闭。</p><p><strong>图结构：从数据库不仅能从主数据库接收同步数据，还能再以自身作为主数据库，将数据再同步给下属的从数据库。</strong></p><p>通过复制可实现读写分离，提高负载能力。往往读的频率大于写的频率，当单机的Redis无法应对大量读请求时，可通过复制建立多个从数据库节点，主数据库只进行写操作，从数据库负责读操作。</p><p><strong>从数据库的持久化</strong><br>可通过复制建立一个或多个从数据库，并在从数据库启动持久化，在主数据库禁用持久化。<br>当<strong>从数据库</strong>崩溃重启后主数据库会自动同步数据。<br>当<strong>主数据库</strong>崩溃后则需要按照以下步骤进行恢复。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 在从数据库中使用命令slaveof no one将从数据库提升为主数据库继续对外提供服务</span><br><span class="line">2. 启动崩溃的主数据库，再使用slaveof将其设置为新的主数据库的从数据库，再将数据进行同步。</span><br></pre></td></tr></table></figure></p><blockquote><p>当开启复制且主数据库关闭持久化功能时，不要使用supervisor等进程管理工具使主数据库崩溃后自动重启。同样当主数据库所在服务器因故关闭时，也要避免直接重启。<br>因为主数据库重启后没有开启持久化功能，所以主数据库中所有数据都会被清空，而从数据库又会与从主数据库中同步数据，导致从数据库所有数据也被清空。</p></blockquote><h3 id="无硬盘复制"><a href="#无硬盘复制" class="headerlink" title="无硬盘复制"></a>无硬盘复制</h3><p>Redis的复制是基于RDB方式持久化实现的，即主数据库端在后台保存RDB快照，从数据库接收并载入快照文件。<br>缺点：</p><ol><li>当主数据库禁用RDB快照后，如果执行复制初始化，Redis依然会生成RDB快照，所以下次启动后主数据库会以该快照恢复数据。<strong>因为复制发生的时间不能确定，这使得恢复的数据可能是任何时间点的。</strong></li><li>因为复制初始化时需要在硬盘中创建RDB快照文件，所以如果硬盘性能很慢（如网络硬盘）时这一过程会对性能产生影响。<br>举例来说，当使用Redis做缓存系统时，因为不需要持久化，所以服务器的硬盘读写速度可能较差。但是当该缓存系统使用一主多从的集群架构时，每次和从数据库同步，Redis都会执行一次快照，同时对硬盘进行读写，导致性能降低。</li></ol><p>因此Redis引入了无硬盘复制选项，开启该选项时，Redis在<strong>与从数据库进行复制初始化时将不会将快照内容存储到硬盘上，而是直接通过网络发送给从数据库</strong>，避免了硬盘的性能瓶颈。</p><p>可修改配置文件中<code>repl-diskless-sync</code>参数为yes开启。</p><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><p>场景：当主从数据库连接断开后，从数据库会发送SYNC命令来重新进行一次完整复制操作。虽然断开期间数据库的变化很小，但也需要将数据库中的所有数据重新快照并传送一次。因此Redis实现了主从断线重连的情况下的增量复制。</p><p>增量复制是基于如下3点实现的。</p><ol><li>从数据库会存储<strong>主数据库的运行ID（run id）</strong>。每个Redis运行实例均会拥有一个唯一的运行ID，每当实例重启后，就会自动生成一个新的运行ID。</li><li>在复制同步阶段，<strong>主数据库每将一个命令传送给从数据库时，都会同时把该命令存放到一个积压队列（backlog）中</strong>，并记录下当前积压队列中存放的命令的偏移量范围。</li><li>同时，从数据库接收到主数据库传来的命令时，会记录下该命令的偏移量。</li></ol><p>当主从连接准备就绪后，从数据库会发送一条PSYNC命令来告诉主数据库可以开始把所有数据同步过夹了，格式为<code>PSYNC 主数据库的运行ID断开前最新的命令偏移量</code>。主数据库收到PSYNC命令后，会执行以下判断来决定此次重连是否可以执行增量复制。</p><ol><li>首先主数据库会判断从数据库传送来的运行ID是否和自己的运行ID相同，确保从数据库之前确实是和自己同步的。</li><li>然后判断从数据库最后同步成功的备今信移景是否在积压队列中，如果在则可以执行增量复制，并将积压队列中相应的命令发送给从数据库。<br>如果此次重连不满足增量复制的条件，主数据库会进行一次全部同步。</li></ol><p>增量复制的过程对开发者来说是完全透明的，唯一需要开发者设置的就是积压队列的大小了。主数据库可以正常地和旧版本的从数据库同步（通过接收SYNC命令），从数据库也可以与旧版本的主数据库同步（通过发送SYNC命令）。<br>积压队列在本质上是一个固定长度的循环队列，默认情况下积压队列的大小为1MB，可以通过配置文件的<code>rep1-backlog-size</code>选项来调整。积压队列越大，其允许的主从数据库断线的时间就越长。<br>根据主从数据库之间的网络状态，设置一个合理的积压队列很重要。因为积压队列存储的内容是命令本身，所以估算积压队列的大小只需估计主数据库可能执行的命令的大小即可。另一个配置参数是<code>rep1-backlog-ttl</code>，当所有从数据库与主数据库断开连接后，经过多久时间可以释放积压队列的内存空间，默认为1小时。</p><h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><p>Redis提供哨兵实现自动化的系统监控和故障恢复功能，哨兵是一个独立的进程。<br>哨兵有以下功能：</p><ol><li>监控主数据库和从数据库是否正常运行。</li><li>主数据库出现故障时自动将从数据库转换为主数据库。</li></ol><p>在一个主从Redis系统中，可使用多个哨兵进行监控任务以保证系统足够稳健。哨兵不仅能监控主从数据库，还能与其他哨兵互相监控。<br><img src="/2018/05/17/Redis学习笔记/shaobing.png"></p><p>哨兵实验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">实验环境：system2 192.168.163.102</span><br><span class="line">主服务器：127.0.0.1 6379</span><br><span class="line">redis-server /etc/redis.conf </span><br><span class="line"></span><br><span class="line">从服务器：127.0.0.1 6380 6381</span><br><span class="line">redis-server --port 6380 --slaveof 127.0.0.1 6379</span><br><span class="line">redis-server --port 6381 --slaveof 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6380,state=online,offset=266,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6381,state=online,offset=266,lag=0</span><br><span class="line"></span><br><span class="line">设置哨兵</span><br><span class="line">创建配置文件/etc/sentinel.conf，并添加以下内容：</span><br><span class="line">sentinel monitor MyMaster_1 127.0.0.1 6379 1</span><br><span class="line">sentinel monitor master-name ip port quoram</span><br><span class="line"># MyMaster_1为要监视的主数据库的名字，可自定义</span><br><span class="line"># 后面跟上主数据库的IP地址和端口号</span><br><span class="line"># 最后一个数字quoram表示最低通过票数</span><br><span class="line"></span><br><span class="line"># 配置哨兵时，只需要配置监视的主数据库即可，哨兵会自动发现主数据库下的所有从数据库。</span><br><span class="line"></span><br><span class="line">然后启动Sentinel进程</span><br><span class="line">redis-sentinel /etc/sentinel.conf</span><br><span class="line">启动哨兵后会报如下信息</span><br><span class="line">Sentinel ID is 33766bbd6ec93b3574240b6a4ac5c8ea498207d4</span><br><span class="line">+monitor master MyMaster_1 127.0.0.1 6379 quorum 1</span><br><span class="line">* +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ MyMaster_1 127.0.0.1 6379</span><br><span class="line">* +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ MyMaster_1 127.0.0.1 6379</span><br><span class="line"></span><br><span class="line"># +slave表示发现了从数据库</span><br><span class="line">然后在另一个终端中关闭主数据库</span><br><span class="line">在原终端中会出现一连串的以下信息</span><br><span class="line">* Connecting to MASTER 127.0.0.1:6379</span><br><span class="line">* MASTER &lt;-&gt; SLAVE sync started</span><br><span class="line">Error condition on socket for SYNC: Connection refused</span><br><span class="line"></span><br><span class="line">在过了一段时间（默认30s，可配置修改）后，会出现以下信息</span><br><span class="line">+sdown master MyMaster_1 127.0.0.1 6379</span><br><span class="line">+odown master MyMaster_1 127.0.0.1 6379 #quorum 1/1</span><br><span class="line"></span><br><span class="line"># +sdown 表示哨兵主观认为主数据库停止服务了</span><br><span class="line"># +odown 表示哨兵客观认为主数据库停止服务了</span><br><span class="line"># 此时哨兵执行故障恢复，挑选一个从数据库提升为主数据库</span><br><span class="line">然后会报出许多信息，下面列举出几条重要的信息</span><br><span class="line">+try-failover master MyMaster_1 127.0.0.1 6379</span><br><span class="line">+vote-for-leader 33766bbd6ec93b3574240b6a4ac5c8ea498207d4 1</span><br><span class="line">......</span><br><span class="line">+failover-end master MyMaster_1 127.0.0.1 6379</span><br><span class="line">+switch-master MyMaster_1 127.0.0.1 6379 127.0.0.1 6380</span><br><span class="line">+slave slave 127.0.0.1:6381 127.0.0.1 6381 @ MyMaster_1 127.0.0.1 6380</span><br><span class="line">+slave slave 127.0.0.1:6379 127.0.0.1 6379 @ MyMaster_1 127.0.0.1 6380</span><br><span class="line"></span><br><span class="line"># +try-failover 表示哨兵开始故障恢复</span><br><span class="line"># +failover-end 表示哨兵完成故障恢复，故障恢复步骤包括领头哨兵选举、备份从数据库的选择等</span><br><span class="line"># +switch-master 表示主数据库从6379端口迁移到6380，即6380端口的从数据库提升为主数据库</span><br><span class="line"># 两个+slave，原主数据库变为了现主数据库的从数据库，但此时6379的数据库并未启动，说明哨兵并不会清除已停止服务的实例的信息</span><br><span class="line"></span><br><span class="line">再次登录上127.0.0.1:6380</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=99027,lag=1</span><br><span class="line"># 因为6379端口数据库未启动，所以此时只有一个从数据库</span><br><span class="line">然后重启6379端口数据库</span><br><span class="line">-sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ MyMaster_1 127.0.0.1 6380</span><br><span class="line">+convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ MyMaster_1 127.0.0.1 6380</span><br><span class="line"></span><br><span class="line"># -sdown 表示实例6379已恢复服务（与+sdown相反）</span><br><span class="line"># +convert-to-slave 表示将6379端口实例设置为6380端口实例的从数据库。</span><br><span class="line">在6379端会报以下信息：</span><br><span class="line">SLAVE OF 127.0.0.1:6380 enabled</span><br><span class="line">再在6380端查看</span><br><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=541686,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=6379,state=online,offset=541686,lag=0</span><br></pre></td></tr></table></figure></p><p>一个哨兵节点可同时监控多个Redis主从系统，只要提供多个sentinel monitor配置即可。多个哨兵节点也可监控一个主从系统。</p><p>sentinel.conf配置文件的其他配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># sentinel down-after-milliseconds 主数据库名 值</span><br><span class="line"># 这条参数用于设置哨兵发送ping命令检测数据库节点状态的周期时间，单位为毫秒</span><br></pre></td></tr></table></figure></p><p>当超过该参数时间而未收到回复后，则哨兵认为该节点主观下线。若该节点为主数据库，则哨兵会进一步判断是否需要故障恢复。哨兵会向其他节点发送<code>sentinel is-master-down-by-addr</code>命令询问其他节点是否他们也认为主数据库主观下线，当赞同的节点达到指定数目后，哨兵会认为主数据库客观下线，并进行故障恢复。这个指定数目就是<code>sentinel.conf</code>中<code>sentinel monitor</code>最后一项数值quoram。</p><p>哨兵启动后，会与要监控的主数据库建立两条连接。一条连接用来订阅该主数据的<code>_sentinel_:he11o</code>频道以获取其他同样监控该数据库的哨兵节点的信息，另外哨兵也需要定期向主数据库发送INFO等命令来获取主数据库本身的信息。</p><p>哨兵创建后与立刻做的事情：<br>发送INFO命令获得<strong>当前数据库</strong>的相关信息（包括运行ID、复制信息等）从而实现新节点的自动发现。哨兵向主数据库发送INFO命令，通过解析返回结果来得知从数据库列表，而后对每个从数据库同样建立两个连接。至此，与主数据库的连接建立成功。</p><p>和主数据库的连接建立完成后，哨兵会定时执行下面3个操作。</p><ol><li>每10秒哨兵会向主数据库和从数据库发送INFO命令。</li><li>每2秒哨兵会向主数据库和从数据库的<code>_sentinel_:hel1o</code>频道发送自己的信息。<br>发送的消息内容为：<code>&lt;哨兵IP&gt;，&lt;哨兵port&gt;，&lt;哨兵运行ID&gt;，&lt;哨兵配置版本&gt;，&lt;主数据库名&gt;，&lt;主数据库IP&gt;，&lt;主数据库port&gt;，&lt;主数据库配置版本&gt;</code></li><li>每1秒哨兵会向主数据库、从数据库和其他哨兵节点发送PING命令。</li></ol><p>选举领头哨兵的过程使用了Raft算法，过程如下：</p><ol><li>发现主数据库客观下线的哨兵节点向每个哨兵节点发送命令，要求对方选自己为领头哨兵。</li><li>如果目标哨兵节点没有选过其他人，则会同意将该节点设为领头哨兵。</li><li>如果该节点发现有超过半数且超过该数值的哨兵节点同意选自己为领头哨兵，则此节点会成功成为领头哨兵。</li><li>当有多个哨兵节点同时参选领头哨兵，会出现没有一个节点当选的情况。此时参选节点会等待一个随机时间重新发起参选请求，进行下一轮直到选举成功。</li></ol><p>故障恢复过程：</p><ol><li>领头哨兵会从从数据库中挑选一个作为新的主数据库。<br> 挑选的依据分为三点：<ul><li>所有在线的从数据库中选择优先级最高的，优先级可通过配置文件<code>slave-priority</code>参数设置</li><li>若有多个最高优先级的从数据库，则复制的命令偏移量大的优先</li><li>若上述都相同，则运行ID小的优先</li></ul></li><li>选出符合的从数据库后，会向该数据库发送<code>slaveof no one</code>使其提升为主数据库，然后再向其他数据库发送<code>slaveof</code>使其成为新的主数据库的从数据库。最后再更新数据记录，原的主数据库变为从数据库。</li></ol><p>哨兵的部署方案：</p><ul><li>每个节点部署一个哨兵</li><li>每个哨兵与其对应节点网络环境相同或相近</li></ul><p>这样可以保证哨兵的视角具有代表性和可靠性。最好将quoram的值设为N/2+1（N为哨兵节点个数）。若每个节点都部署一个哨兵的话，可能会因为Redis不支持连接复用而造成产生大量冗余连接。</p><h3 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h3><p>集群往往用于水平扩容。<br>若要开启集群，只要将配置文件的<code>cluster-enabled</code>参数设为yes即可，默认开启。每个集群至少需要三个主数据库。</p><p>集群实验<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实验环境</span><br><span class="line">6个数据库，3个主数据库，3个从数据库</span><br><span class="line">三个主数据库端口分别为6000，6001，6002</span><br><span class="line">三个从数据库端口分别为6003，6004，6005</span><br></pre></td></tr></table></figure></p><p>集群会将当前节点记录的集群状态持久化到指定文件，默认为当前目录下的<code>nodes.conf</code>，这里还是存放在/etc/nodes.conf，每个节点对应的文件必须不同，否则会启动失败，因此启动节点时要注意最后为每个节点使用不同的工作目录，或通过配置文件<code>cluster-config-file 节点文件路径</code>修改。<br>最好给每个节点都创建一个目录，然后每个节点都复制一份配置文件，并修改<code>port</code>参数，<code>cluster-config-file</code>参数。然后通过<code>redis-server 配置文件</code>启动。使用<code>ps</code>查看，每个节点都是显示类似<code>redis-server *:6000 [cluster]</code>。<br>然后进入节点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6000&gt; info cluster</span><br><span class="line"># Cluster</span><br><span class="line">cluster_enabled:1    # 1说明集群启动正常</span><br></pre></td></tr></table></figure></p><p>目前仅仅节点运行正常，但并未加入集群。需要使用redis的ruby插件。<br>首先需要安装ruby，最好不要yum安装，应该下最新版本的源码包编译安装。安装完后可以在<code>/usr/local/redis/src/</code>目录下找到<code>redis-trib.rb</code>命令，创软链接。<br>然后使用该命令初始化集群<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis-trib.rb create --replicas 1 \</span><br><span class="line">    127.0.0.1:6000 \</span><br><span class="line">    127.0.0.1:6001 \</span><br><span class="line">    127.0.0.1:6002 \</span><br><span class="line">    127.0.0.1:6003 \</span><br><span class="line">    127.0.0.1:6004 \</span><br><span class="line">    127.0.0.1:6005</span><br><span class="line"># --replicas 1 表示每个主数据库拥有的从数据库个数为1</span><br><span class="line"></span><br><span class="line">会出现以下信息：</span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:6000</span><br><span class="line">127.0.0.1:6001</span><br><span class="line">127.0.0.1:6002</span><br><span class="line">Adding replica 127.0.0.1:6004 to 127.0.0.1:6000</span><br><span class="line">Adding replica 127.0.0.1:6005 to 127.0.0.1:6001</span><br><span class="line">Adding replica 127.0.0.1:6003 to 127.0.0.1:6002</span><br><span class="line">......</span><br><span class="line">Can I set the above configuration? (type &apos;yes&apos; to accept):</span><br><span class="line">确认输入yes创建集群</span><br></pre></td></tr></table></figure></p><p>通过<code>redis-trib.rb</code>创建集群的过程：</p><ol><li>首先该命令会以客户端形式尝试连接所有节点，并发送ping确定节点正常，同时发送<code>info</code>获取节点运行ID、验证是否开启了集群</li><li>集群会向每个节点发送<code>cluster meet IP地址 端口</code>告诉当前节点指定的节点也是集群成员。</li><li><code>redis-trib.rb</code>会分配主从数据库节点，分配原则为尽量保证每个主数据库运行在不同IP地址上，同时每个从数据库和主数据库都不运行在同一IP地址。</li><li>分配完成后，会为主数据库分配插槽，即分配哪些键归哪些节点复制。对每个要成为子数据库的节点发送<code>cluster replicate 主数据库运行ID</code>将当前节点转换为从数据库并复制指定主数据库。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6000&gt; CLUSTER nodes</span><br><span class="line">5c15caa067f96e557d73704e961ee08504fe3ac1 127.0.0.1:6004@16004 slave b098c2ddc169cc6e5411e8c42fb5afa96fa91764 0 1531150828178 5 connected</span><br><span class="line">6808731e0d12e8ec740509ef060c81306d5cd9bd 127.0.0.1:6000@16000 myself,master - 0 1531150825000 1 connected 0-5460</span><br><span class="line">8e885e28b530491468b76bb8084cf7c22a8166f4 127.0.0.1:6005@16005 slave 9de0340daaf29f81b32c96d8010e9e443d66be0b 0 1531150827000 6 connected</span><br><span class="line">b098c2ddc169cc6e5411e8c42fb5afa96fa91764 127.0.0.1:6001@16001 master - 0 1531150825153 2 connected 5461-10922</span><br><span class="line">e219bc21f1ab59f4cf00ca1b35da84e955424556 127.0.0.1:6003@16003 slave 6808731e0d12e8ec740509ef060c81306d5cd9bd 0 1531150827000 4 connected</span><br><span class="line">9de0340daaf29f81b32c96d8010e9e443d66be0b 127.0.0.1:6002@16002 master - 0 1531150827169 3 connected 10923-16383</span><br></pre></td></tr></table></figure><p>可通过<code>cluster meet IP地址 端口</code>向新节点发送使新节点加入集群<br>当新节点收到该命令后，会根据命令中的IP地址和端口与目标建立握手连接，然后目标会认为此节点为集群中的一员，并使用Gossip协议（一种分布式系统通信协议）向集群中所有节点发送此节点的信息。</p><p>新节点加入集群后可进行以下操作：</p><ul><li>使用<code>cluster replicate</code>复制每个主数据库，以从数据库运行</li><li>向集群申请分配插槽（slot）以主数据库运行</li></ul><p>在一个集群中，所有键会被分配给16384个插槽，每个主数据库会负责处理其中一部分插槽。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">确认创建集群后的报出的信息</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6000)</span><br><span class="line">M: 6808731e...... 127.0.0.1:6000</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 5c15caa0...... 127.0.0.1:6004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b098c2d......</span><br><span class="line">S: 8e885e28...... 127.0.0.1:6005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 9de0340......</span><br><span class="line">M: b098c2dd...... 127.0.0.1:6001</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">......</span><br><span class="line">由此也可看出，只有主数据库才会分配插槽，从数据库无插槽。</span><br></pre></td></tr></table></figure></p><p>初始化集群时分配给每个节点的插槽是连续的，但实际上Redis没有限制，可将任意几个插槽分配给任意节点。</p><p>键与插槽的关系<br>键名的有效部分通过算法计算出散列值并取16384的余数。使得每个键都可以分配到16384个插槽中，进而分配的指定的一个节点中处理。</p><blockquote><p>有效部分：若键名包含大括号，则有效部分为大括号内的内容，若不包含大括号，则整个键名都是有效部分</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">可使用命令cluster slots查看插槽分配情况</span><br><span class="line">127.0.0.1:6000&gt; CLUSTER SLOTS</span><br><span class="line">1) 1) (integer) 0</span><br><span class="line">   2) (integer) 5460</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6000</span><br><span class="line">      3) &quot;6808731e0d12e8ec740509ef060c81306d5cd9bd&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6003</span><br><span class="line">      3) &quot;e219bc21f1ab59f4cf00ca1b35da84e955424556&quot;</span><br><span class="line">2) 1) (integer) 5461</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6001</span><br><span class="line">      3) &quot;b098c2ddc169cc6e5411e8c42fb5afa96fa91764&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6004</span><br><span class="line">      3) &quot;5c15caa067f96e557d73704e961ee08504fe3ac1&quot;</span><br><span class="line">3) 1) (integer) 10923</span><br><span class="line">   2) (integer) 16383</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6002</span><br><span class="line">      3) &quot;9de0340daaf29f81b32c96d8010e9e443d66be0b&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6005</span><br><span class="line">      3) &quot;8e885e28b530491468b76bb8084cf7c22a8166f4&quot;</span><br><span class="line"></span><br><span class="line">因为有3个master，所以有三条记录，每条记录中包含四个值：</span><br><span class="line">1) 插槽的开始号</span><br><span class="line">2) 插槽的结束号</span><br><span class="line">3) 所有负责该插槽的节点（第一个是主数据库，后面都是从数据库）。包含以下内容：</span><br><span class="line">   1) 节点的IP地址</span><br><span class="line">   2) 节点端口号</span><br><span class="line">   3) 节点运行ID</span><br></pre></td></tr></table></figure><p>插槽的分配的情况</p><ol><li>插槽之前没被分配过，现在想分配给指定节点</li><li>插槽之前被分配过，现在想移动到指定节点</li></ol><p>将插槽分配给节点的过程</p><ol><li>若是上述的第一种情况，即插槽未被分配过。使用<code>cluster addslots [插槽号]....</code>可分配多个插槽。<br> 若被分配过则会报错<code>(error) ERR Slot 100 is already busy</code></li><li>若是第二种情况，即插槽被分配过。redis-trib.rb提供简便迁移方法<br> <code>redis-trib.rb reshard 目标IP地址:端口</code><br> 其中<code>reshard</code>表示需要重新分片。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">目标：将6000端口的插槽分1000个到6001端口</span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6000</span><br><span class="line"></span><br><span class="line"># 然后会询问要迁移的插槽个数</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 1000</span><br><span class="line"></span><br><span class="line"># 询问要迁移到的节点ID（redis-trib.rb会给出，也可以进入数据库cluster nodes查看）</span><br><span class="line">What is the receiving node ID? b098c2ddc169cc6e5411e8c42fb5afa96fa91764</span><br><span class="line"></span><br><span class="line"># 询问从哪个节点开始移出插槽，输入6000端口节点的ID</span><br><span class="line"># 在结束输入后回车，并输入done</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type &apos;all&apos; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &apos;done&apos; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1:6808731e0d12e8ec740509ef060c81306d5cd9bd</span><br><span class="line">Source node #2:done</span><br><span class="line"># 然后会要求再次确认，输入yes</span><br><span class="line">Do you want to proceed with the proposed reshard plan (yes/no)? yes</span><br><span class="line"># 再进redis查看cluster slots</span><br><span class="line">127.0.0.1:6000&gt; CLUSTER SLOTS</span><br><span class="line">1) 1) (integer) 1000</span><br><span class="line">   2) (integer) 5460</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6000</span><br><span class="line">      3) &quot;6808731e0d12e8ec740509ef060c81306d5cd9bd&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6003</span><br><span class="line">      3) &quot;e219bc21f1ab59f4cf00ca1b35da84e955424556&quot;</span><br><span class="line">2) 1) (integer) 0</span><br><span class="line">   2) (integer) 999</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6001</span><br><span class="line">      3) &quot;b098c2ddc169cc6e5411e8c42fb5afa96fa91764&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6004</span><br><span class="line">      3) &quot;5c15caa067f96e557d73704e961ee08504fe3ac1&quot;</span><br><span class="line">3) 1) (integer) 5461</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6001</span><br><span class="line">      3) &quot;b098c2ddc169cc6e5411e8c42fb5afa96fa91764&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 6004</span><br><span class="line">      3) &quot;5c15caa067f96e557d73704e961ee08504fe3ac1&quot;</span><br></pre></td></tr></table></figure></li></ol><p>若不使用<code>redis-trib.rb</code>命令。也可通过<code>cluster setslot</code>命令分片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot 插槽号 node 新节点运行ID</span><br><span class="line">例：若要将上面分好的1000个插槽迁移回到6000管理</span><br><span class="line"></span><br><span class="line">前提：插槽中没有任何键。因为这样迁移时并不会连同相应键一起迁移，会造成键的丢失。</span><br></pre></td></tr></table></figure></p><p>可通过<code>cluster getkeysinslot 插槽号 要返回的键的数量</code>获取指定插槽中的键，以查看要迁移的插槽中是否存在键。<br>然后把每个键迁移迁移到目标节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">migrate 目标节点地址 目标节点端口 键名 数据库号 超时时间 [copy] [replace]`</span><br><span class="line">其中copy和replace可选，copy表示不会将键从当前数据库删除，只是复制。replace表示目标节点若存在同名键则覆盖。</span><br><span class="line">因为集群模式数据库只能使用0号数据库，所以数据库号始终是0</span><br></pre></td></tr></table></figure></p><p>Redis还提供以下命令实现集群不下线的数据迁移：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clsuter setslot 插槽号 migrating 新节点运行ID</span><br><span class="line">cluster setslot 插槽号 importing 原节点运行ID</span><br><span class="line"></span><br><span class="line">迁移时若要把N号插槽从A迁移到B，需要如下操作</span><br><span class="line">在B执行cluster setslot N importing A</span><br><span class="line">在A执行clsuter setslot N migrating B</span><br><span class="line">在A执行cluster getkeysinslot N 获取N号插槽的键列表</span><br><span class="line">对列表的每个键都执行migrate命令</span><br><span class="line">执行cluster setslot 0 B 完成迁移</span><br></pre></td></tr></table></figure></p><p>当客户端向集群中任一节点发送命令后，该节点都会判断相应键是否在当前节点，若在则立刻处理，若不在则返回一个MOVE重定向请求，告诉客户端目前负责该键的节点。返回的错误信息格式为：<br><code>(error) MOVED 键所在的插槽号 IP地址:端口</code><br><code>redis-cli</code>也提供集群模式支持自动重定向，通过<code>-c</code>参数启动客户端。</p><p>集群中每个节点都会每隔1秒随机选5个节点，并选择其中最久无响应的节点发送一个ping，若超时无回复，则变为主观下线，进行判断，与哨兵类似。选择主数据库的过程也与哨兵一致，都使用Raft算法。<br>若一个至少负责一个插槽的主数据库下线且无相应从数据库可进行故障恢复，则<strong>整个集群</strong>默认会进入下线状态无法工作。也可修改配置文件的<code>cluster-require-full-coverage</code>设为no，使集群在这种情况下继续工作。</p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>可通过配置文件的<code>requirepass</code>参数设置密码，于是客户端每次连接数据库时必须发送密码验证，否则Redis会拒绝执行客户端发来的命令，会报错：<code>(error)NOAUTH Authentication required</code>。<br>使用<code>auth 密码</code>验证。<br>也可在redis中通过命令<code>config set requirepass 密码</code>设置密码。<br>也可通过命令<code>config get requirepass</code>获取密码（已验证后才能看）</p><p>攻击者会通过穷举法破解Redis密码（1秒内可尝试十几万个密码）。</p><blockquote><p>配置Redis复制时，若主数据库设置了密码，需要在从数据库的配置文件中通过<code>masterauth</code>参数设置验证密码，在从数据库连接主数据库时会自动<code>auth</code>验证。</p></blockquote><p>Redis支持对命令的重命名，可在配置文件中的<code>rename-command</code>进行设置。格式为<code>rename-command 命令 重命名后的命令</code>。<br>若要禁用某命令可直接将该命令重命名为空字符串即可。</p><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>Redis支持两种通信协议：</p><ul><li>统一请求协议：二进制安全</li><li>简单协议：便于在telnet中输入（已废弃）</li></ul><p>简单协议中提供五种telnet返回值表示形式已被封装到redis-cli中，而就成为了redis的返回形式。</p><ul><li>错误回复error reply<br>以<code>-</code>开头，并跟上错误信息，以<code>\r\n</code>结尾</li><li>状态回复status reply<br>以<code>+</code>开头，跟上状态信息，以<code>\r\n</code>结尾</li><li>整数回复integer reply<br>以<code>:</code>开头，跟上数值，以<code>\r\n</code>结尾</li><li>字符串回复bulk reply<br>以<code>$</code>开头，跟上字符串长度，<code>\r\n</code>分隔，再跟上字符串内容，再以<code>\r\n</code>结尾。若返回值为空，会返回<code>$-1</code></li><li>多行字符串回复multi-bulk reply<br>以<code>*</code>开头，跟上字符串个数，<code>\r\n</code>分隔，再跟上字符串内容，再以<code>\r\n</code>结尾。</li></ul><p><strong>统一请求协议</strong><br>命令格式类似于多行字符串回复的格式，每个命令都可以包含二进制字符。<br>Redis的AOF文件和主从复制时发送的内容都使用了统一请求协议。<br>若发送命令<code>set foo bar</code>，则在传输中的写法为<code>*3\r\n$3\r\nSET\r\n*3\r\n$3\r\nFOO\r\n*3\r\n$3\r\nBAR\r\n</code>。</p><h3 id="一些管理命令"><a href="#一些管理命令" class="headerlink" title="一些管理命令"></a>一些管理命令</h3><ul><li>耗时命令日志<br>当一条命令执行时间超时后，Redis会将该命令的执行时间等信息加入耗时命令日志（slow log）。可通过配置文件的<code>slowlog-log-slower-than</code>参数设置该限制时间，单位为微秒（1s=10^6μs），默认为10000μs。耗时命令日志会存储在内存中，也可通过配置文件<code>slowlog-max-len</code>设置记录的最多条数，默认128。</li></ul><p>可在rediscli中使用<code>slowlog get</code>获取当前耗时命令日志。<br>每条日志由四个部分组成：</p><ol><li>该日志的唯一ID</li><li>该命令执行的Unix时间</li><li>该命令的耗时时间，单位微秒</li><li>命令和参数</li></ol><ul><li>命令监控<br>Redis提供<code>monitor</code>命令监控Redis执行的所有命令。<br>在一个终端中输入<code>monitor</code>，便开始监视任何执行操作（该终端被挂起，不能执行命令）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在第一个终端中输入</span><br><span class="line">127.0.0.1:6379&gt; MONITOR</span><br><span class="line">OK</span><br><span class="line">在另一个终端中执行一条命令</span><br><span class="line">set foo bar</span><br><span class="line"></span><br><span class="line">于是在第一个终端中就会打印出以下内容</span><br><span class="line">1531104811.876088 [0 127.0.0.1:41664] &quot;COMMAND&quot;</span><br><span class="line">1531104820.923283 [0 127.0.0.1:41664] &quot;set&quot; &quot;foo&quot; &quot;bar&quot;</span><br></pre></td></tr></table></figure></li></ul><p><code>monitor</code>命令十分影响redis的性能，会降低近一半的负载能力，因此只适合进行排错和调试。</p><ul><li><code>config get &lt;指定配置&gt;</code>：获取服务器配置信息（就是配置文件中的参数）。</li></ul><h2 id="Redis配置文件常用参数"><a href="#Redis配置文件常用参数" class="headerlink" title="Redis配置文件常用参数"></a>Redis配置文件常用参数</h2><p>按照配置文件中的出现顺序</p><ul><li><p><code>bind &lt;IPaddr&gt;</code>： 指定Redis只接收该地址的请求。默认接收所有IP地址的请求，这样会造成安全隐患，最好填写需要调用redis的服务器的IP地址，或者直接写<code>127.0.0.1</code>仅允许本地用户调用。</p></li><li><p><code>daemonize yes|no</code>：是否在后台运行。默认在前台运行</p></li><li><p><code>pidfile</code>：PID文件路径。若运行多个Redis，则需要在各自的配置文件中指定不同的PID文件路径和端口</p></li><li><p><code>port</code>：Redis监听的端口，默认为6379</p></li><li><p><code>timeout</code>：客户端连接超时时间，单位秒。若客户端在超时前没发出任何指令，则会关闭连接。</p></li><li><p><code>logfile</code>：日志文件路径</p></li><li><p><code>loglevel</code>：日志等级，分为四个：debug、verbose、notice、warning，默认为notice</p></li><li><p><code>databases</code>：数据库个数，默认设为16个</p></li><li><p><code>save &lt;seconds&gt; &lt;changes&gt;</code>：redis进行备份的频率。在多少秒内进行几次更新操作，就会触发备份，将数据同步到RDB文件。详见持久化</p></li><li><p><code>rdbcompression yes|no</code>：是否开启rdb备份时压缩，默认开启</p></li><li><p><code>dbfilename</code>：rdb备份的文件名，默认为<code>dump.rdb</code></p></li><li><p><code>dir</code>：rdb备份文件存放路径。路径和文件名要分开配置，因为Redis备份时会先将当前数据库的状态写入一个临时文件，等备份完成后再把该文件替换为指定文件。</p></li><li><p><code>slaveof &lt;masterip&gt; &lt;masteport&gt;</code>：在从数据库上设置，指定主数据库</p></li><li><p><code>masterauth &lt;master-password&gt;</code> ：当主数据库连接需要密码验证时，在此指定密码</p></li><li><p><code>requirepass</code>：设置客户端连接后进行任何其他操作前需要的密码。</p><blockquote><p>因为Redis速度快，所以外部用户可以每秒进行150000次密码尝试，若密码简单，很容易被破解。</p></blockquote></li><li><p><code>maxmemory &lt;bytes&gt;</code>：设置Redis最大能使用的内存，单位字节。当分配的内存完全被占用后，若再接收到set命令，则Redis会先删除设置了expire的键，无论是否到期。若所有expire的键都被删除了，则redis不再进行set操作，只允许get操作。此参数适合把redis当做类似Memcached缓存来使用</p></li><li><code>maxclients</code>：限制同时连接的客户数。当连接数超过该值，则不再接收，并返回error。</li><li><code>appendonly yes|no</code> ：默认情况下，redis会在后台异步把数据库镜像备份到此磁盘，但这样备份非常耗时，且不能很频繁，若断电会造成大量数据丢失。若开启appendonly，则redis会将接收到的每一次写操作追加到<code>appendonly.aof</code>中，当redis重启时，会从该文件恢复到之前的状态。但这样容易造成该文件过大。可通过指令<code>BGREWRITEAOF</code>对该文件整理。</li><li><code>appendfsync always|everysec|no</code>：详见持久化</li><li><code>vm-enabled</code>：是否开启虚拟内存支持。当内存不够时，会把value存放到交换区（swap）中。性能基本不受影响。同时要将<code>vm-max-memory</code>设置足够大以存放所有key</li><li><code>vm-max-memory</code>：开启虚拟内存后redis可用的最大内存大小，默认为0。在生产环境中，最好不要设为0，根据实际情况调整。</li></ul><h2 id="在Docker上搭建Redis"><a href="#在Docker上搭建Redis" class="headerlink" title="在Docker上搭建Redis"></a>在Docker上搭建Redis</h2><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol><li><p><strong>Redis内存用完怎么办？</strong></p><p>redis的性能会下降，并可能出错。可通过info查看redis内存使用情况，并写脚本进行监控。可通过配置文件<code>maxmemory</code>调整redis可用内存大小。若redis的内存使用达到上限，即给出错误写入的命令，仅能接受只读命令。</p></li><li><p><strong>使redis内存使用率降低的方法？</strong></p><p>最好使用redis的哈希、列表、排序集、整数集</p></li><li><p><strong>如果没有数据集较大的内存，怎么进行高层次的操作？</strong></p><p>使用客户端哈希，并部署redis集群，自动分发，以及redis子集的热备</p></li><li><p><strong>单线程Redis如何利用多个CPU？</strong></p><p>只需在同一台机器上启动多个redis实例，当做不同服务器即可。</p></li></ol><h2 id="Redis报错问题"><a href="#Redis报错问题" class="headerlink" title="Redis报错问题"></a>Redis报错问题</h2><ul><li>Redis被配置为保存数据库快照，但它目前不能持久化到硬盘。用来修改集合数据的命令不能用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">报错：(error) MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.</span><br></pre></td></tr></table></figure></li></ul><p>原因：强制关闭Redis快照导致不能持久化<br>解决：将配置文件<code>stop-writes-on-bgsave-error</code>设置为no</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>Redis入门指南（第二版）<br><a href="https://segmentfault.com/a/1190000010131816" target="_blank" rel="noopener">Linux_基于Docker搭建Redis集群</a><br><a href="https://segmentfault.com/a/1190000014618411" target="_blank" rel="noopener">Docker Redis的官方镜像简单使用</a><br><a href="https://segmentfault.com/a/1190000009857207" target="_blank" rel="noopener">【Redis】基于 Redis3.2.4 集群搭建说明</a></p><p>高性能网站构建实战</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>运维小技巧整理</title>
      <link href="/2018/05/09/%E8%BF%90%E7%BB%B4%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/"/>
      <url>/2018/05/09/%E8%BF%90%E7%BB%B4%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>网上、书上的运维技巧整理</p><a id="more"></a><h3 id="删除脚本-1"><a href="#删除脚本-1" class="headerlink" title="删除脚本-1"></a>删除脚本-1</h3><p>为防止<code>rm -rf</code>失误造成破坏，可将删除写成一个脚本<code>remove.sh</code></p><ol><li>首先在指定目录创建<code>.trash</code>目录，作为回收站</li><li><p>创建脚本，放在一个固定位置<code>/root/shell/</code><br> <code>vim /root/shell/remove.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">TRASH_DIR=<span class="string">"/root/.trash"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*;<span class="keyword">do</span></span><br><span class="line">        TIME_STAMP=$(date +%F)</span><br><span class="line">        filename=<span class="variable">$i</span></span><br><span class="line">        mv <span class="variable">$i</span> <span class="variable">$TRASH_DIR</span>/<span class="variable">$TIME_STAMP</span>.<span class="variable">$filename</span></span><br><span class="line">        <span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>设置<code>rm</code>别名<code>vim /root/.bashrc</code><br>修改<code>alias rm=&quot;sh /root/shell/remove.sh&quot;</code></p></li><li>设置定时任务<br><code>echo &quot;0 0 * * * rm -rf /root/.trash/*&quot; &gt;&gt; /etc/crontab</code><br>这样删除的文件也能尽快恢复</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx笔记-1</title>
      <link href="/2018/05/02/Nginx%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/02/Nginx%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇包含以下知识点：</p><ul><li><a href="#Nginx介绍">Nginx介绍</a></li><li><a href="#Nginx安装">Nginx安装</a></li><li><a href="#Nginx配置文件解析">Nginx配置文件解析</a></li><li><a href="#访问控制、身份认证与SSL">访问控制、身份认证与SSL</a></li><li><a href="#Nginx日志">Nginx日志</a></li><li><a href="#Nginx缓存">Nginx缓存</a></li></ul><a id="more"></a><ul><li><a href="">Nginx负载均衡</a></li><li><a href="#Nginx反向代理">Nginx反向代理</a></li><li><a href="#Nginx邮件服务">Nginx邮件服务</a></li><li><a href="#重写与重定向">重写与重定向</a></li><li><a href="#Nginx常见模块">Nginx常见模块</a></li><li><a href="">Nginx配置简单优化</a></li><li><a href="#LNMP分布式集群方案">LNMP分布式集群方案</a></li><li><a href="">Docker部署LNMP</a></li></ul><h1 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h1><p>Nginx有以下功能：</p><ul><li>负载均衡</li><li>HTTP web服务器</li><li>http协议的反向代理服务器</li><li>pop3\smtp\imap4等邮件协议的反向代理</li><li>能缓存打开的文件（元数据） ，支持FastCGI、uWSGI协议，作为缓存服务器</li><li>模块化（非DSO机制），过滤器zip，SSI，SSL</li></ul><p>特性：</p><ul><li>模块化设计，较好扩展性</li><li>高可靠性：master/worker支持多进程，也支持多线程</li><li>支持热备份：不停机更新配置文件，更换日志，更新服务器程序版本</li><li>低内存消耗：10000个 keep-alive连接模式下非活动连接仅消耗2.5M内存</li><li>热部署（平滑升级）：旧的配置维持现状，新的配置立刻使用，并在使用中逐步自动将旧配置替换为新配置。</li></ul><p><strong>Nginx架构：</strong><br>nginx会以daemon方式启动进程，后台进程包含一个master进程和多个worker进程。<br>master进程用于启动管理多个worker进程，若取消master进程，则nginx会以单进程运行<br>一个请求只能在一个worker进程中处理，一个worker进程只能处理一个请求。worker进程个数一般设置为cpu核数</p><ul><li>master：加载配置文件、管理worker进程、平滑升级</li><li>worker：http服务、http代理、fastcgi代理</li><li>事件驱动：epoll      </li><li>消息通知：select、poll、rt signals</li><li>模块类型：核心模块、标准http模块、可选http模块、邮件模块、第三方模块</li></ul><img src="/2018/05/02/Nginx笔记/nginx_jiagou.png" title="jiagou"><p><strong>Master进程完成的工作：</strong></p><ul><li>读取并验证配置文件</li><li>创建、绑定及关闭套接字</li><li>启动、终止及维护worker进程</li><li>无需终止服务而重新配置</li><li>控制非中断式程序升级（平滑升级），启用新的二进制程序，并且能在需要时回滚到老版本</li><li>重新打开日志文件</li><li>可编译嵌入式perl脚本</li></ul><p><strong>Worker进程完成的工作：</strong></p><ul><li>接收、传入并处理来自客户端的请求</li><li>提供反向代理及过滤功能</li></ul><p><strong>请求过程：</strong></p><ol><li>在master进程里面，先建立好需要listen的socket（listenfd）之后，然后再fork出多个worker进程</li><li>所有worker进程的listenfd会在新连接到来时变得可读，为<strong>保证只有一个进程处理该连接</strong>，所有worker进程在注册listenfd读事件前抢accept_mutex，抢到互斥锁的那个进程注册listenfd读事件，在读事件里调用accept接受该连接。</li><li>当一个worker进程在accept这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接</li></ol><p><strong>IO复用</strong>：</p><p>​    单进程模型：阻塞，一次仅处理一个请求，无法应对高并发场景</p><p>​    多进程模型：每个进程响应一个请求。缺陷：当请求量庞大时，会占用大量CPU及内存资源，因为每个请求访问的页面都会单独缓存，若访问的页面相同，会造成内存使用效率低，且进程间切换会消耗大量CPU资源</p><p>​    Linux原生并不支持线程，Windows和SunOS都支持。Linux将线程当做进程来处理，但称作LWP轻量级进程（Light Weight Process），Linux进行线程管理是通过调用各种线程库实现的。</p><p>​    多线程单请求模型：每个线程响应一个请求。线程和进程类似，也需要切换，但线程是轻量级的进程，切换消耗的资源很小。且同一进程内的线程共享一片存储空间，若有访问同一资源的请求，也可直接从存储空间调用该资源。线程对内存资源的需求量也比进程要小。而如果CPU数量只有1个，则多线程的优势基本无法体现，只有在多颗CPU的情况下，多线程才能发挥出极高的效率。</p><p>​    多线程多请求模型：一个线程响应多个请求。</p><h1 id="Nginx安装"><a href="#Nginx安装" class="headerlink" title="Nginx安装"></a>Nginx安装</h1><p>在安装nginx前需要安装以下环境：</p><ul><li>gcc与gcc-c++等，可直接组安装Development Tools</li><li>prce-devel(perl的正则表达库)</li><li>zlib与zlib-devel(资料压缩的函数库)</li><li>openssl与openssl-devel(安全套接字密码库)</li></ul><p>创建系统用户组<code>groupadd -r nginx</code><br>创建系统<code>useradd -r nginx -M -g nginx</code></p><blockquote><p><code>-r</code>创建系统用户（组），<code>-M</code>不创建该用户家目录</p></blockquote><p>创建目录<code>/var/tmp/nginx/client</code>，否则在后面运行时可能报错。</p><p><strong>初始化文件模块配置</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/nginx \ # 设置nginx安装目录</span><br><span class="line">--sbin-path=/usr/sbin/nginx \  # 命令放在/sbin下</span><br><span class="line">--conf-path=/etc/nginx/nginx.conf \  # 配置文件位置</span><br><span class="line">--pid-path=/var/run/nginx/nginx.pid \  # nginx进程号文件</span><br><span class="line">--lock-path=/var/lock/nginx.lock \  # nginx锁文件</span><br><span class="line">--user=nginx \  # 指定用户</span><br><span class="line">--group=nginx \  # 指定用户组</span><br><span class="line">--http-log-path=/var/log/nginx/access.log \  # 运行日志位置</span><br><span class="line">--error-log-path=/var/log/nginx/error.log \  # 报错日志</span><br><span class="line">--http-client-body-temp-path=/var/tmp/nginx/client \  </span><br><span class="line"># 指定客户端post上传的$_FILES上传的文件地址，该目录需要自己创</span><br><span class="line">--with-http_ssl_module \   # 加载ssl模块，默认没加载</span><br><span class="line">--with-http_stub_status_module \  # 加载监控模块</span><br><span class="line">--with-http_gzip_static_module \  # 加载gzip压缩模块</span><br><span class="line">--with-debug  # 允许debug</span><br></pre></td></tr></table></figure><p>之后<code>make &amp;&amp; make install</code></p><p>nginx命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br><span class="line">  -t           #检查配置文件语法</span><br><span class="line">  -c           #指定配置文件</span><br><span class="line">  -V           #查看编译信息</span><br><span class="line">  -s           #指定对nginx的操作</span><br><span class="line">    stop      #停止（快速关闭）</span><br><span class="line">    quit      #退出（优雅关闭，所有worker进程会停止接收新连接，然后将所有未处理完的请求处理完后关闭）</span><br><span class="line">    reopen    #重新打开日志文件</span><br><span class="line">    reload    #重新读取配置文件（平滑重启）</span><br><span class="line">  -q           #在配置测试期间不显示非错误消息</span><br></pre></td></tr></table></figure><h1 id="Nginx配置文件解析"><a href="#Nginx配置文件解析" class="headerlink" title="Nginx配置文件解析"></a>Nginx配置文件解析</h1><p>配置文件<code>/etc/nginx.conf</code><br>配置文件组织结构：</p><ul><li>全局配置：main</li><li>模块配置：events，http，server，location</li></ul><p><strong>注：配置的每条指令的结尾必须加上分号<code>;</code></strong></p><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="main块"><a href="#main块" class="headerlink" title="main块"></a>main块</h3><ul><li><p>正常运行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user Username [Groupname]  # 指定运行worker进程的用户</span><br><span class="line">pid PATH  # 指定nginx进程的pid文件</span><br><span class="line">worker_rlimit_nofile   # 指定一个worker进程所能打开的最大文件描述符数量</span><br><span class="line">worker_rlimit_sigpending  # 指定每个用户能发给worker进程的最大的信号数量</span><br></pre></td></tr></table></figure></li><li><p>性能优化配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  # worker进程个数，通常为物理CPU核心数量-1</span><br><span class="line">可填auto，自动使用所有CPU。</span><br><span class="line">worker_cpu_affinity CPUMask # 指定使用的cpu，cpumask为cpu掩码。</span><br><span class="line"># cpumask：0001,0010,0100,1000</span><br><span class="line">work_priority NICE  # 指定nice值，即优先级</span><br></pre></td></tr></table></figure></li></ul><p><code>worker_processes</code>和<code>work_connections</code>决定了最大并发数量。最大并发量即为<code>worker_processes × work_connections</code></p><p>而在反向代理场景，因为nginx既要维持和客户端的连接，又要维持和后端服务器的连接，因此处理一次连接要占用2个连接，所以最大并发数为：<code>worker_processes × worker_connections/2</code></p><p>Nginx可能还会打开其他的连接，这些都会占用文件描述符，影响并发数量</p><p>最大并发数量还受”允许打开的最大文件描述符数量”限制，可以使用<code>worker_rlimit_nofile</code>指令修改。或直接通过<code>ulimit -n</code>修改</p><ul><li>调试定位配置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">daemon &#123;on|off&#125;  # 是否以守护进程方式启动</span><br><span class="line">master_process &#123;on|off&#125;  # 是否以master模型运行</span><br><span class="line">error_log PATH [level]  # 错误日志文件路径及日志等级。</span><br><span class="line">#日志等级：debug|info|notice|warn|error|crit|alert|emerg，默认为error</span><br><span class="line"># 可设置为debug，但需要在编译时指定--with-debug才能用</span><br><span class="line"># 若要禁用error_log 则可设置为error_log /dev/null;</span><br></pre></td></tr></table></figure></li></ul><h2 id="模块配置"><a href="#模块配置" class="headerlink" title="模块配置"></a>模块配置</h2><h3 id="events块"><a href="#events块" class="headerlink" title="events块"></a>events块</h3><p><code>events { }</code>事件驱动，并发响应连接。控制Nginx处理连接的方式<br>包含以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker_connections  # 每个worker进程能响应的最大并发请求数量</span><br><span class="line">use &#123;epoll | select | poll &#125;  # 选择使用事件类型，最好让nginx自动选择</span><br><span class="line">accept_mutex &#123;on|off&#125;  # 是否开启负载均衡锁，启用时，表示让多个worker进程轮流响应请求。默认开启</span><br><span class="line">lock_file PATH   # 锁文件路径</span><br></pre></td></tr></table></figure><h3 id="http块"><a href="#http块" class="headerlink" title="http块"></a>http块</h3><p><code>http { }</code>处理http响应的配置</p><p>注：http块下的文件相对路径是相对于Nginx的配置文件目录</p><p>包含以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">#include  用于引入配置文件</span><br><span class="line">#设置mime.types文件路径，若是相对地址则是相对于nginx.conf配置文件</span><br><span class="line">include       mime.types;     </span><br><span class="line"></span><br><span class="line">#default_type用于设置默认文件类型</span><br><span class="line">#若在编译时设置了配置文件目录，则此项路径为/usr/share/mime/application/octet-stream.xml</span><br><span class="line">default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">#日志格式</span><br><span class="line">#log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">#日志文件路径，由于已设置了/var/log/nginx/access.log，所以不需要改</span><br><span class="line">#access_log  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">#开启高效传输文件模式，默认为on。</span><br><span class="line">#可以让Nginx在传输文件时直接在磁盘和tcp socket之间传输数据，而不用经过任何buffer</span><br><span class="line">sendfile        on;</span><br><span class="line"></span><br><span class="line">#在sendfile为on时，确定是否启用tcp_nopush(FreeBSD)或tcp_cork(linux)</span><br><span class="line">#会将多个http首部打包为单个报文。用于防止网络阻塞，但会额外占用资源</span><br><span class="line">#tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">tcp_nodelay &#123;on| off&#125; </span><br><span class="line">#tcp 有一个nagle算法，将多个小的数据块打包传输以提高带宽利用率。</span><br><span class="line">#有时只需要访问一个较小页面，但由于nagle算法，要等待其他响应以打包为大数据块，所以会等较长时间才会返回页面。对keepalive模式下连接是否使用tcp_nodelay。通常关闭。</span><br><span class="line"></span><br><span class="line">#设置keepalive长连接的超时时间。默认为65。若为0则保持长连接</span><br><span class="line">#keepalive_timeout  0;</span><br><span class="line"></span><br><span class="line">#设置keepalive连接上最大请求资源数，默认100</span><br><span class="line">keepalive_requests 数量      </span><br><span class="line"></span><br><span class="line">#指明禁止指定浏览器使用keepalive功能</span><br><span class="line">keepalive_disable &#123;none|browser&#125;</span><br><span class="line"></span><br><span class="line">#设置发送响应报文的超时时长，默认60s</span><br><span class="line">send_timeout  时长     </span><br><span class="line"></span><br><span class="line">#接收客户端报文body的缓冲区大小，默认8k（32位|16k--64位）超出该大小时，会被存储于磁盘</span><br><span class="line">client_body_buffer_size  数值     </span><br><span class="line"></span><br><span class="line">#指定存储客户端报文的路径及子目录的结构数量</span><br><span class="line">#就是编译时--http-client-body-temp-path指定的路径</span><br><span class="line">client_body_temp_path PATH &#123;level1 | level2 | level3&#125;   </span><br><span class="line">#例：client_body_temp_path /var/tmp/client_body  2 2 表示该目录下有2层目录，每层有两个子目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#是否开启gzip压缩响应报文</span><br><span class="line">#gzip  on;</span><br><span class="line"></span><br><span class="line">#指定错误页面</span><br><span class="line">#error_page  404  /404.html;</span><br><span class="line">error_page   500 502 503 504  /50x.html;</span><br><span class="line">#更改响应状态码，隐藏服务器的真实状态码信息</span><br><span class="line">#error_page  404=200 /404.html;</span><br><span class="line">#设置由重定向后实际的处理结果来决定状态码</span><br><span class="line">#error_page  404=/404.html;</span><br><span class="line"></span><br><span class="line">server &#123; &#125;  # 虚拟主机模块</span><br></pre></td></tr></table></figure><h3 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#虚拟主机监听的本地端口和主机名</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line"></span><br><span class="line">#设置编码类型，为防止网页出现乱码，需要将charset设置gb2312或utf-8。</span><br><span class="line">#charset koi8-r;</span><br><span class="line"></span><br><span class="line">#Location，URI的根</span><br><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /XXX &#123;&#125;  #location块</span><br><span class="line"></span><br><span class="line">#在响应首部中添加字段</span><br><span class="line">add_header 字段名 值</span><br><span class="line"></span><br><span class="line">try_files  [页面] [uri | =code] </span><br><span class="line">#设置尝试打开的文件，若都找不到再返回最后一个uri</span><br><span class="line">#最后一个uri必须存在，且必须由别的location定义，不能在当前的location中，否则会死循环 </span><br><span class="line">#例：try_files $uri xxx.html 先找用户需要的uri，若找不到返回xxx.html</span><br><span class="line"></span><br><span class="line">#显示访问连接信息。</span><br><span class="line">#stub_status   on;  #注：要放入server块</span><br><span class="line"># 然后设置location</span><br><span class="line">#location /status &#123;</span><br><span class="line">#  stub_status;</span><br><span class="line">#&#125;</span><br><span class="line">#便可通过域名/status 查看。</span><br><span class="line">Active connections: 164 </span><br><span class="line">server accepts handled requests</span><br><span class="line"> 7595 7595 7601 </span><br><span class="line">Reading: 0 Writing: 164 Waiting: 0 </span><br><span class="line"># 当前活动连接数</span><br><span class="line">已接收的连接个数，已处理的连接个数，已经处理的请求个数</span><br><span class="line">正在读取客户端的Header个数（Reading），正在返回给客户端的Header个数（Writing），长连接或等待状态的请求个数（Waiting）（当开启Keepalive时，该值为Active-Reading-Writing）。</span><br></pre></td></tr></table></figure><h3 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h3><p>目录映射。允许根据用户请求的URI匹配定义的location，匹配到就按该location中的配置处理</p><p>location的第一个<code>/</code>为root中指定路径的最后的<code>/</code></p><p><code>alias</code> 设置别名，用于定义路径别名，<strong>只用于location配置段</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /images &#123;</span><br><span class="line">  root /data/www/imgs/ ;      </span><br><span class="line">  # 即表示在URL中访问/images即为访问服务器中/data/www/imgs/images/目录</span><br><span class="line">  # root为将location接在root指定的路径后</span><br><span class="line">&#125;</span><br><span class="line">location /images &#123;</span><br><span class="line">  alias /data/www/imgs/ ;     </span><br><span class="line">  # 即表示在URL中访问/images即为访问服务器的/data/www/imgs/ 目录</span><br><span class="line">  # alias为整段替换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与root和alias指令相关的变量为<code>$document_root</code>、<code>$realpath_root</code>。</p><p><strong><code>$document_root</code>的值即是root指令、alias指令的值</strong></p><p><strong><code>$realpath_root</code>的值是对root、alias指令进行绝对路径换算后的值</strong></p><p><strong><code>location</code>匹配</strong></p><ul><li><p>不带符号URI：匹配该资源目录下的所有资源</p></li><li><p><code>=</code> URL精确匹配，只匹配该资源</p></li><li><p><code>~</code> 正则表达式匹配，区分大小写</p></li><li><p><code>~*</code> 正则表达式匹配，不区分大小写（例如 <code>location ~* \.(gif|jpg)$</code> 匹配<code>.gif</code>或<code>jpg</code>结尾的文件）</p></li><li><p><code>^~</code> URI左半部分匹配，非正则匹配，不区分大小写</p></li></ul><p><strong>优先级：<code>=</code> &gt; <code>^~</code>&gt;<code>~</code>或<code>~*</code>&gt; 不带符号的URI</strong></p><h1 id="访问控制、身份认证与SSL"><a href="#访问控制、身份认证与SSL" class="headerlink" title="访问控制、身份认证与SSL"></a>访问控制、身份认证与SSL</h1><p>Nginx的两个配置访问控制的指令<code>allow</code>和<code>deny</code>，由模块<code>ngx_http_access_module</code>提供。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow|deny  IP地址[/mask]</span><br><span class="line">allow|deny  all</span><br></pre></td></tr></table></figure><p>若同一个块中同时配置了多条<code>deny</code>或<code>allow</code>，则先出现的访问权限生效。若多个块中都配置了权限指令，则内层的优先级高于外层的。</p><p>被访问控制deny的IP地址访问时会返回<strong>403</strong>状态码。</p><p>Nginx的basic身份认证指令<code>auth_basic</code>和<code>auth_basic_user_file</code>由模块<code>ngx_http_auth_basic_module</code>提供。可配置在http、server、location块中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auth_basic  描述 | off;   是否开启http_basic对用户认证</span><br><span class="line">auth_basic_user_file  FILE;  指定用户认证的账号文件</span><br></pre></td></tr></table></figure><p>可通过Apache的工具<code>htpasswd</code>创建用户认证文件</p><p><code>htpasswd -c -m -b /etc/nginx/secret mike 123456</code></p><p>使用SSL将网站配置为HTTPS</p><p>首先进入目录<code>/etc/pki/CA/private</code>下创建服务器RSA私钥，叫<code>server.key</code>。</p><p><code>openssl genrsa -out server.key 2048</code></p><p>生成服务器的CSR证书请求文件。CSR证书请求文件是服务器的公钥，用于提交给CA机构进行签名。</p><p><code>openssl req -new -key server.key -out server.csr</code>按要求填写信息即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:CN</span><br><span class="line">State or Province Name (full name) []:Jiangsu</span><br><span class="line">Locality Name (eg, city) [Default City]:Yangzhou</span><br><span class="line">....</span><br><span class="line">Common Name (eg, your name or your server&apos;s hostname) []:system3.example.com</span><br></pre></td></tr></table></figure><p>CSR参数含义：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>Country Name</td><td>符合ISO的两个字母的国家代码，中国CN</td></tr><tr><td>State or Province Name</td><td>省份</td></tr><tr><td>Locality Name</td><td>城市</td></tr><tr><td>Organization Name</td><td>公司名</td></tr><tr><td>Organizational Unit Name</td><td>组织名/部门名</td></tr><tr><td>Common Name</td><td>使用SSL加密的域名，不能填错</td></tr><tr><td>Email Address</td><td>邮箱，可省略</td></tr><tr><td>A challenge password</td><td>有的CA机构需要此密码，通常省略即可</td></tr><tr><td>An optional company name</td><td>可选的公司名，可省略</td></tr></tbody></table><p>CA为服务器认证证书</p><p><code>openssl x509 -req -days 30 -in server.csr -signkey server.key -out server.crt</code></p><blockquote><p>在CA用私钥签名了证书后，该证书将用于浏览器验证请求的网站是否真实，防止网络通信过程中被篡改。</p><p>浏览器保存了受信任的CA机构的公钥，在请求HTTPS网站时，会利用CA公钥验证服务器证书，并检查域名是否吻合、证书是否过期等。</p></blockquote><p>在Nginx配置文件中设置https配置。Nginx配置文件中已默认存在SSL配置，只是注释了，取消注释，并修改crt文件路径即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  system3.example.com;</span><br><span class="line">ssl          on;         # 这条配置文件可能没有，要加上</span><br><span class="line">        ssl_certificate      /etc/pki/CA/private/server.crt; # SSL认证证书路径</span><br><span class="line">        ssl_certificate_key  /etc/pki/CA/private/server.key; # SSL认证密钥路径</span><br><span class="line"></span><br><span class="line">        ssl_session_cache    shared:SSL:1m;  # 用于存储SSL会话的高速缓存的类型和大小</span><br><span class="line">        ssl_session_timeout  5m; # 客户端可以重复使用存储在缓存中的会话参数的时间</span><br><span class="line">        ssl_ciphers  HIGH:!aNULL:!MD5;   # openssl允许的加密类型</span><br><span class="line">        ssl_prefer_server_ciphers  on;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>/etc/hosts</code>中确定配置了system3的条目。在浏览器上输入<code>https://system3.example.com</code>会说明此连接不安全。是因为当前的证书是服务器自己作为CA签名的，所以浏览器无法信任。点添加例外，可查看该证书，与配置的一致。</p><img src="/2018/05/02/Nginx笔记/1.png"><img src="/2018/05/02/Nginx笔记/2.png"><p>添加安全例外后，即可访问网页</p><h1 id="Nginx日志"><a href="#Nginx日志" class="headerlink" title="Nginx日志"></a>Nginx日志</h1><p>关于Nginx日志的指令如下：</p><ul><li><p><code>log_format</code>：日志格式。格式：<code>log_format 格式名 格式（由变量组成）</code>，默认格式如下：</p><p><code>&#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39; &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;</code></p><ul><li><code>$remote_addr</code>：客户端的地址。如果Nginx服务器在后端，则该变量只能获取到前端（代理或负载均衡服务器）的IP地址</li><li><code>$remote_user</code>：远程客户端用户名称</li><li><code>$time_local</code>：记录访问时间和时区信息</li><li><code>$request</code>：记录用户访问时的url和http协议信息</li><li><code>$status</code>：记录客户端请求时返回的状态码</li><li><code>$body_bytes_sent</code>：记录服务器响应给客户端的主体大小</li><li><code>$http_referer</code>：记录此次请求是从哪个链接过来的，需要模块<code>ngx_http_referer_module</code>支持，默认已装，可以防止盗链问题</li><li><code>$http_user_agent</code>：记录客户端的浏览器信息。如使用什么浏览器发起的请求，是否是压力测试工具在测试等</li><li><code>$http_x_forward_for</code>：若要在<code>$remote_addr</code>中获取的是真正客户端的IP，则要添加此项，并且在前端的服务器要开启<code>x_forward_for</code></li></ul></li><li><p><code>access_log</code>：访问日志的路径和采用的日志格式名。格式：<code>access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];</code>。若不指定格式名，默认为combined。buffer为日志缓冲区的大小，默认64K。flush为日志刷盘时间，即日志保存在缓冲区的最大时间。gzip为日志刷盘前是否压缩以及压缩级别。if指定条件。</p></li><li><p><code>open_log_file_cache</code>：设置日志文件缓存。默认关闭，即每一条日志都是打开文件，写入后关闭，这样会消耗一定量的IO。而设置了缓存后，会等日志数量达到一个指标后一下写入日志文件。</p><p>格式：<code>open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];</code>。其中max为缓存中的最大文件描述符数量。inactive为存活时间，默认是10s。min_uses为在inactive时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是1次。valid为检查频率，默认60s。</p></li><li><p><code>log_subrequest</code>：是否在access.log中记录子请求的访问日志。默认不记录</p></li><li><p><code>rewrite_log</code>：是否在error.log中记录notice级别的重写日志。默认关闭</p></li></ul><h2 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h2><p>默认Nginx不会自动切割日志。</p><p><strong>手动切割</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv access.log access-XXXX.log</span><br><span class="line">nginx -s reopen</span><br></pre></td></tr></table></figure><p><strong>自动切割</strong>：</p><p>创建shell脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">ACCESS_LOG=/var/log/nginx/access.log</span><br><span class="line">NEW_ACCESS_LOG=/var/log/nginx/access-$(date -d yesterday +%Y%m%d).log</span><br><span class="line">[ -f $ACCESS_LOG ] || exit 1</span><br><span class="line">  mv $ACCESS_LOG $NEW_ACCESS_LOG</span><br><span class="line">  /sbin/nginx -s reopen</span><br></pre></td></tr></table></figure><p>添加定时任务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /bin/sh XXX.sh &amp;&gt; /dev/null   #每天晚上12点切割日志</span><br></pre></td></tr></table></figure><h1 id="Nginx缓存"><a href="#Nginx缓存" class="headerlink" title="Nginx缓存"></a>Nginx缓存</h1><p>Nginx的模块<code>ngx_http_proxy_module</code>自带缓存功能，Nginx可实现几种缓存：网页内容缓存，日志缓存，打开文件缓存，fastcgi缓存。Nginx的缓存功能主要由<code>proxy_chache</code>相关的命令集和<code>fastcgi_cache</code>相关命令集构成，前者用于反向代理，后者用于对FastCGI缓存。</p><p>需要下载第三方的Nginx模块<code>ngx_cache_purge</code>，用于清除指定的URL缓存，<a href="http://labs.frickle.com/nginx_ngx_cache_purge/" target="_blank" rel="noopener">下载地址</a></p><p>下载后解压，然后重新编译Nginx，通过<code>nginx -V</code>查看编译选项，复制过去然后加上解压后的模块目录（不是里面的.c文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure  </span><br><span class="line">........</span><br><span class="line">   --add-module=/root/ngx_cache_purge-2.3</span><br></pre></td></tr></table></figure><p>编译后能看到新的模块添加成功的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configuring additional modules</span><br><span class="line">adding module in /root/ngx_cache_purge-2.3</span><br><span class="line"> + ngx_http_cache_purge_module was configured</span><br></pre></td></tr></table></figure><p>然后<strong>只要<code>make</code>就行，不能<code>make install</code>，不然就是重新安装Nginx了</strong></p><p>最后还要替换nginx启动文件，在重新编译后，nginx的下载目录中有个<code>objs</code>目录，将里面的<code>nginx</code>启动脚本复制到<code>/usr/sbin/</code>下，替换原来的<code>nginx</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -f /usr/sbin/nginx </span><br><span class="line">cp /root/nginx-1.14.0/objs/nginx /usr/sbin/</span><br></pre></td></tr></table></figure><p>通过<code>nginx -V</code>查看，<code>--add-module=/root/ngx_cache_purge-2.3</code>已成功编译</p><p>Nginx自带的缓存相关指令有三个：</p><ul><li><code>proxy_cache_path</code>：配置缓存存放路径。常用格式：<code>proxy_cache_path path [levels=levels] keys_zone=name:size [max_size=size] [inactive=time];</code>。<ul><li><code>levels</code>：缓存目录级别以及缓存目录名的字符数，数字间用冒号分隔。最多可有三层目录，目录名最多两个字符。例：<code>levels=1:2:2</code>表示一共三层目录，第一层目录名1字符，第二和第三层目录名为2字符。</li><li><code>keys_zone</code>：缓存标识名和内存中缓存的最大空间。名字必须唯一。可在<code>keys_zone</code>的值后加上<code>:内存缓存空间</code>指定内存中的缓存空间大小</li><li><code>max_size</code>：磁盘中缓存目录的最大空间</li><li><code>inactive</code>：缓存的默认时长，到达指定时间却没被访问的缓存会被自动删除</li></ul></li><li><code>proxy_cache</code>：指定要使用的缓存方法，使用<code>proxy_cache_path</code>中<code>keys_zone</code>指定的名称。格式：<code>proxy_cache 缓存标识名;</code></li><li><code>proxy_cache_valid</code>：根据状态码指定缓存有效期。格式：<code>proxy_cache_valid 状态码（可指定多个，或直接指定any） 时间（支持m|h等时间单位）;</code></li></ul><p>在配置文件添加缓存配置。首先在http块下（server块外）添加缓存路径，路径可根据需要自定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proxy_temp_path   /data/ngxcache/proxy_temp_dir;</span><br><span class="line">proxy_cache_path  /data/ngxcache/proxy_cache_dir levels=1:2 keys_zone=cache_one:1000m max_size=1g;</span><br></pre></td></tr></table></figure><p>然后在server块中的location块添加其余的缓存配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    proxy_cache cache_one;</span><br><span class="line">    proxy_cache_valid  200 1h;      # 状态码为200的缓存1小时</span><br><span class="line">    proxy_cache_valid  404 1m;</span><br><span class="line">    proxy_cache_valid  any 5m;      # 剩余的所有状态都缓存5分钟</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当开启缓存后，Nginx会生成进程<code>cache_manager</code>对缓存进行管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx      1359   1356  0 11:23 ?        00:00:00 nginx: cache manager process</span><br><span class="line">nginx      1360   1356  0 11:23 ?        00:00:00 nginx: cache loader process</span><br></pre></td></tr></table></figure><p>可在<code>server</code>块中添加<code>add_header X-Cache $upstream_cache_status;</code>，该参数用于显示缓存状态返回值，一共有七种：</p><table><thead><tr><th>返回值</th><th>说明</th></tr></thead><tbody><tr><td>HIT</td><td>缓存</td></tr><tr><td>MISS</td><td>未命中，请求被传送到后端</td></tr><tr><td>EXPIRED</td><td>缓存已过期，请求被传到后端</td></tr><tr><td>UPDATING</td><td>正在更新缓存，将使用旧的应答</td></tr><tr><td>STALE</td><td>无法从后端服务器更新缓存时，返回了旧的缓存</td></tr><tr><td>BYPASS</td><td>缓存被绕过了</td></tr><tr><td>REVALIDATED</td><td>在启用proxy_cache_revalidate后，当缓存内容过期后时，Nginx通过一次If-Modified-Since的请求头去验证缓存内容是否过期，此时会返回该状态</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_header X-Cache &quot;$upstream_cache_status from $server_addr&quot;;</span><br></pre></td></tr></table></figure><p>完整的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">proxy_temp_path     /data/ngxcache/proxy_temp_dir;</span><br><span class="line">proxy_cache_path    /data/ngxcache/proxy_cache_dir levels=1:2 keys_zone=cache_one:1000m max_size=1g;</span><br><span class="line">upstream web &#123;</span><br><span class="line">  server 172.16.246.134;</span><br><span class="line">  server 172.16.246.135;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen       80;</span><br><span class="line">  server_name  web;</span><br><span class="line">  root         /usr/share/nginx/html;</span><br><span class="line">  add_header X-Cache &quot;$upstream_cache_status from $server_addr&quot;;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_cache cache_one;</span><br><span class="line">    proxy_cache_valid  200 1h;</span><br><span class="line">    proxy_pass http://web;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过浏览器访问<code>http://web</code>。如果是第一次访问，会发现状态是MISS</p><img src="/2018/05/02/Nginx笔记/5.png"><p>若再次访问，则状态会变为HIT。</p><img src="/2018/05/02/Nginx笔记/6.png"><p>并且可以看到缓存目录下已建立缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/data/ngxcache/proxy_cache_dir/</span><br><span class="line">├── 5</span><br><span class="line">│   └── a4</span><br><span class="line">│       └── 383e066904ed363cfafab47f9f53fa45</span><br><span class="line">└── 6</span><br><span class="line">    └── 01</span><br><span class="line">        └── abca5f5d9926bd7fbfc52390d3d35016</span><br></pre></td></tr></table></figure><h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><p>Nginx提供负载均衡模块<code>ngx_http_upstream_module</code>，且Nginx有四种典型的负载均衡配置方式。</p><table><thead><tr><th>配置方式</th><th>说明</th></tr></thead><tbody><tr><td>轮询</td><td>默认配置方式，每个请求按照时间顺序逐一分配到不同后端服务器</td></tr><tr><td>权重</td><td>利用weight指定轮询的权重比率，weight与访问比率成正比。用于后端服务器性能不均的情况</td></tr><tr><td>ip_hash</td><td>每个请求按访问IP的hash结果分配，使每个访客固定访问一个后端服务器，可解决Session问题</td></tr><tr><td>fair（第三方）</td><td>按后端服务器响应时间来分配请求，响应时间短的优先</td></tr><tr><td>url_hash（第三方）</td><td>按访问URL的哈希结果来分配请求，使每个URL固定访问一个后端服务器。适用于后端服务器做缓存的情况</td></tr><tr><td>一致性Hash（Tengine）</td><td>将每个服务器虚拟成N个节点，均匀分布在哈希环上，每次请求时会根据配置参数计算出一个Hash，在哈希环上查找离这个哈希值最近的虚拟节点，对应服务器作为该次请求的后端服务器。好处：若增加或减少了机器，对整个集群的影响会最小</td></tr></tbody></table><p>Nginx作负载均衡的优点：</p><ul><li>配置简单</li><li>成本低</li><li>支持Rewrite重写规则</li><li>有内置的健康检查功能</li><li>节省带宽：支持Gzip，可添加浏览器本地缓存的Header</li><li>稳定性高：高并发的情况下也基本不会宕机</li></ul><h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>实验环境：</p><ul><li>负载均衡器：172.16.246.133</li><li>后端服务器1：172.16.246.134</li><li>后端服务器2：172.16.246.135</li></ul><p>仅需在负载均衡服务器上配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name  sys1.example.com;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://sys1.example.com;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream sys1.example.com &#123;</span><br><span class="line">  server 172.16.246.134;</span><br><span class="line">  server 172.16.246.135;</span><br><span class="line">&#125;</span><br><span class="line"># 实际上，轮询也是有weight的，只是所有的server的weight都为默认的1。</span><br></pre></td></tr></table></figure><p>在本机上进行访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB1</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB1</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br></pre></td></tr></table></figure><h2 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h2><p>仍在负载均衡器上配置，仅修改upstream块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream sys1.example.com &#123;</span><br><span class="line">  server 172.16.246.134 weight=1 max_fails=1 fail_timeout=2;</span><br><span class="line">  server 172.16.246.135 weight=3 max_fails=2 fail_timeout=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>weight</td><td>权重</td></tr><tr><td>max_fails</td><td>允许请求失败次数，默认为1。当超过最大次数时，返回proxy_next_upstream指令定义的错误</td></tr><tr><td>fail_timeout</td><td>在经历max_fails次失败后，暂停服务的时间</td></tr><tr><td>backup</td><td>预备备份机器，当所有其他主机都down后，就会启用该主机</td></tr><tr><td>down</td><td>指定的server暂不参与负载均衡</td></tr></tbody></table><p>查看现象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl sys1.example.com       # 一共四次访问，访问web1和web2的比例正好为1:3</span><br><span class="line">WEB2</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB1</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br></pre></td></tr></table></figure><h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream sys1.example.com &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 172.16.246.134;</span><br><span class="line">  server 172.16.246.135;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br><span class="line">&gt; curl sys1.example.com</span><br><span class="line">WEB2</span><br></pre></td></tr></table></figure><p>每个IP地址绑定一个web服务器，可能会导致某些web服务器负载很大，有的很少，反而无法保证负载均衡。</p><h1 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h1><p>在模块<code>ngx_http_proxy_module</code>中与Nginx反向代理有关的指令：<code>proxy_pass</code>，用于设置后端服务器的地址，仅用于<code>location</code>块。可以设置代理服务器的协议和地址以及映射位置的可选URI。</p><p>实验环境：</p><ul><li>代理服务器：172.16.246.133</li><li>后端服务器1：172.16.246.134</li><li>后端服务器2：172.16.246.135</li></ul><p>只需要在代理服务器上配置即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name web1;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://172.16.246.134;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name web2;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://172.16.246.135;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在本机上配置hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">172.16.246.133  web1 web2</span><br></pre></td></tr></table></figure><p>确保代理服务器和后端服务器的端口都打开。然后在本机测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl web1</span><br><span class="line">WEB1</span><br><span class="line">&gt; curl web2</span><br><span class="line">WEB2</span><br></pre></td></tr></table></figure><p>如果代理的是动态内容服务器，要使用<code>fastcgi_pass</code>指令进行代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.php$ &#123;</span><br><span class="line">  fastcgi_pass http://phpserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充指令：</p><ul><li><p><strong><code>proxy_set_header</code></strong>：在将客户端请求转交给后端服务器前，更改请求头信息。默认只重新定义了两个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header Host       $proxy_host;</span><br><span class="line"># 最好使用$host变量，它的值等于“Host”请求头字段中的服务器名称，如果此字段不存在则等于主服务器名称</span><br><span class="line">proxy_set_header Host       $host;</span><br><span class="line"># 服务器名称可以与代理服务器的端口一起传递</span><br><span class="line">proxy_set_header Host       $host:$proxy_port;</span><br><span class="line"># 请求host为代理主机</span><br><span class="line">proxy_set_header Host       $proxy_host;</span><br><span class="line"># 添加客户端IP</span><br><span class="line">proxy_set_header X-Real-IP  $remote_addr;</span><br><span class="line">proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">proxy_set_header Connection close;</span><br></pre></td></tr></table></figure><p>若设置了<code>X-Real-IP</code>，且后端服务器是httpd，则可以修改httpd配置文件中的<code>LogFormat</code>，添加一个<code>%{X-Real-IP}i</code>。而若后端是Nginx，则不用修改了，因为Nginx的<code>log_format</code>中已默认配置了<code>$remote_addr</code>，即客户端IP。</p><p>如果启用了缓存，则标题字段为“If-Modified-Since”，“If-Unmodified-Since”，“If-None-Match”，“If-Match”，“Range”和“If-Range”来自原始请求不会传递给代理服务器。</p></li><li><p><strong><code>proxy_connect_timeout</code></strong>：配置Nginx与后端代理服务器尝试连接的超时时间，默认60s，且通常不会大于75秒。</p></li><li><p><strong><code>proxy_read_timeout</code></strong>：配置Nginx向后端服务器组发出read请求后，等待响应的超时时间。仅在<strong>两个连续的读操作之间</strong>设置超时，而不是整个响应。如果代理服务器在此时间内未传输任何内容，则关闭连接。默认为60秒。</p></li><li><p><strong><code>proxy_send_timeout</code></strong>：配置Nginx向后端服务器组发出write请求后，等待响应的超时时间。仅在<strong>两个连续的写操作之间</strong>设置超时，而不是整个请求。如果代理服务器在此时间内未收到任何内容，则关闭连接。默认为60秒。</p></li><li><p><strong><code>proxy_redirect</code></strong>：用于修改后端服务器返回的响应头中的Location和Refresh</p></li><li><p><strong><code>proxy_buffer_size</code></strong>：用于读取从代理服务器接收的响应的第一部分的缓冲区的大小，这部分通常包含一个小的响应头。默认情况下，缓冲区大小等于一个内存页面，默认为4K或8K。</p></li><li><p><strong><code>proxy_buffers</code></strong>：用于从代理服务器读取响应的缓冲区的数量(number)和大小(size)，用于单个连接。默认情况下，缓冲区大小等于一个内存页面。默认为4K或8K。语法：<code>proxy_buffers number size;</code></p></li><li><p><strong><code>proxy_temp_file_write_size</code></strong>：当启用从代理服务器到临时文件的响应缓冲时，限制一次写入临时文件的数据大小。默认情况下，size由<code>proxy_buffer_size</code>和<code>proxy_buffers</code>指令设置的两个缓冲区限制。默认为8k或16k。</p></li></ul><h1 id="Nginx邮件服务"><a href="#Nginx邮件服务" class="headerlink" title="Nginx邮件服务"></a>Nginx邮件服务</h1><h1 id="重写与重定向"><a href="#重写与重定向" class="headerlink" title="重写与重定向"></a>重写与重定向</h1><p>Nginx提供模块<code>ngx_http_rewrite_module</code>实现重写与重定向。<code>rewrite</code>指令能用于<code>server</code>、<code>location</code>、<code>if</code>块中。</p><p><code>rewrite regex replacement [flag];</code></p><p>其中regex为正则表达式，replacement为符合正则的替换算法。flag为进一步处理的标识。以下为flag的可选值：</p><table><thead><tr><th>参数值</th><th>说明</th></tr></thead><tbody><tr><td>last</td><td>终止rewrite，继续匹配</td></tr><tr><td>break</td><td>终止rewrite，不再继续匹配</td></tr><tr><td>redirect</td><td>临时重定向，返回的HTTP状态码为302</td></tr><tr><td>permanent</td><td>永久重定向，返回的HTTP状态码为301</td></tr></tbody></table><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>在server块中添加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># !-e判断请求指定的资源是否不存在，若不存在就执行if块中的指令。$request_filename表示当前请求的文件路径</span><br><span class="line">if (!-e $request_filename) &#123;</span><br><span class="line">  rewrite &quot;^/.*&quot; /40x.html break;</span><br><span class="line">  # 重写符合规则的请求地址。&quot;^/.*&quot;表示匹配当前网站下的所有请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试验：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; curl http://web/asdasd</span><br><span class="line">400 ERROR</span><br></pre></td></tr></table></figure><p>若使用last标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LNMP分布式集群方案"><a href="#LNMP分布式集群方案" class="headerlink" title="LNMP分布式集群方案"></a>LNMP分布式集群方案</h1><h2 id="搭建Nginx-PHP环境"><a href="#搭建Nginx-PHP环境" class="headerlink" title="搭建Nginx+PHP环境"></a>搭建Nginx+PHP环境</h2><p>编译安装PHP，php版本7.2.11。</p><p>确保<code>zlib</code>及其库<code>zlib-devel</code>，<code>gd</code>及其库<code>gd-devel</code>，<code>curl</code>及其库<code>libcurl</code>、<code>libcurl-devel</code>，<code>openssl</code>及其库<code>openssl-devel</code>，<code>libxml2</code>和<code>libxml2-devel</code>（php编译必须的依赖包），<code>libjpeg</code>及其库<code>libjpeg-devel</code>，<code>libpng</code>及其库<code>libpng-devel</code>，<code>freetype-devel</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">./configure   --prefix=/usr/local/php7.2 \</span><br><span class="line">   --enable-fpm \            # 开启PHP的FPM功能</span><br><span class="line">   --with-zlib \</span><br><span class="line">   --enable-zip \</span><br><span class="line">   --enable-mbstring \       # 用于多字节字符串处理</span><br><span class="line">   --with-mysqli \           # 增强版Mysql数据库访问支持</span><br><span class="line">   --with-pdo-mysql \        # 基于PDO（php data object）的MySQL数据库访问支持</span><br><span class="line">   --with-gd \               # gd库支持，用于php图像处理</span><br><span class="line">   --with-jpeg-dir \         # jpeg图像处理库</span><br><span class="line">   --with-png-dir \          # png图像处理库</span><br><span class="line">   --with-freetype-dir \     # freetype字体图像处理库</span><br><span class="line">   --with-curl \             # curl支持</span><br><span class="line">   --with-openssl \</span><br><span class="line">   --with-mhash \            # mhash加密支持</span><br><span class="line">   --enable-bcmath \         # 精确计算功能</span><br><span class="line">   --enable-opcache          # 开启opcache，一种php代码优化器</span><br><span class="line">   </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>安装完成后，php-fpm是无法通过<code>systemctl</code>管理的。需要以下配置</p><p>php配置文件目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/php7.2/etc/</span><br><span class="line">├── pear.conf</span><br><span class="line">├── php-fpm.conf.default</span><br><span class="line">└── php-fpm.d</span><br><span class="line">    └── www.conf.default</span><br></pre></td></tr></table></figure><p>需要将<code>php-fpm.conf.default</code>改名为<code>php-fpm.conf</code>。然后进入解压包的目录中<code>sapi/fpm</code>目录，里面有一个<code>php-fpm.service</code>，将该文件的权限改为<code>754</code>，然后复制到<code>/usr/lib/systemd/system/</code>中。</p><p>如果是CentOS/Redhat 6系列，则将<code>init.d.php-fpm</code>复制到<code>/etc/init.d/</code>中并改名为<code>php-fpm</code>，添加执行权限，然后<code>chkconfig --add php-fpm</code>。</p><p>查看<code>php-fpm.service</code>，确保PID文件、配置文件路径正确。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=The PHP FastCGI Process Manager</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">PIDFile=/usr/local/php7.2/var/run/php-fpm.pid</span><br><span class="line">ExecStart=/usr/local/php7.2/sbin/php-fpm --nodaemonize --fpm-config /usr/local/php7.2/etc/php-fpm.conf</span><br><span class="line">ExecReload=/bin/kill -USR2 $MAINPID</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>其中配置文件的路径为安装目录的<code>etc/php-fpm.conf</code>，所以该配置文件原来的<code>.default</code>文件一定要改名为<code>php-fpm.conf</code>。并且还需要将<code>php-fpm.d/</code>下的<code>www.conf.default</code>改名为<code>www.conf</code>，否则还会报错。</p><p><code>/usr/local/php7.2/sbin/php-fpm -t</code>检查配置文件是否正确。</p><p>再启动php-fpm，<code>systemctl start php-fpm.service</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep php-fpm</span><br><span class="line">root      47197      1  0 22:53 ?        00:00:00 php-fpm: master process (/usr/local/php7.2/etc/php-fpm.conf)</span><br><span class="line">nobody    47198  47197  0 22:53 ?        00:00:00 php-fpm: pool www</span><br><span class="line">nobody    47199  47197  0 22:53 ?        00:00:00 php-fpm: pool www</span><br><span class="line"></span><br><span class="line">ss -anpt | grep php-fpm</span><br><span class="line">LISTEN     0      128    127.0.0.1:9000                     *:*                   users:((&quot;php-fpm&quot;,pid=47199,fd=5),(&quot;php-fpm&quot;,pid=47198,fd=5),(&quot;php-fpm&quot;,pid=47197,fd=7))</span><br></pre></td></tr></table></figure><p>可以看出，php-fpm监听了9000端口，主进程用户为root，子进程用户为nobody。</p><p>可以将<code>bin</code>和<code>sbin</code>目录添加到环境变量中，将配置文件软连接到<code>/etc/php/</code>中，方便操作。</p><p>php-fpm主配置文件<code>php-fpm.conf</code>，该配置文件采用的是INI的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[global]          # 全局配置</span><br><span class="line">pid = run/php-fpm.pid       # pid文件路径</span><br><span class="line">error_log = log/php-fpm.log # 日志路径</span><br><span class="line">syslog.ident = php-fpm      # syslog标识名称</span><br><span class="line">log_level = notice          # 日志等级。alert, error, warning, notice, debug</span><br><span class="line">daemonize = yes             # 是否在后台运行</span><br><span class="line">events.mechanism = epoll    # 事件机制。</span><br><span class="line">include=/usr/local/php7.2/etc/php-fpm.d/*.conf  # 进程池配置存放目录</span><br><span class="line">; process.max = 128</span><br></pre></td></tr></table></figure><p>php-fpm进程池配置文件<code>www.conf</code>，采用的也是INI格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[www]              # 进程池配置</span><br><span class="line">user = nobody      # 工作用户</span><br><span class="line">group = nobody     # 工作组</span><br><span class="line">listen = 127.0.0.1:9000     # 监听IP地址与端口</span><br><span class="line">;listen.owner = nobody      # socket文件所属用户</span><br><span class="line">;listen.group = nobody      # socket文件所属组</span><br><span class="line">;listen.allowed_clients = 127.0.0.1   # 指定允许连接的客户端IP，默认为环回口</span><br><span class="line">pm = dynamic                # 控制子进程的数量，默认为dynamic（动态控制）</span><br><span class="line">pm.max_children = 5        # 最多子进程数</span><br><span class="line">pm.start_servers = 2       # 启动进程数，对应了php-fpm:pool www的个数</span><br><span class="line">pm.min_spare_servers = 1   # 最少空闲进程数，若少于该数，则会自动创建空闲进程</span><br><span class="line">pm.max_spare_servers = 3   # 最多空闲进程数，若多于该数，则会自动删除空闲进程</span><br><span class="line">access.log = log/$pool.access.log     # 日志文件，默认不记录日志</span><br><span class="line">;php_admin_value[memory_limit] = 32M  # 以php_admin_value的方式替换php.ini中memory_limit的值</span><br><span class="line">;php_flag[display_errors] = off    # 以php_flag的方式替换php.ini中display_errors的值</span><br></pre></td></tr></table></figure><p>在php的解压包中，有两个关于<code>php.ini</code>的配置文件：<code>php.ini-production</code>和<code>php.ini-development</code>，其中production适用于实际上线环境（安全性高），development适合于开发环境（便于调试）。选择其中一个复制到php安装目录下<code>lib/php/</code>中，并改名为<code>php.ini</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[PHP]            # PHP核心配置</span><br><span class="line">output_buffering = 4096             # 输出缓冲，单位字节</span><br><span class="line">;open_basedir =                     # 限制php脚本可访问的路径</span><br><span class="line">disable_functions =                 # 禁用的函数列表</span><br><span class="line">max_execution_time = 30             # 每个PHP脚本最长时间限制，单位秒</span><br><span class="line">memory_limit = 128M                 # 每个PHP脚本最大内存使用限制</span><br><span class="line">display_errors = On                 # 是否输出错误信息</span><br><span class="line">log_errors = On                     # 是否开启错误日志</span><br><span class="line">;error_log = php_errors.log         # 错误日志路径</span><br><span class="line">post_max_size = 8M                  # 通过POST提交的最大限制</span><br><span class="line">default_mimetype = &quot;text/html&quot;      # 默认MIME类型</span><br><span class="line">default_charset = &quot;UTF-8&quot;           # 默认编码</span><br><span class="line">file_uploads = On                   # 是否开启文件上传</span><br><span class="line">;upload_tmp_dir =                   # 上传文件临时保存目录</span><br><span class="line">upload_max_filesize = 2M            # 上传文件最大限制</span><br><span class="line">allow_url_fopen = On                # 是否允许打开远程文件</span><br><span class="line">;cgi.fix_pathinfo=1                 # 开启在CGI模式下自动识别PATHINFO</span><br><span class="line"># PATHINFO用于在某个脚本后添加自定义内容</span><br><span class="line"># 开启后，若要访问的资源不存在，则会执行上一级的文件，若上一级的文件仍不存在，则返回“File not found”</span><br><span class="line"># 若不开启，要访问的文件不存在，则直接返回错误“No input file specified”</span><br><span class="line"></span><br><span class="line">[Date]               # 时间与日期配置</span><br><span class="line">;date.timezone = Asia/Shanghai      # 时区         </span><br><span class="line"></span><br><span class="line">[Session]            # 会话配置</span><br><span class="line">session.save_handler = files        # 将会话以文件形式保存</span><br><span class="line">;session.save_path = &quot;/tmp&quot;         # 会话保存目录</span><br></pre></td></tr></table></figure><p>修改Nginx配置文件，取消以下行的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">  root           html;</span><br><span class="line">  fastcgi_pass   127.0.0.1:9000;         # 将动态请求交给该端口处理</span><br><span class="line">  fastcgi_index  index.php;</span><br><span class="line">  fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name; # 额外参数文件</span><br><span class="line">  include        fastcgi.conf;  # 包含了当前目录下的fastcgi_params配置</span><br><span class="line">  # 一定要设置为fastcgi.conf，不能设为fastcgi_params</span><br><span class="line">  # 因为.conf文件不_params文件多了一条</span><br><span class="line">  # fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;   </span><br><span class="line">  # 这是指定了脚本的路径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>/etc/nginx/fasstcgi_params</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 请求字符串（/xxx.php?xxx=xxxx&amp;xxx=xxxx）</span><br><span class="line">fastcgi_param  QUERY_STRING       $query_string;</span><br><span class="line"># 请求方法（get、post）</span><br><span class="line">fastcgi_param  REQUEST_METHOD     $request_method;</span><br><span class="line"># 内容的类型（即MIME类型）</span><br><span class="line">fastcgi_param  CONTENT_TYPE       $content_type;</span><br><span class="line"># 内容长度</span><br><span class="line">fastcgi_param  CONTENT_LENGTH     $content_length;</span><br><span class="line"># CGI脚本名</span><br><span class="line">fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;</span><br><span class="line"># 请求URI</span><br><span class="line">fastcgi_param  REQUEST_URI        $request_uri;</span><br><span class="line"># 文件URI</span><br><span class="line">fastcgi_param  DOCUMENT_URI       $document_uri;</span><br><span class="line"># 文件根目录</span><br><span class="line">fastcgi_param  DOCUMENT_ROOT      $document_root;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>在<code>index.php</code>中写入<code>&lt;? phpinfo(); ?&gt;</code>。刷新配置，浏览器访问。</p><img src="/2018/05/02/Nginx笔记/3.png"><h2 id="Nginx-Apache动静分离"><a href="#Nginx-Apache动静分离" class="headerlink" title="Nginx+Apache动静分离"></a>Nginx+Apache动静分离</h2><p>Nginx提供外部访问，静态请求直接由Nginx处理，动态请求转交给Apache处理，实现动静分离。</p><img src="/2018/05/02/Nginx笔记/4.png"><p>首先要确保Apache已支持PHP。确保Apache是<code>--enable-so</code>的，会在Apache的<code>bin/</code>下有一个<code>apxs</code>命令，是Apache的一个扩展工具（Apache extension tools），用于编译模块。php的configure可用apxs编译用于Apache访问PHP的模块。</p><p>使用<code>php -i | grep configure</code>查看php的编译参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configure Command =&gt;  &apos;./configure&apos;  &apos;--prefix=/usr/local/php7.2&apos; &apos;--enable-fpm&apos; &apos;--with-zlib&apos; &apos;--enable-zip&apos; &apos;--enable-mbstring&apos; &apos;--with-mcrypt&apos; &apos;--with-mysql&apos; &apos;--with-mysqli&apos; &apos;--with-pdo-mysql&apos; &apos;--with-gd&apos; &apos;--with-jpeg-dir&apos; &apos;--with-png-dir&apos; &apos;--with-freetype-dir&apos; &apos;--with-curl&apos; &apos;--with-openssl&apos; &apos;--with-mhash&apos; &apos;--enable-bcmath&apos; &apos;--enable-opcache&apos;</span><br></pre></td></tr></table></figure><p>重新整理并添加<code>--with-apxs2=/usr/local/httpd-2.4/bin/apxs</code>。</p><p><strong>注：</strong>如果此时直接编译仍然会报错，错误来自于<code>apxs</code>命令。报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure: /usr/local/httpd-2.4/bin/apxs: /replace/with/path/to/perl/interpreter: </span><br><span class="line">bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure><p>查看<code>apxs</code>命令。第一行是<code>#!/replace/with/path/to/perl/interpreter -w</code>肯定是不存在的，需要替换为<code>#!/usr/bin/perl -w</code>。重试<code>./configure</code>，然后<code>make</code>（不要<code>make install</code>）。</p><p>修改httpd的配置文件，以下为要修改的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Listen 81     # 防止与Nginx冲突，要修改端口号</span><br><span class="line"></span><br><span class="line"># 修改httpd虚拟主机</span><br><span class="line">&lt;VirtualHost *:81&gt;</span><br><span class="line">  Servername &quot;system3.example.com&quot;</span><br><span class="line">  DocumentRoot &quot;htdocs/php&quot;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>修改Nginx配置文件，将以下行取消注释并修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">  proxy_pass   http://127.0.0.1:81;     # 代理客户端浏览器请求Apache服务器</span><br><span class="line">  proxy_set_header Host $host;   # 发送Host消息头</span><br><span class="line">  # 因为Nginx在代理时能传递客户端的请求头，但无法传递Host消息头</span><br><span class="line">  # $host保存了请求的主机名（system3.example.com）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><a href="http://www.cnblogs.com/f-ck-need-u/p/7683027.html" target="_blank" rel="noopener">nginx基础及提供web服务(nginx.conf详解)</a></li><li><a href="http://www.ttlsa.com/linux/the-nginx-log-configuration/" target="_blank" rel="noopener">nginx日志配置</a></li><li>Nginx高性能Web服务器实战教程</li><li>高性能网站构建实战</li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> 集群 </tag>
            
            <tag> 代理 </tag>
            
            <tag> 负载均衡 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> Nginx </tag>
            
            <tag> LNMP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Apache-Server笔记</title>
      <link href="/2018/05/02/Apache-Server%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/02/Apache-Server%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<img src="/2018/05/02/Apache-Server笔记/0.png"><p>本片包含以下内容：</p><ul><li><a href="#Apache-httpd服务器介绍">Apache-httpd服务器介绍</a></li><li><a href="#httpd服务器安装">httpd服务器安装</a></li><li><a href="#httpd配置文件">httpd配置文件</a></li><li><a href="#httpd虚拟主机">httpd虚拟主机</a></li><li><a href="#httpd认证授权">httpd认证授权</a></li><li><a href="#页面重定向">页面重定向</a></li><li><a href="#.htaccess文件">.htaccess文件</a></li></ul><a id="more"></a><ul><li><a href="#CGI">CGI</a></li><li><a href="#动态httpd">动态httpd</a></li><li><a href="#httpd与SSL">httpd与SSL</a></li><li><a href="#httpd日志">httpd日志</a></li><li><a href="#httpd代理">httpd代理</a></li><li><a href="#Apache-MPM模式">Apache-MPM模式</a></li><li><a href="#Apache实用第三方模块">Apache实用第三方模块</a></li><li><a href="#Apache安全措施">Apache安全措施</a></li><li><a href="#LAMP环境搭建">LAMP环境搭建</a></li><li><a href="#LAMT环境搭建">LAMT环境搭建</a></li></ul><h1 id="Apache-httpd服务器介绍"><a href="#Apache-httpd服务器介绍" class="headerlink" title="Apache-httpd服务器介绍"></a>Apache-httpd服务器介绍</h1><p>Apache服务器全称Apache-HTTP-Server，而httpd就是Apache服务器端运行的软件，提供WWW服务器平台。</p><p><strong>Apache特性</strong></p><ul><li>简单强大的配置文件</li><li>支持虚拟主机</li><li>支持多种HTTP认证</li><li>集成Perl脚本，代理服务器模块</li><li>支持通用网关接口、FastCGI</li><li>支持实时监视服务器状态和定制服务器日志</li><li>支持SSL、服务器端包含指令SSI</li><li>可通过第三方模块支持Java Servlets</li><li>提供对用户会话的跟踪</li><li>采用模块化设计模型</li></ul><p><strong>Apache最重要的特性就是：采用模块化设计模型</strong>。模块分为：</p><ul><li>静态模块：是Apache最基本的模块，无法随时添加和卸载，在编译安装时设定</li><li>动态模块：是可以随时添加和卸载的模块，使得部署有最大的灵活性</li></ul><p>Apache的模块会被编译为动态共享对象DSO，这些DSO独立于httpd，可以在编译时就添加，也可以后期通过Apache Extension Tool工具编译添加模块，可使用<code>httpd -M</code>查看模块加载清单。</p><h1 id="httpd服务器安装"><a href="#httpd服务器安装" class="headerlink" title="httpd服务器安装"></a>httpd服务器安装</h1><p>httpd版本2.4.34。可以使用源码安装，可进行更精细的设定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">  --enable-so               # 开启模块化功能，支持DSO</span><br><span class="line">  --enable-mods-shared      # 指明以DSO方式编译的模块，all表示所有模块，most表示大部分模块</span><br><span class="line">  --enable-ssl              # 支持ssl加密</span><br><span class="line">  --enable-rewrite          # 支持地址重写</span><br><span class="line">  --with-mpm                # 设置httpd工作模式</span><br><span class="line">  --with-suexec-bin         # suexec库的路径，用于支持SUID、SGID</span><br><span class="line">  --with-apr                # 指定apr程序的绝对路径</span><br></pre></td></tr></table></figure><blockquote><p>apr：Apache Portable Runtime（APR）项目的任务是创建和维护软件库，为底层平台特定的实现提供可预测且一致的接口。主要目标是提供一个API，软件开发人员可以对其进行编码，并确保可预测的行为，如果不是相同的行为，无论他们的软件构建在哪个平台上，都可以减轻他们编写特殊情况条件以解决问题的需要。</p><p>源码安装前需要安装apr和apr-util，仍然需要源码安装</p></blockquote><p>下载apr和apr-util的源码包，先安装apr，先要确保安装了<code>gcc</code></p><p><code>./configure --prefix=/usr/local/apr-1.6</code>然后<code>make &amp;&amp; make install</code></p><p>再安装apr-util，需要<code>--with-apr</code>指定apr的安装路径</p><p><code>./configure --prefix=/usr/local/apr-util-1.6 --with-apr=/usr/local/apr-1.6</code>然后<code>make &amp;&amp; make install</code></p><p>可能会报一个错<code>xml/apr_xml.c:35:19: 致命错误：expat.h：No such file or directory</code>，需要安装<code>expat-devel</code>，<code>yum install expat expat-devel</code>即可。</p><p>安装与Apache相关的依赖库或软件，直接<code>yum|dnf</code>安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pcre-devel          # perl正则表达式库</span><br><span class="line">libxml2-devel       # xml文件库，很重要</span><br><span class="line">libpng-devel        # png图像库</span><br><span class="line">libjpeg-devel       # jpeg图像库</span><br><span class="line">libmcrypt-devel     # mcrypt加密库</span><br><span class="line">zlib-devel          # zlib压缩库</span><br><span class="line">freetype-devel      # freetype字体库</span><br><span class="line">autoconf            # 生成配置脚本的软件，不一定要</span><br><span class="line">gd-devel            # gd图像库</span><br><span class="line">libcurl-devel       # curl库</span><br><span class="line">openssl-devel       # openssl库。注：php5不支持openssl1.1.0版本以上的</span><br></pre></td></tr></table></figure><p>然后</p><figure class="highlight plain"><figcaption><span>--prefix</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/httpd-2.4 \</span><br><span class="line">            --with-apr=/usr/local/apr-1.6 \</span><br><span class="line">            --with-apr-util=/usr/local/apr-util-1.6</span><br><span class="line">  # 若不指定--prefix，会默认安装在/usr/local/apache2中</span><br></pre></td></tr></table></figure><p>并<code>make &amp;&amp; make install</code>即可。源码安装后可能不能直接使用Apache的管理命令，需要添加环境变量，<code>export PATH=/usr/local/httpd-2.4/bin:$PATH</code>，也可以永久添加。</p><p>httpd提供两种编译方式：静态编译和动态编译</p><ul><li>静态编译：把模块直接编译进httpd核心，httpd启动时所有静态编译的模块都会启动</li><li>动态编译：将模块编译好，但不编译进httpd核心，httpd启动动态模块并不会启动，而是需要在配置文件中<code>LoadModule</code>加载才能启动，实现了模块热插拔。</li></ul><p>可在编译时指定<code>--enable-模块名=shared|static</code>指定模块是动态或静态编译。</p><blockquote><p>httpd能够实现动态编译的原因在于httpd默认会安装<code>mod_so</code>，此模块提供了配置文件的<code>LoadModule</code>和<code>LoadFile</code>指令，在编译时指定<code>--enable-so</code>即可，而此模块只能使用静态编译，若指定为<code>shared</code>则编译时会出错。</p></blockquote><p>动静态编译的优先级：</p><ol><li>不指定模块编译选项，则默认值为<code>--enable-mods-shared=most</code>即动态编译大部分模块</li><li>显式指定的优先级高，如果某个模块既指定了静态，又指定了动态，则静态优先。</li><li>静态关键字规则优先于动态关键字规则，即若<code>--enable-mods-static=few</code>和<code>--enable-mod-shared=all</code>同时配置，静态优于动态，静态生效。</li></ol><p>也可通过各种源安装。<code>yum|dnf install httpd</code>。安装完成后，Apache会提供<code>apachectl</code>脚本命令，可进行httpd的启动、关闭和测试，若没有修改配置文件下使用<code>start</code>启动httpd，会报以下错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not reliably determine the server&apos;s fully qualified domain name</span><br></pre></td></tr></table></figure><p>报错说明httpd无法确定服务器域的名称，可通过修改主配置文件的<code>ServerName</code>解决。修改后再通过<code>apachectl starts</code>启动httpd，再直接打命令<code>apachectl</code>能看到httpd已在运行的消息<code>httpd (pid 2012) already running</code>。也可以通过<code>systemctl start httpd</code>启动httpd。</p><p>若开启了<code>firewalld</code>服务，需要放行<code>80/tcp</code>端口，放行<code>http</code>服务。</p><p>httpd的主要目录（yum源安装）：</p><ul><li><code>/etc/httpd</code>：httpd服务根目录</li><li><code>/etc/httpd/conf</code>和<code>/etc/httpd/conf.d</code>：httpd服务配置文件目录</li><li><code>/var/www/html</code>：网站数据目录</li><li><code>/var/log/httpd</code>：httpd日志目录，里面存放有<code>access_log</code>访问日志和<code>error_log</code>错误日志</li></ul><p>若是通过yum源安装的httpd，则在<code>/etc/httpd</code>中的<code>logs</code>，<code>modules</code>和<code>run</code>目录都是软连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/httpd/logs --&gt; /var/log/httpd</span><br><span class="line">/etc/httpd/modules --&gt; /usr/lib64/httpd/modules</span><br><span class="line">/etc/httpd/run --&gt; /run/httpd</span><br></pre></td></tr></table></figure><p><code>apachectl</code>命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apachectl</span><br><span class="line">  -V           # 查看apache版本信息，以及模块、编译信息</span><br><span class="line">  -l           # 查看已被编译的模块</span><br><span class="line">  start        # 启动httpd，如果已在运行就会返回错误</span><br><span class="line">  stop         # 停止httpd</span><br><span class="line">  restart      # 重启httpd</span><br><span class="line">  fullstatus   # 显示mod_status的完整状态报告。需要在服务器上启用mod_status，并在系统上使用基于文本的浏览器</span><br><span class="line">  status       # 显示简要状态报告，信息与systemctl status httpd一致</span><br><span class="line">  graceful     # 优雅地重启Apache httpd守护进程。如果守护程序未运行，则启动它。这与正常重启不同，因为当前打开的连接不会中止。副作用是旧的日志文件不会立即关闭。这意味着，如果在日志轮换脚本中使用，则可能需要大量延迟才能确保在处理旧日志文件之前将其关闭。</span><br><span class="line">  graceful-stop # 让已运行的httpd进程不再接受新请求，并给他们足够的时间处理当前正在处理的事情，处理完成后才退出。所以在进程退出前，日志文件暂时不会关闭，正在进行的连接暂时不会断开。</span><br><span class="line">  configtest   # 配置文件语法测试，相当于apachectl -t</span><br></pre></td></tr></table></figure><p><code>httpd</code>命令：与<code>apachectl</code>一致</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">httpd                # 可直接启动httpd</span><br><span class="line">  -D name            # 定义一个在&lt; IfDefine name &gt;中使用的name，以此容器中的指令</span><br><span class="line">  -d directory       # 指定ServerRoot</span><br><span class="line">  -f file            # 指定配置文件</span><br><span class="line">  -C &quot;directive&quot;     # 指定在加载配置文件前要处理的指令(directive)</span><br><span class="line">  -c &quot;directive&quot;     # 指定在加载配置文件后要处理的指令</span><br><span class="line">  -e level           # 显示httpd启动时的日志调试级别</span><br><span class="line">  -E file            # 将启动信息记录到指定文件中</span><br><span class="line">  -v                 # 显示版本号</span><br><span class="line">  -V                 # 显示编译配置选项</span><br><span class="line">  -h                 # 显示帮助信息</span><br><span class="line">  -l                 # 显示已编译但非动态编译的模块，即静态编译的模块</span><br><span class="line">  -L                 # 显示静态模块可用的指令列表</span><br><span class="line">  -t -D DUMP_VHOSTS  # 显示虚拟主机的设置信息</span><br><span class="line">  -t -D DUMP_RUN_CFG # 显示运行参数</span><br><span class="line">  -S                 # 等价于-t -D DUMP_VHOSTS -D DUMP_RUN_CFG。在调试如何解析配置文件时非常有用</span><br><span class="line">  -t -D DUMP_MODULES # 显示所有已被加载的模块，包括静态和动态编译的模块</span><br><span class="line">  -M                 # 等价于-t -D DUMP_MODULES</span><br><span class="line">  -t                 # 检查配置文件语法</span><br><span class="line">  -T                 # 不检查DocumentRoot，直接启动</span><br><span class="line">  -X                 # 调试模式，此模式下httpd进程依赖于终端</span><br><span class="line">  -k                 # 管理httpd进程，接受start|restart|graceful|graceful-stop|stop</span><br></pre></td></tr></table></figure><h1 id="httpd配置文件"><a href="#httpd配置文件" class="headerlink" title="httpd配置文件"></a>httpd配置文件</h1><p>httpd主配置文件主要由指令和容器构成，容器使用<code>&lt;容器名&gt;&lt;/容器名&gt;</code>作为开始和结束，容器的指令一般只在容器内生效，每个指令都是某个模块提供的，指令生效方式是从上往下读取，所以不要变更指令位置。</p><p><strong>主配置文件重点指令</strong>：</p><ul><li><code>ServerRoot</code>：设置Apache的安装主目录，若采用源码安装，默认路径为<code>/usr/local/apache2</code></li><li><code>Listen</code>：设置服务器监听端口IP及端口号，默认监听服务器本机所有IP地址的80端口。格式：<code>Listen [IP地址:]端口 [协议]</code>，默认监听所有IP，使用TCP协议。可多次使用Listen以开启多个端口</li><li><code>LoadModule</code>：加载模块。格式 <code>LoadModule 模块名 模块文件名</code>，模块文件一般存放在ServerRoot的module目录中</li><li><code>ServerAdmin</code>：主服务器返回给客户端的错误消息中的管理员邮箱地址</li><li><code>ServerName</code>：设置服务器本机的主机名和端口，用于URL重定向</li><li><code>User</code>：apache在本地系统上运行的用户名</li><li><code>Group</code>：apache在本地系统上运行的组名</li><li><code>DocumentRoot</code>：网络路径相对路径的根，是文档的根目录，使用rpm包安装则默认值为<code>/var/www</code>，使用源码安装则默认为<code>$ServerRoot/htdocs</code></li><li><code>ErrorLog</code>：服务器错误日志存放位置，默认使用相对路径<code>logs/error_log</code></li><li><code>ErrorLogFormat</code>：错误日志格式</li><li><code>CustomLog</code>：客户端访问日志文件路径及日志格式，格式：<code>CustomLog 文件名 格式</code>，默认相对路径为<code>logs/access_log</code></li><li><code>LogFormat</code>：用户日志文件格式，一般用这里指定的格式创建别名，然后通过<code>CustomLog</code>调用该格式</li><li><code>LogLevel</code>：日志消息等级，分为<code>debug/info/notice/warm/error/crit/alert/emerg</code></li><li><code>AllowOverride</code>：支持从<code>.htaccess</code>文件中重写前面的指令，若值为<code>None</code>，表示不支持</li><li><code>Require</code>：给所有用户或特定用户/组授予或拒绝对目录的访问</li><li><code>Include</code>：允许Apache在主配置目录加载其他配置文件，默认为<code>conf.d/*.conf</code></li><li><code>Options</code>：为特殊目录设置选项，语法格式为<code>Options [+|-]选项</code>。<ul><li><code>All</code>：开启除<code>MultiViews</code>之外的所有选项</li><li><code>None</code>：不启用额外功能</li><li><code>FollowSymlinks</code>：允许Options指定目录下的文件链接到目录外的文件或目录</li><li><code>Indexes</code>：若与URL对应的Options目录下找不到<code>DirectoryIndex</code>指定的首页文件，则会将当前目录的所有文件索引出来</li></ul></li><li><code>Order</code>：控制默认访问状态以及<code>Allow</code>和<code>Deny</code>的顺序<ul><li>若为<code>Order deny,allow</code>则先检查拒绝，当拒绝与允许冲突时，<code>allow</code>优先，默认规则<code>allow</code>，即只要是<code>deny</code>排在前面，就只要写拒绝的IP地址即可，使用<code>Deny from [IP地址]|all</code></li><li>若为<code>Order allow,deny</code>则先检查允许，当拒绝与允许冲突时，<code>deny</code>优先，默认规则<code>deny</code>，即只要是<code>allow</code>排在前面，就只要写拒绝的IP地址即可，使用<code>Allow from [IP地址]|all</code></li></ul></li><li><code>Alias</code>：用于将URL路径映射到本地文件系统的路径，且本地路径不受DocumentRoot的限制，该目录中的脚本不允许执行。格式：<code>Alias URL路径 &quot;本地资源的文件系统路径&quot;</code>。<code>Alias</code>不支持正则，而<code>AliasMatch</code>支持，格式一致。</li><li><code>ScriptAlias</code>：类似于Alias，并且能将Web路径映射到DocumentRoot之外的文件系统位置，还告诉Apache指定的目录存在CGI脚本，可以执行脚本</li><li><code>DirectoryIndex</code>：作为索引的文件名，默认找<code>index.html</code>。若url中未指定网页文件，则会返回该目录下<code>DirectoryIndex</code>定义的文件，可指定多个文件，若都不存在，会生成所有文件列表，此时<code>Option Indexes</code>必须打开。</li><li><code>UserDir</code>：定义和本地用户的主目录相对的目录，可将公共的html文件放入该目录，即每个用户的个人站点。默认设置为<code>public_html</code>，每个用户都可在自己的主目录下创建名为<code>public_html</code>的目录，该目录下的html文件可通过<code>域名/~用户名</code>访问。若值为<code>disabled</code>表示禁止使用个人站点。</li><li><code>Timeout</code>：客户端与服务器连接的超时间隔</li><li><code>KeepAlive</code>：开启长连接。HTTP/1.1中支持一次连接多次传输，可在一次连接中传递多个HTTP请求</li><li><code>KeepAliveTimeout</code>：一次连接中多次请求间的超时间隔</li><li><code>MaxKeepAliveRequests</code>：一个HTTP连接中最多可请求的次数，若为0，表示无限制</li></ul><blockquote><p><a href="https://httpd.apache.org/docs/2.4/mod/quickreference.html" target="_blank" rel="noopener">指令文档</a></p></blockquote><p><strong>常用容器：</strong></p><ul><li><p><code>IfDefine</code>：使管理员能采用多种配置方式启动Apache，当启动httpd时使用命令<code>httpd -D 自定义名</code>便会匹配，若测试条件为真，就会加载该容器中定义的参数。格式：<code>&lt;IfDefine [!]自定义名&gt;</code></p></li><li><p><code>IfModule</code>：可以封装仅在条件满足时才会处理的命令，根据模块是否加载决定条件是否满足。语法：<code>&lt;IfModule [!] 模块&gt;指令&lt;/IfModule&gt;</code></p></li><li><p><code>Directory</code>：仅用于特定的文件系统目录、子目录及目录下内容，通常<strong>用绝对路径</strong>，即使是相对路径，也是相对于文件系统的根目录。语法：<code>&lt;Directory 路径&gt;指令&lt;/Directory&gt;</code>，路径可使用<code>~</code>匹配正则表达式。</p></li><li><p><code>DirectoryMatch</code>：类似Directory，可直接用正则表达式匹配</p></li><li><p><code>Files</code>：类似Directory，但Files内指令仅能应用与特定文件，匹配的范围是<strong>它所在的上下文</strong>。语法：<code>&lt;Files 文件名&gt;指令&lt;/Files&gt;</code>，可使用<code>~</code>匹配正则表达式</p></li><li><p><code>FilesMatch</code>：与Files类似，可直接用正则表达式匹配</p></li><li><p><code>Location</code>：该容器内的指令仅对特定URL有效。格式<code>&lt;Location URL&gt;指令&lt;/Location&gt;</code>，可使用<code>~</code>匹配正则表达式。<code>Location</code>支持三种匹配模式：</p><ul><li>精确匹配：精确到资源的URL路径</li><li>加尾随斜线：匹配目录内容，如<code>&lt;Location &quot;/myapp/&quot;&gt;</code></li><li>无尾随斜线：匹配目录和目录内容，如<code>&lt;Location &quot;/myapp&quot;&gt;</code></li></ul></li><li><p><code>LocationMatch</code>：类似Location，可直接用正则表达式匹配</p></li><li><blockquote><p>在DirectoryMatch，Files，FilesMatch，Location，LocationMatch中，若出现包含关系，如一个目录同时匹配到了两个相同类型容器，则会选择匹配先定义的容器</p></blockquote></li><li><p><code>VirtualHost</code>：虚拟主机，可直接用正则表达式匹配。语法：<code>VirtualHost IP地址:[端口号]</code>，IP地址为监听的本地网卡IP，若为<code>*</code>则表示监听本地所有网卡</p></li><li><code>EnableSendfile</code>：使用sendfile系统调用，把静态文件发送给客户端，获得更好的性能</li></ul><h1 id="httpd虚拟主机"><a href="#httpd虚拟主机" class="headerlink" title="httpd虚拟主机"></a>httpd虚拟主机</h1><p>基于IP的虚拟主机可根据不同IP地址及端口号定位不同的网站请求，但需要独立的公网IP地址。基于域名的虚拟主机能实现在一台公网服务器上部署多个网站，服务器根据客户端访问HTTP头部信息实现网站的分离解析。</p><p>客户端请求到达后，服务器根据<code>&lt;VirtualHost IP地址:[端口号]&gt;</code>匹配主机，若IP地址 为<code>*</code>，表示匹配本地所有IP地址</p><p>匹配顺序：</p><ul><li>匹配虚拟主机。匹配虚拟主机的规则为最佳匹配法，IP地址越精确，匹配就越优先。</li><li>如果基于名称的虚拟主机无法匹配上，则采用虚拟主机列表中的第一个虚拟主机作为响应主机。</li><li>如果所有虚拟主机都无法匹配上，则采用从主配置段落中的主机。</li></ul><p>首先配置虚拟主机配置文件，将<code>/usr/share/doc/httpd/httpd-vhosts.conf</code>复制到<code>/etc/httpd/conf.d/</code>目录下，可改名，以此为模板，创建一台虚拟主机。配置完成后重启httpd。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    DocumentRoot &quot;/var/www/virhost1&quot;</span><br><span class="line">    ServerName virhost1.example.com</span><br><span class="line">    ErrorLog &quot;/var/log/httpd/virhost1-error_log&quot;</span><br><span class="line">    CustomLog &quot;/var/log/httpd/virhost1-access_log&quot; common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">&lt;Directory &quot;/var/www/virhost1&quot;&gt;</span><br><span class="line">    Require all granted</span><br><span class="line">    Options Indexes</span><br><span class="line">    AllowOverride None</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>注：在实验机上，需要将该地址解析出来，所以要修改<code>/etc/hosts</code>，在环回口后添加<code>virhost1.example.com</code>，再访问即可。</p><p><strong>注：物理站点与虚拟站点不能同时存在，如果启动虚拟站点，物理站点立刻失效。若要让之前的物理站点恢复访问，就将该站点按虚拟站点的格式重新搭建</strong></p><h1 id="httpd认证授权"><a href="#httpd认证授权" class="headerlink" title="httpd认证授权"></a>httpd认证授权</h1><p>httpd提供各种认证模块，名称以<code>mod_auth</code>开头。基础的http认证模块为<code>mod_auth_basic</code>。</p><p>可以通过命令<code>htpasswd</code>生成用于网页认证的用户信息文件，该命令在<code>httpd-tools</code>包中，支持3种加密算法：MD5、SHA和系统上的crypt()函数，默认为md5。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">htpasswd [-cimBdpsDv] [-C cost] passwordfile username</span><br><span class="line">htpasswd -b[cmBdpsDv] [-C cost] passwordfile username password</span><br><span class="line"></span><br><span class="line"> -c  创建一个新密码文件</span><br><span class="line"> -n  不会更新密码文件，仅仅在输出显示，因此不用指定密码文件。而若不指定此项就必须指定密码文件，不能与-c一起用</span><br><span class="line"> -b  在命令行中读取密码，若不指定，系统会提示输入</span><br><span class="line"> -i  从输入读取密码（类似echo XXX | htpasswd -i），常用于脚本</span><br><span class="line"> -m  使用md5加密（默认）</span><br><span class="line"> -B  使用bcrypt函数加密，很安全</span><br><span class="line"> -C  使用bcrypt函数加密的次数，默认为5，范围是4到31，次数越多越安全，但会更慢</span><br><span class="line"> -d  使用crypt函数加密，不安全</span><br><span class="line"> -s  使用SHA加密密码，不安全</span><br><span class="line"> -p  不加密密码，不安全</span><br><span class="line"> -D  删除指定认证用户</span><br></pre></td></tr></table></figure><p>主配置文件的认证指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AuthType       指定web身份认证的类型，有四种类型：</span><br><span class="line">    none      不认证</span><br><span class="line">    basic     文件认证（默认），需要mod_auth_basic模块</span><br><span class="line">    digest    md5摘要认证，需要mod_auth_digest模块</span><br><span class="line">    form      表单认证，需要mod_auth_form模块</span><br><span class="line">AuthName       设置身份认证时的提示信息</span><br><span class="line">AuthUserFile   指定web用户认证列表，即htpasswd命令生成的密码文件</span><br><span class="line">AuthGroupFile  指定组认证文件，文件中分组格式为&quot;组名: 组成员....&quot;</span><br></pre></td></tr></table></figure><p><strong><code>Require</code>指令</strong>：只能放在<code>Directory</code>容器中，用于控制对目录的访问权限，功能由<code>mod_authz_core</code>模块提供。有以下配置：</p><ul><li><p><code>Require all granted | denied</code>：允许|拒绝所有人访问该目录</p></li><li><p><code>Require method http方法 ...</code>：只有指定的http方法（如get,post）才能访问该目录</p></li><li><p><code>Require expr 正则表达式</code>：只要满足指定正则表达式才能访问</p></li><li><p><code>Require user 用户...</code>：只有指定用户能访问</p></li><li><p><code>Require valid-user 用户...</code>：认证列表中所有用户都可访问</p><blockquote><p>关于用户的认证需要<code>mod_authz_user</code>模块</p></blockquote></li><li><p><code>Require group 组...</code>：指定组内的用户才能访问</p></li><li><p><code>Require file-owner</code>：web用户名必须与请求文件的UID对应用户名一致才能访问</p></li><li><p><code>Require file-group</code>：web用户名必须为请求文件的gid组中的一员才能访问</p><blockquote><p>组认证需要<code>mod_authz_groupfile</code>模块</p></blockquote></li><li><p><code>Require ip IP地址[/Mask]...</code>：指定IP能访问该目录</p></li><li><p><code>Require host 域名...</code>：指定域名能访问该目录</p><blockquote><p>关于ip和host的认证需要<code>mod_authz_host</code>模块</p></blockquote></li><li><p>若<code>Require</code>后加上<code>not</code>则是取反。</p></li></ul><p><strong>认证实验：</strong></p><p>首先创建密码认证文件：<code>htpasswd -cb /etc/httpd/secret mike 123456</code>，认证用户并不需要在系统中存在。</p><p>配置文件中的认证配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/www/virhost1&quot;&gt;</span><br><span class="line">    Options Indexes</span><br><span class="line">    AllowOverride None</span><br><span class="line">    #若通过.htaccess文件配置了以下认证信息，则需要将AllowOverride的值设为AuthConig</span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthName &quot;Enter Auth Username and Password:&quot;</span><br><span class="line">    AuthUserFile /etc/httpd/secret</span><br><span class="line">    Require user mike</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>重启httpd，通过浏览器访问，会提示输入用户名密码。</p><img src="/2018/05/02/Apache-Server笔记/4.png"><p>创建组认证文件<code>echo &quot;group1: mike&quot; &gt; /etc/httpd/auth_group</code>，修改配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory &quot;/var/www/virhost1&quot;&gt;</span><br><span class="line">    Options Indexes</span><br><span class="line">    AllowOverride None</span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthName &quot;Enter Auth Username and Password:&quot;</span><br><span class="line">    AuthUserFile /etc/httpd/secret</span><br><span class="line">    AuthGroupFile /etc/httpd/auth_group</span><br><span class="line">    Require user mike</span><br><span class="line">    Require group group1</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><h1 id="htaccess文件"><a href="#htaccess文件" class="headerlink" title=".htaccess文件"></a>.htaccess文件</h1><p><code>.htaccess</code>文件提供了一种基于每个目录进行配置更改的方法，该文件包含一个或多个配置，而该文件存放在某个<code>Directory</code>下，则该文件中的配置都应用于这个<code>Directory</code>。</p><p>如果有权限访问httpd主服务器配置文件，则应该完全避免使用<code>.htaccess</code>文件，使用<code>.htaccess</code>文件会降低Apache http服务器的速度。</p><p>如果想给<code>.htaccess</code>文件改名，则需要在配置文件中用指令<code>AccessFileName &quot;文件名&quot;</code>说明。</p><p>是否启用<code>.htaccess</code>文件取决于<code>AllowOverride</code>指令，该指令决定是否启用文件中定义的指令。</p><p>通常，只有在无法访问主服务器配置文件时才应使用.htaccess文件。.htaccess文件主要面向于没有root访问权限而无法改动主配置文件的用户，允许他们通过配置各自网站的.htaccess文件自行进行配置修改。</p><p>应该避免使用<code>.htaccess</code>文件的两点原因：</p><ul><li><p>当AllowOverride设置为允许使用.htaccess文件时，httpd将在每个目录中查找.htaccess文件。因此，允许.htaccess文件会导致性能下降，且每次请求文档时都会加载.htaccess文件。</p><p>httpd必须在所有更高级别的目录中查找.htaccess文件，以便拥有必须应用的完整指令。 例如，如果从目录<code>/www/htdocs/example</code>中请求文件，httpd必须查找以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/.htaccess</span><br><span class="line">/www/.htaccess</span><br><span class="line">/www/htdocs/.htaccess</span><br><span class="line">/www/htdocs/example/.htaccess</span><br></pre></td></tr></table></figure><p>这样会查找四个文件，即使不存在。</p><p>若指定重定向的指令，则在.htaccess上下文中，必须重新编译每个对目录的请求的正则表达式</p></li><li><p>允许用户修改服务器配置可能导致无法控制的更改，必须对用户的权限进行精细的控制，准确地设置AllowOverride的内容。</p></li></ul><p>由于会从最上级目录迭代向下查找.htaccess文件，所以，若不同的.htaccess文件中有相同指令，则最下层的.htaccess文件中的该指令生效，下层的文件中的指令会覆盖上层文件中相同的指令。</p><h2 id="htaccess文件的常用示例"><a href="#htaccess文件的常用示例" class="headerlink" title=".htaccess文件的常用示例"></a>.htaccess文件的常用示例</h2><p><strong>认证（Authentication）</strong>：需要在<code>&lt;Directory&gt;</code>中配置<code>AllowOverride AuthConfig</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AuthType Basic</span><br><span class="line">AuthName &quot;Password Required&quot;</span><br><span class="line">AuthUserFile &quot;/www/passwords/password.file&quot;</span><br><span class="line">AuthGroupFile &quot;/www/passwords/group.file&quot;</span><br><span class="line">Require group admins</span><br></pre></td></tr></table></figure><p><strong>服务器端包括（Server Side Includes，SSI）</strong>：提供了向现有HTML文档添加动态内容的方法，而无需通过CGI程序或其他动态技术。 SSI适用于在大部分内容都是静态的网页中添加小块动态信息，例如当前时间。若网页大部分内容都是动态生成的，则并不适用。</p><p><strong>若要使能SSI，则需要在配置文件中或.htaccess文件中添加<code>Options +Includes</code></strong>，表示允许为SSI指令解析文件。</p><p>还需要告诉Apache需要解析的文件，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType text/html .shtml</span><br><span class="line">AddOutputFilter INCLUDES .shtml</span><br></pre></td></tr></table></figure><p>缺点：如果想将SSI指令添加到现有页面，则必须更改该页面的名称以及该页面的所有链接。</p><p><strong>重写规则（Rewrite Rules）</strong>：在.htaccess文件中使用RewriteRule时，每个目录的上下文会稍微改变一下，规则被认为是相对于当前目录，而不是原始请求的URI。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在根目录中的.htaccess文件</span><br><span class="line">RewriteRule &quot;^images/(.+)\.jpg&quot; &quot;images/$1.png&quot;</span><br><span class="line"></span><br><span class="line">在images中的.htaccess文件</span><br><span class="line">RewriteRule &quot;^(.+)\.jpg&quot; &quot;$1.png&quot;</span><br></pre></td></tr></table></figure><p><strong>CGI配置</strong>：允许指定目录中的CGI程序运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Options +ExecCGI</span><br><span class="line">AddHandler cgi-script cgi pl</span><br><span class="line">若要将目录中的所有文件都看做CGI程序，则将AddHandler替换为</span><br><span class="line">SetHandler cgi-script</span><br></pre></td></tr></table></figure><h1 id="页面重定向"><a href="#页面重定向" class="headerlink" title="页面重定向"></a>页面重定向</h1><h1 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h1><p>CGI（common gateway interface，通用网关接口）是Web 服务器运行时外部程序的规范，按CGI 编写的程序<strong>可以扩展服务器功能</strong>，处理动态内容。CGI 应用程序<strong>能与浏览器进行交互</strong>，还可<strong>通过数据库API与数据库服务器等外部数据源进行通信</strong>,从数据库服务器中获取数据。对于HTTP，只有get和post方法允许执行cgi脚本。</p><img src="/2018/05/02/Apache-Server笔记/9.png"><p>常见的CGI术语：</p><ul><li><strong>fastcgi</strong>：是cgi协议的优化版本</li><li><strong>php-cgi</strong>：php-cgi实现了fastcgi，但性能不佳，单进程处理请求。</li><li><strong>php-fpm</strong>：全称：php-fastcgi process manager，是php-cgi的改进版，管理多个php-cgi的进程及线程</li><li><strong>cgi进程或线程</strong>：用于接收web服务器的动态请求，调用并初始化zend虚拟机</li><li><strong>zend虚拟机</strong>：对php文件的语法分析、编译并执行，执行完成后关闭</li></ul><img src="/2018/05/02/Apache-Server笔记/10.png"><p>CGI的三种交互模式：</p><ul><li>cgi模式：httpd每收到一个动态请求就fork一个cgi进程，该进程返回结果后就自动销毁</li><li>动态模块模式：将php-cgi模块编译进httpd</li><li>php-fpm模式：使用php-fpm管理php-cgi，httpd不再控制php-cgi进程的启动，可将php-fpm独立运行在其他非web服务器上，实现动静分离</li></ul><h1 id="动态httpd"><a href="#动态httpd" class="headerlink" title="动态httpd"></a>动态httpd</h1><p>安装Apache后，会在存放网页的目录中生成一个目录<code>cgi-bin</code>，关于CGI的配置在主配置文件中。</p><p>指令<code>ScriptAlias</code>：使Apache允许执行一个特定目录中的CGI程序，当客户端请求此特定目录中的资源时，Apache假定其中所有的文件都是CGI程序并试图运行它。格式：<code>ScriptAlias /cgi-bin/ &quot;CGI存放目录&quot;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule alias_module&gt;</span><br><span class="line">    ScriptAlias /cgi-bin/ &quot;/var/www/cgi-bin/&quot;</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;Directory &quot;/var/www/cgi-bin&quot;&gt;</span><br><span class="line">    AllowOverride None</span><br><span class="line">    Options None</span><br><span class="line">    Require all granted</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure><p>关于CGI模块加载的配置在<code>conf.modules.d/01-cgi.conf</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mpm_worker_module&gt;</span><br><span class="line">   LoadModule cgid_module modules/mod_cgid.so</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line">&lt;IfModule mpm_event_module&gt;</span><br><span class="line">   LoadModule cgid_module modules/mod_cgid.so</span><br><span class="line">&lt;/IfModule&gt;</span><br><span class="line"># worker和event使用mod_cgid，而prefork使用mod_cgi</span><br><span class="line">&lt;IfModule mpm_prefork_module&gt;</span><br><span class="line">   LoadModule cgi_module modules/mod_cgi.so</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>若开启了Selinux，则还需要修改<code>cgi-bin</code>的上下文<code>chcon -R -t httpd_sys_script_exec_t /var/www/cgi-bin</code></p><h1 id="httpd与SSL"><a href="#httpd与SSL" class="headerlink" title="httpd与SSL"></a>httpd与SSL</h1><p>SSL对Apache能提供的功能：</p><ul><li>认证用户与服务器</li><li>提供数据保密性和完整性</li></ul><p>SSL协议的工作流程包括<strong>服务器认证阶段</strong>和<strong>用户认证阶段</strong></p><ul><li>客户端向服务器发送一个hello开始消息，发起一个会话连接</li><li>服务器根据客户端信息确定是否生成新的主密钥，如果需要就会在响应hello信息中添加生成主密钥需要的信息</li><li>客户端收到响应信息，根据信息生成一个主密钥，用服务器的公钥加密发给服务器</li><li>服务器收到后返回客户一个用主密钥认证的信息，让客户端认证服务器</li><li>服务器通过客户端认证后，进入用户认证阶段，由服务器开始对客户端的认证</li><li>服务器向客户端发起提问（封装在数字签名中）</li><li>客户端返回答案和公钥，提供认证信息</li></ul><img src="/2018/05/02/Apache-Server笔记/7.png"><p>HTTPS安全超文本传输协议，内置在浏览器中，对数据压缩和解密。HTTPS就是用SSL作为HTTP应用层的子层，使用TCP443端口。</p><p>Apache通过<code>mod_ssl</code>模块实现对TLS/SSL的支持，该模块存放在<code>/usr/lib64/httpd/modules/mod_ssl.so</code>，并有配置文件<code>/etc/httpd/conf.modules.d/00-ssl.conf</code>。还有相关模块<code>mod_socache_shmcb</code>，是一个共享对象缓存提供程序，提供对共享内存段内高性能循环缓冲区支持的缓存的创建和访问，已默认加载。</p><p>httpd服务器配置自签名证书：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out /etc/pki/tls/private/server.key 2048    #生成私钥</span><br><span class="line">openssl req -new -x509 -key /etc/pki/tls/private/server.key -out /etc/pki/tls/certs/server.crt  #根据私钥生成根证书</span><br><span class="line">    Country Name (2 letter code) [XX]:CN            #国家名</span><br><span class="line">    State or Province Name (full name) []:jiangsu   #省名</span><br><span class="line">    Locality Name (eg, city) [Default City]:Yangzhou    #地名</span><br><span class="line">    Organization Name (eg, company) [Default Company Ltd]:NJUPT  #公司名</span><br><span class="line">    Organizational Unit Name (eg, section) []:Tech    #部门名</span><br><span class="line">    Common Name (eg, your name or your server&apos;s hostname) []:system1  #主机名</span><br><span class="line">    Email Address []:system1@example.com  #邮箱</span><br></pre></td></tr></table></figure><p>也可以通过进入<code>/etc/pki/tls/certs</code>并使用命令<code>make server.key</code>创建私钥。</p><p>配置SSL虚拟主机，需要引用<code>/etc/httpd/conf.d/ssl.conf</code>中的配置，并做修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:443&gt;</span><br><span class="line">    SSLEngine on</span><br><span class="line">    SSLProtocol all -SSLv2 -SSLv3</span><br><span class="line">    SSLCipherSuite HIGH:3DES:!aNULL:!MD5:!SEED:!IDEA</span><br><span class="line">    SSLHonorCipherOrder on</span><br><span class="line">    SSLCertificateFile /etc/pki/tls/certs/server.crt</span><br><span class="line">    SSLCertificateKeyFile /etc/pki/tls/private/server.key</span><br><span class="line"></span><br><span class="line">    DocumentRoot &quot;/var/www/html&quot;</span><br><span class="line">    ServerName system1.example.com</span><br><span class="line">    ErrorLog &quot;/var/log/httpd/error_log&quot;</span><br><span class="line">    CustomLog &quot;/var/log/httpd/access_log&quot; common</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>由于是对已存在的虚拟主机进行SSL封装，所以，需要在原虚拟主机中添加两条指令进行重定向，使任何访问原http地址的客户端都跳转到https地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    DocumentRoot &quot;/var/www/html&quot;</span><br><span class="line">    ServerName system1.example.com</span><br><span class="line">    ErrorLog &quot;/var/log/httpd/error_log&quot;</span><br><span class="line">    CustomLog &quot;/var/log/httpd/access_log&quot; common</span><br><span class="line">    RewriteEngine  on</span><br><span class="line">    RewriteRule  ^(/.*)$  https://%&#123;HTTP_HOST&#125;$1  [redirect=301]</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p>通过浏览器访问<code>http://system1.example.com</code>，会出现不安全提示</p><img src="/2018/05/02/Apache-Server笔记/8.png"><p>确认添加例外后，就能自动跳转到<code>https://system1.example.com</code>。</p><h1 id="httpd日志"><a href="#httpd日志" class="headerlink" title="httpd日志"></a>httpd日志</h1><p>当Apache开始运行后，会生成4种标准日志文件：</p><ul><li>错误日志error_log</li><li>访问日志access_log</li><li>传输日志</li><li>cookie日志</li></ul><p>若使用SSL加密，还会生成<code>ssl_access_log</code>、<code>ssl_error_log</code>、<code>ssl_request_log</code>。当日志文件过大时，Apache会自动生成新的日志文件，文件的名称以配置文件中指定。</p><p><code>LogFormat</code>指定的日志记录格式变量：</p><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>%b</td><td>发送字节（不含HTTP标题）</td></tr><tr><td>%f</td><td>文件名</td></tr><tr><td>%h</td><td>远程主机</td></tr><tr><td>%a</td><td>远程IP地址</td></tr><tr><td>%{HEADER}i</td><td>HEADER内容：发送给服务器的请求</td></tr><tr><td>%p</td><td>服务器的服务端口</td></tr><tr><td>%r</td><td>请求的第一行，类似GET / HTTP/1.0</td></tr><tr><td>%s</td><td>状态（起始请求），最后请求状态为%&gt;s</td></tr><tr><td>%t</td><td>时间，格式是common日志格式中的时间格式</td></tr><tr><td>%{format}t</td><td>时间，格式由format给出</td></tr><tr><td>%T</td><td>服务器请求花费的时间（单位秒）</td></tr><tr><td>%u</td><td>来自auth的远程用户，若返回码为401则可能是假的</td></tr><tr><td>%U</td><td>请求的URL路径</td></tr><tr><td>%v</td><td>服务器的提供服务ServerName</td></tr></tbody></table><p>错误日志记录的等级：</p><table><thead><tr><th>等级</th><th>解释</th></tr></thead><tbody><tr><td>Emerg</td><td>紧急，系统不可用</td></tr><tr><td>Alert</td><td>需要立刻注意</td></tr><tr><td>Crit</td><td>危险警告</td></tr><tr><td>Error</td><td>除上述三种外的其他情况</td></tr><tr><td>Warm</td><td>警告</td></tr><tr><td>Notice</td><td>需要引起注意</td></tr><tr><td>Info</td><td>一般消息</td></tr><tr><td>Debug</td><td>Debug模式产生的消息</td></tr></tbody></table><p>访问日志的种类：</p><ul><li>普通日志：在LogFormat定义的名字为common</li><li>参考日志：记录客户访问站点的用户身份，名字为referer</li><li>代理日志：记录请求的用户代理，名字为agent</li><li>综合日志：结合了上面三种，名字为combined</li></ul><h2 id="日志切割"><a href="#日志切割" class="headerlink" title="日志切割"></a>日志切割</h2><p>Apache提供了命令<code>rotatelogs</code>，对日志进行切割，将庞大的日志文件切割为相对小的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">以轮替时间做切割：rotatelogs [options] 日志文件 [轮替时间（单位秒）][偏移量]</span><br><span class="line">以日志大小做切割：rotatelogs [options] 日志文件 [日志文件大小]</span><br><span class="line">偏移量为相对于UTC的分钟数，若省略，默认为0，即使用UTC时间。东八区即为8x60=480</span><br><span class="line"></span><br><span class="line">可以把以下配置添加到主配置文件：</span><br><span class="line">TransferLog &quot;|rotatelogs 日志文件 86400&quot;</span><br><span class="line">TransferLog &quot;|rotatelogs 日志文件 5M&quot;</span><br><span class="line"></span><br><span class="line">默认生成的日志名为&quot;日志名.日志开始记录的时间&quot;，如果使用轮替时间，则该值就是轮替时间的倍数，可通过cron服务设置。如果日志文件包含了strftime转换格式，则使用该格式。当轮替时间结束或日志文件大小达到指定值，就会生成一个新日志文件</span><br><span class="line"></span><br><span class="line">  -v       详细的操作信息会被错误输出(strerr)</span><br><span class="line">  -l       使用本地时间。不要在改变了GMT偏移量的环境中使用该选项，若设置了此选项，也就不用设置偏移量了</span><br><span class="line">  -f       在程序启动时强制开启日志</span><br><span class="line">  -t       截断日志</span><br><span class="line">  -e       输出日志到标准输出</span><br><span class="line">  -c       创建日志，无论是否为空</span><br></pre></td></tr></table></figure><p>若要按时间轮替日志文件：</p><ul><li><code>ErrorLog &quot;|rotatelogs 日志存放目录/%Y%m%d_error.log 86400 480&quot;</code></li><li><code>CustomLog &quot;|rotatelogs 日志存放目录/%Y%m%d_access.log 86400 480&quot; common</code></li></ul><p>若要按日志大小轮替日志文件：</p><ul><li><p><code>ErrorLog &quot;|rotatelogs -l 目录/%Y%m%d_error.log 5M&quot;</code></p></li><li><p><code>CustomLog &quot;|rotatelogs -l 目录/%Y%m%d_access.log 5M&quot; common</code></p></li></ul><h2 id="Webalizer分析统计日志"><a href="#Webalizer分析统计日志" class="headerlink" title="Webalizer分析统计日志"></a>Webalizer分析统计日志</h2><p>Webalizer是一个高效的web服务器日志分析程序。webalizer基本支持所有的日志文件格式，包括common，combined。目前还支持ftp日志、squid日志分析。</p><p>直接<code>yum install webalizer</code>即可。webalizer的配置主要通过配置文件<code>webalizer.conf</code>实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LogFile      /var/log/httpd/access_log #日志文件的路径，也可通过命令行选项指定</span><br><span class="line">OutputDir    /var/www/usage #统计报表的输出位置</span><br><span class="line">HistoryName  /var/lib/webalizer/webalizer.hist #webalizer生成的历史文件名</span><br><span class="line">Incremental  yes #设置是否增量</span><br><span class="line">IncrementalName /var/lib/webalizer/webalizer.current #保存当前数据的文件名</span><br><span class="line">PageType     htm* #定义哪些类型的URL属于页面访问</span><br><span class="line">UseHTTPS     no #若在一台安全服务器上运行，需要开启</span><br><span class="line">DNSCache     /var/lib/webalizer/dns_cache.db #反向DNS解析的缓存文件</span><br><span class="line">DNSChildren  10 #设置用于DNS解析的子进程，值要在5到20间</span><br><span class="line">Quiet        yes #不显示输出信息</span><br><span class="line">FoldSeqErr   yes #强制忽略次序错误，因为Apache HTTP服务器可能会生成无序日志条目</span><br><span class="line">HideURL      *.gif #设置需要隐藏的内容</span><br><span class="line">SearchEngine  yahoo.com p= #设置搜索引擎和URL查询格式</span><br></pre></td></tr></table></figure><p><strong>一般只要配置<code>LogFile</code>和<code>OutputDir</code>即可。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">webalizer [options] [log file]</span><br><span class="line">  -v       显示日志详细信息</span><br><span class="line">  -d       显示额外的debug信息</span><br><span class="line">  -F type  设置日志类型（clf | ftp | squid | w3c）</span><br><span class="line">  -f       忽略次序错误</span><br><span class="line">  -i       忽略历史文件</span><br><span class="line">  -p       保留状态（递增）</span><br><span class="line">  -b       忽视状态（递增）</span><br><span class="line">  -q       忽略消息信息</span><br><span class="line">  -Q       忽略所有信息</span><br><span class="line">  -T       显示时间信息</span><br><span class="line">  -c file  指定配置文件</span><br><span class="line">  -n name  指定服务器主机名</span><br><span class="line">  -o dir   指定存放结果的文件</span><br><span class="line">  -t name  指定报告题目的主机名</span><br><span class="line">  --ip     查看指定IP地址的访问情况</span><br><span class="line">  --start  指定开始时间</span><br><span class="line">  --end    指定结束时间</span><br></pre></td></tr></table></figure><p>在<code>/var/www/usage</code>下生成了几张图片和两个html文件，其中<code>index.html</code>是简要信息，<code>usage_日期.html</code>是详细的分析文件</p><center>index.html</center><img src="/2018/05/02/Apache-Server笔记/5.png"><center>usage_日期.html</center><img src="/2018/05/02/Apache-Server笔记/6.png"><h1 id="httpd代理"><a href="#httpd代理" class="headerlink" title="httpd代理"></a>httpd代理</h1><p>httpd通过<code>ProxyRequests</code>指令配置正向代理的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ProxyRequests on</span><br><span class="line">ProxyVia on</span><br><span class="line">&lt;Proxy &quot;*&quot;&gt;      #访问任意外网URL</span><br><span class="line">    Require host 允许通过代理访问外网的内网服务器</span><br><span class="line">    #也可以是Require all granted</span><br><span class="line">&lt;/Proxy&gt;</span><br></pre></td></tr></table></figure><h1 id="Apache-MPM模式"><a href="#Apache-MPM模式" class="headerlink" title="Apache-MPM模式"></a>Apache-MPM模式</h1><p>MPM(<code>Multi-Processing Modules</code>)，Apache的多路处理模块，有三种模式：<code>prefork</code>、<code>worker</code>、<code>event</code>。</p><p>编译时可通过<code>--with-mpm</code>指定模式，也可以通过<code>--enable-mpms-shared=all</code>支持全部三种。httpd2.4以上默认采用<code>event</code>模式。并可通过<code>apachectl -l</code>看到编译了<br><code>event.c</code>模块。</p><blockquote><p>httpd2.4通过rpm安装会发现仍采用prefork模式，而源码安装则已使用event模式</p></blockquote><p>可以修改<code>httpd.conf</code>中添加以下模块（源码安装）或<code>/etc/httpd/conf.modules.d/00-mpm.conf</code>（rpm安装）改变模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoadModule mpm_prefork_module modules/mod_mpm_prefork.so 或</span><br><span class="line">LoadModule mpm_worker_module modules/mod_mpm_worker.so 或</span><br><span class="line">LoadModule mpm_event_module modules/mod_mpm_event.so</span><br></pre></td></tr></table></figure><ul><li><code>prefork</code>：实现了一个非线程、预派生的工作模式。在Apache启动之初，就会<strong>预派生一些子进程</strong>，然后等待连接。可以减少频繁创建和销毁进程的开销，<strong>每个子进程只有一个线程</strong>。成熟稳定，可以<strong>兼容新老模块</strong>，也<strong>不需要担心线程安全问题</strong>。<strong>效率比<code>worker</code>略高</strong><ul><li>缺点：<strong>一个进程相对地占用更多的资源，消耗大量内存，不擅长处理高并发的场景</strong>。</li></ul></li></ul><img src="/2018/05/02/Apache-Server笔记/1.png"><ul><li><code>worker</code>：使用了<strong>多进程和多线程的混合模式</strong>，也同样会预派生一些子进程，然后每个子进程创建一些线程，同时包括<strong>一个监听线程</strong>，每个请求过来会被分配到一个线程来服务。<strong>占用内存少，适合高并发环境</strong><ul><li><strong>使用线程的原因：</strong>线程比进程更加轻量级，因为<strong>线程通常会共享父进程的内存地址的，因此内存占用会减少一些</strong>。如果一个线程异常挂了，会<strong>导致父进程和它的其他正常子线程都挂了，只会影响Apache的一部分</strong>，而不是整个服务。</li><li>缺点：<strong>必须考虑线程安全问题</strong>，因为多个子进程时共享父进程的内存地址的。若使用keepalive的长连接方式，某个线程一直占据，若过多的线程被占用，会导致高并发时无服务线程可用。</li></ul></li></ul><img src="/2018/05/02/Apache-Server笔记/2.png"><ul><li><code>event</code>：从Apache2.2才被加入MPM，Apache2.4开始成为默认MPM。类似worker模式，但解决了keepalive问题。有一个<strong>专门的线程来管理这些keep-alive线程</strong>，当有真实请求过来的时候，将请求传递给服务线程，<strong>执行完毕后，又允许它释放</strong>，这样增强了在高并发场景下的请求处理能力。</li></ul><img src="/2018/05/02/Apache-Server笔记/3.png"><p><strong>各MPM模式的简单优化：</strong>若是rpm安装，就在<code>httpd.conf</code>中添加，若为源码安装，就在<code>/usr/local/httpd-2.4/conf/extra/httpd-mpm.conf</code>中找到对应模块修改。以下参数基本采用配置文件默认值。</p><ul><li><code>worker</code>模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mpm_worker_module&gt;</span><br><span class="line">    ServerLimit           25  #服务器允许配置的上限进程数</span><br><span class="line">    # 与ThreadLimit结合使用，可设置MaxClients允许配置的最大数值</span><br><span class="line">    # 在重启期间对ServerLimit的修改都会被忽略，但对MaxClients的修改可生效</span><br><span class="line">    </span><br><span class="line">    ThreadLimit          200  #每个子进程可配置的线程数的上限</span><br><span class="line">    # 也设置了ThreadPerChild的上限，默认为64</span><br><span class="line">    </span><br><span class="line">    StartServers           3  #服务器启动时建立的子进程数，默认为3</span><br><span class="line">    MinSpareThreads       75  #最小空闲线程数，默认75。</span><br><span class="line">    #若服务器中空闲进程太少，子进程会自动产生空闲进程等待</span><br><span class="line">    </span><br><span class="line">    MaxSpareThreads      250  #最大空闲线程数，默认250。</span><br><span class="line">    #若服务器中空闲进程太多，子进程会杀死多余的空闲进程。</span><br><span class="line">    #取值范围：&gt;= MinSpareThreads+ThreadsPerChild</span><br><span class="line">    </span><br><span class="line">    MaxClients          2500  #允许同时运行的最大进程数，任何超过限制的请求进入等待队列</span><br><span class="line">    #默认值为ServerLimit*ThreadsPerChild。若要增加此项，则同时也要增加ServerLimit</span><br><span class="line">    </span><br><span class="line">    ThreadsPerChild       25  #每个子进程建立的常驻执行线程数，默认25。</span><br><span class="line">    #子进程创建这些线程后就不创建新线程了</span><br><span class="line">    </span><br><span class="line">    MaxConnectionsPerChild 0  #处理多少个请求后子进程自动销毁，默认值0意味着永不销毁。</span><br><span class="line">    # 在Apache2.4版本以前，叫做MaxRequestsPerChild</span><br><span class="line">    #当负载较高时，为了使每个进程处理更多的请求，避免销毁、创建进程的开销，一般建议设置为0或较大的数字。</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><ul><li><code>prefork</code>模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mpm_prefork_module&gt;</span><br><span class="line">    StartServers              5  </span><br><span class="line">    MinSpareServers           5  #最小空闲进程数，与MinSpareThreads同理</span><br><span class="line">    MaxSpareServers          10  #最大空闲进程数，与MaxSpareThreads同理</span><br><span class="line">    ServerLimit            2000</span><br><span class="line">    MaxClients             1000  #默认MaxClients最多有256个线程</span><br><span class="line">    MaxConnectionsPerChild    0  </span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>修改模式重启httpd，查看进程，能看到五个子进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep httpd</span><br><span class="line">root       2241      1  1 22:05 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache     2242   2241  0 22:05 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache     2243   2241  0 22:05 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache     2244   2241  0 22:05 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache     2245   2241  0 22:05 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">apache     2248   2241  0 22:05 ?        00:00:00 /usr/sbin/httpd -DFOREGROUND</span><br></pre></td></tr></table></figure><ul><li><code>event</code>模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mpm_event_module&gt;</span><br><span class="line">    StartServers             3</span><br><span class="line">    MinSpareThreads         75</span><br><span class="line">    MaxSpareThreads        250</span><br><span class="line">    ThreadsPerChild         25</span><br><span class="line">    MaxRequestWorkers      400</span><br><span class="line">    MaxConnectionsPerChild   0</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><h1 id="Apache实用第三方模块"><a href="#Apache实用第三方模块" class="headerlink" title="Apache实用第三方模块"></a>Apache实用第三方模块</h1><p>若要在httpd上添加新的模块，可以通过修改模块配置文件增加<code>LoalModule</code>指令添加，也可以使用<code>httpd-devel</code>提供的工具<code>apxs</code>直接添加，需要httpd开启了DSO。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apxs </span><br><span class="line">  -n 模块名    指定模块名，可与-i和-g组合</span><br><span class="line">  -i          安装模块，可指定多个</span><br><span class="line">  -a          自动在主配置文件加上LoadModule</span><br><span class="line">  -A          自动在主配置文件加上#LoadModule，即安装了但先不启用</span><br><span class="line">  -c C文件     将.c文件编译为.so文件</span><br></pre></td></tr></table></figure><p>模块间可能存在依赖，可根据报错信息解决。</p><h2 id="Gzip压缩"><a href="#Gzip压缩" class="headerlink" title="Gzip压缩"></a>Gzip压缩</h2><p>Gzip将Apache网页内容压缩后传输给客户端，加快网页加载速度，建议开启。Gzip有两个模块：<code>mod_gzip</code>和<code>mod_deflate</code>，</p><h2 id="防DDOS攻击"><a href="#防DDOS攻击" class="headerlink" title="防DDOS攻击"></a>防DDOS攻击</h2><p>应对DDOS攻击的模块为<code>mod_evasive</code>，可通过<code>yum install mod_evasive</code>获取。安装完成后会生成<code>/usr/lib64/httpd/modules/mod_evasive24.so</code>，以及<code>/etc/httpd/conf.d/mod_evasive.conf</code></p><h1 id="LAMP环境搭建"><a href="#LAMP环境搭建" class="headerlink" title="LAMP环境搭建"></a>LAMP环境搭建</h1><p>直接用<code>yum|dnf</code>安装php，php版本为7.1。php的核心包：</p><ul><li><code>php</code>：在<code>/etc/httpd/conf.d/</code>创建了<code>php.conf</code>，在<code>/usr/lib64/httpd/modules/</code>创建了<code>libphp7.so</code></li><li><code>php-common</code>：创建了大量模块存放在<code>/usr/lib64/php/modules/</code>，帮助文档，配置文件<code>/etc/php.ini</code>以及<code>/etc/php.d/</code>中各个配置文件。</li><li><code>php-fpm</code>：创建了配置文件<code>/etc/php-fpm.conf</code>及<code>/etc/php-fpm.d/</code></li><li><code>php-cli</code>：创建了命令<code>php</code>、<code>php-cgi</code>、<code>phar</code>、<code>phpize</code>存放在<code>/usr/bin/</code>中</li></ul><p>使用<code>systemctl start php-fpm</code>启动。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul><li>高性能网站构建实战</li><li>Linux系统管理与网络管理</li><li>Linux就该这么学</li><li>Linux运维之道（第二版）</li><li>Linux服务器架设指南（第二版）</li><li>防线-企业Linux安全运维理念和实战</li><li>RHCSA/RHCE红帽Linux认证学习指南（第7版）</li><li><a href="https://blog.csdn.net/ccscu/article/details/70182476" target="_blank" rel="noopener">Apache性能优化之MPM选择和配置</a></li><li><a href="http://blog.jobbole.com/91920/" target="_blank" rel="noopener">Apache的三种MPM模式比较：prefork，worker，event</a></li><li><a href="https://blog.csdn.net/njys1/article/details/60867092" target="_blank" rel="noopener">apache的三种mpm模式</a></li><li><a href="https://www.cnblogs.com/jpdoutop/p/httpd-htaccess.html" target="_blank" rel="noopener">浅谈.htaccess文件–避免滥用.htaccess文件</a></li><li><a href="https://httpd.apache.org/docs/2.4/howto/htaccess.html" target="_blank" rel="noopener">Apache HTTP Server Tutorial: .htaccess files</a></li><li><a href="https://httpd.apache.org/docs/2.4/howto/ssi.html" target="_blank" rel="noopener">Apache httpd Tutorial: Introduction to Server Side Includes</a></li><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7627035.html" target="_blank" rel="noopener">简单说明CGI和动态请求是什么</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> Apache </tag>
            
            <tag> http </tag>
            
            <tag> LAMP </tag>
            
            <tag> LAMT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NFS基础笔记</title>
      <link href="/2018/05/02/NFS%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/02/NFS%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇笔记包含以下内容：</p><ul><li><a href="#NFS原理">NFS原理</a></li><li><a href="#NFS基础配置">NFS基础配置</a><ul><li><a href="#服务器端">服务器端</a></li><li><a href="#客户端">客户端</a><a id="more"></a></li></ul></li></ul><h2 id="NFS原理"><a href="#NFS原理" class="headerlink" title="NFS原理"></a>NFS原理</h2><p>NFS（Network Files Network）网络文件系统，允许网络中主机通过通过TCP/IP进行资源共享。采用C/S工作模式，NFS服务器相当于文件服务器，将某个目录设置为输出目录，客户端可将服务器端的输出目录挂载在本地进行访问。NFSv4基于TCP，端口号2049。<br>RPC（Remote Procedure Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务，跨越了传输层和应用层的协议。</p><h2 id="NFS基础配置"><a href="#NFS基础配置" class="headerlink" title="NFS基础配置"></a>NFS基础配置</h2><p>环境：</p><ul><li>两台虚拟机<br>  192.168.163.103/24<br>  192.168.163.104/24</li><li>系统：CentOS7</li><li>Selinux：关闭</li><li>防火墙：关闭</li></ul><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>NFS服务依赖于RPC服务与外界通信，所以需要安装rpcbind程序<br>而NFS</p><ul><li>安装NFS主程序和RPC程序<br><code>yum install nfs-utils rpcbind</code><br><code>systemctl enable nfs-server</code><br><code>systemctl start nfs-server rpcbind.service</code></li><li>配置文件<code>/etc/exports</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 格式为：共享目录  分享给的主机1(参数)  主机2(参数) ...</span><br><span class="line">/var/nfsshare  192.168.163.*(rw,sync)  *.example.com(rw)</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数列表</strong></p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>ro</td><td>客户端只读</td></tr><tr><td>rw</td><td>客户端可读写</td></tr><tr><td>sync</td><td>数据同步写入内存与磁盘，保证数据一致性，效率低</td></tr><tr><td>async</td><td>异步IO，数据先暂时存与内存，待需要时写入硬盘，效率高，但数据丢失风险高</td></tr><tr><td>noaccess</td><td>阻止访问该目录及其子目录</td></tr><tr><td>all_squash</td><td>无论NFS客户端使用什么用户访问，都映射为NFS服务器端的匿名用户，即nfsnobody</td></tr><tr><td>root_squash</td><td>当NFS客户端使用root访问时，映射为NFS服务器端的匿名用户，即nfsnobody</td></tr><tr><td>no_root_squash</td><td>当NFS客户端使用root访问时，仍映射为NFS服务器端的root，并不安全</td></tr><tr><td>wdelay</td><td>为合并多次更新而延迟写入磁盘</td></tr><tr><td>no_wdelay</td><td>尽可能快地写入磁盘</td></tr><tr><td>secure</td><td>限制nfs服务只能使用小于1024的TCP/IP端口传输数据</td></tr><tr><td>insecure</td><td>可使用大于1024的端口</td></tr><tr><td>anounuid</td><td>指定NFS服务器中的用户为匿名用户</td></tr><tr><td>anoungid</td><td>指定NFS服务器中的用户组为匿名用户组</td></tr></tbody></table><blockquote><p>默认情况下，nfs服务会禁止客户端的root用户对共享目录进行写操作，目的是为了保证当nfs以共享目录工作时，共享目录的数据不会被客户端随意修改，但是当nfs以远程存储工作时，这个功能就不合理，所以当nfs以远程存储来工作时，需要在服务端设置no_root_squash选项关闭该功能。</p></blockquote><p>配置完后重启nfs-server服务，或者使用<code>exportfs</code>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exportfs </span><br><span class="line">-a  导出所有列在/etc/exports的目录</span><br><span class="line">-v  显示所有被导出或取消导出的目录</span><br><span class="line">-r  重新导出所有列在/etc/exports的目录</span><br><span class="line">-u [目录] 取消指定目录的导出，与-a同时用时，会取消配置文件中所有目录的导出</span><br></pre></td></tr></table></figure></p><p><code>nfsstat</code>命令可查看当前NFS信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nfsstat </span><br><span class="line">-s 显示NFS服务器信息</span><br><span class="line">-c 显示NFS客户端信息</span><br><span class="line">-m 显示每个NFS文件系统的统计信息（在客户端上查看）</span><br><span class="line">-r 显示RPC信息</span><br></pre></td></tr></table></figure></p><p>若开启了firewalld，则需要放行nfs和rpcbind还有mountd服务，放行端口2049<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-service=nfs</span><br><span class="line">firewall-cmd --permanent --add-service=rpc-bind</span><br><span class="line">firewall-cmd --permanent --add-service=mountd</span><br><span class="line">firewall-cmd --permanent --add-port=2049/tcp 2049/udp</span><br></pre></td></tr></table></figure></p><blockquote><p>mountd提供挂载服务，与nfs无关，只是为了方便客户端挂载</p></blockquote><p>若开启了Selinux，需要添加上下文<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chcon -R -t public_content_t /var/nfsshare</span><br><span class="line">setsebool -P nfs_export_all_rw on</span><br><span class="line">setsebool -P nfs_export_all_ro on</span><br></pre></td></tr></table></figure></p><h3 id="NFS客户端"><a href="#NFS客户端" class="headerlink" title="NFS客户端"></a>NFS客户端</h3><ul><li>需要安装<code>nfs-utils rpcbind</code><br><code>yum install nfs-utils rpcbind</code></li><li>通过<code>showmount</code>查看NFS服务器的共享信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">showmount [options] [NFS服务器]</span><br><span class="line">-e 显示NFS服务器的共享列表</span><br><span class="line">-a 显示本机挂载NFS资源情况</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># showmount -e 192.168.163.102</span><br><span class="line">Export list for 192.168.163.102:</span><br><span class="line">/var/nfsshare 192.168.163.*</span><br></pre></td></tr></table></figure><ul><li>挂载到本机<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mkdir /nfsshare  #创建挂载目录</span><br><span class="line"># mount -t nfs 192.168.163.102:/var/nfsshare /nfsshare</span><br><span class="line"># df -h</span><br><span class="line">Filesystem                     Size  Used Avail Use% Mounted on</span><br><span class="line">......</span><br><span class="line">192.168.163.102:/var/nfsshare   17G  8.1G  9.0G  48% /nfsshare</span><br></pre></td></tr></table></figure></li></ul><p>在mount时也可使用<code>-o</code>指定文件系统的选项<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rsize=   从NFS服务器读文件时每次使用的字节数，默认1024字节</span><br><span class="line">wsize=   向NFS服务器写文件时每次使用的字节数，默认1024字节</span><br><span class="line">timeo=   RPC调用超时后，确定重试算法的参数</span><br><span class="line">soft   软挂载方式，当客户端请求得不到回应时，提示IO错误并退出</span><br><span class="line">hard   硬挂载方式，当客户端请求得不到回应时，提示服务器无响应，但继续请求。默认硬挂载</span><br><span class="line">intr   NFS文件操作超时并时硬挂载时，允许中断文件操作并向调用它的程序返回EINTR</span><br><span class="line">ro   只读方式挂载NFS文件系统</span><br><span class="line">rw   读写方式挂载NFS文件系统</span><br><span class="line">fg   在前台重试挂载</span><br><span class="line">bg   在后台重试挂载</span><br></pre></td></tr></table></figure></p><p>也可通过配置文件<code>/etc/fstab</code>开机自动挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/fstab</span><br><span class="line">......</span><br><span class="line">192.168.163.102:/var/nfsshare  /nfsshare  nfs  defaults 0 0</span><br></pre></td></tr></table></figure></p><p><strong>使用mount或配置文件/etc/fstab挂载的不足：</strong>NFS服务器与客户端的连接不是永久的，任何一方的掉线都会导致另一方等待超时。并且即使很多用户都挂载了共享目录，也会有大部分的用户在大部分时间是不会使用的，这样造成了NFS服务器资源的大量消耗。可通过autofs服务按需动态挂载解决该问题。</p><ul><li>使用autofs自动挂载<br>autofs是一个提供按需挂载的服务，只有在用户访问该挂载点时才会动态挂载该共享目录。<br>安装autofs程序，并开机自启<br><code>yum install autofs</code><br><code>systemctl enable autofs.service</code><br><code>systemctl start autofs.service</code><br>创建autofs关于nfs主配置文件，也可以直接在autofs的主配置文件<code>/etc/auto.master</code>中添加内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/auto.master.d/nfs.autofs</span><br><span class="line">主配置文件的配置格式：</span><br><span class="line">挂载点顶层目录      映射文件</span><br><span class="line">/nfs                  /etc/nfs.misc</span><br><span class="line">由于挂载点为/nfs/share，所以顶层目录为/nfs</span><br></pre></td></tr></table></figure></li></ul><p>创建nfs配置的映射文件<code>/etc/nfs.misc</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim /etc/nfs.misc</span><br><span class="line">映射文件格式：</span><br><span class="line">挂载点     [-挂载选项]       NFS服务器名或IP:共享目录</span><br><span class="line">挂载点是对于挂载点顶层目录的相对路径</span><br><span class="line">share   -fstype=nfs,rw   192.168.163.102:/var/nfsshare</span><br></pre></td></tr></table></figure></p><p>配置完成后重启autofs服务即可。<br>进入<code>/nfs</code>目录中，查看并无内容。然后进入<code>share</code>便可查看到挂载目录的内容。再通过<code>df</code>查看，已成功挂载。</p><p><strong>注：</strong>由于在客户端挂载时也会指定选项，若与服务器端选项不同，在执行操作时可能会报错，即：选项以服务器端配置为准。</p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> nfs </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Samba基础学习笔记</title>
      <link href="/2018/05/02/samba%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/05/02/samba%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>本篇笔记包含以下内容：</p><ul><li><a href="#Samba原理">Samba原理</a></li><li><a href="#Samba基础配置">Samba基础配置</a><ul><li><a href="#服务器端">服务器端</a></li><li><a href="#客户端">客户端</a></li></ul></li></ul><a id="more"></a><img src="/2018/05/02/samba笔记/sambalogo.jpg" title="sambalogo"><h2 id="Samba原理"><a href="#Samba原理" class="headerlink" title="Samba原理"></a>Samba原理</h2><p>Samba最初的目的是为了Windows和Linux之间的沟通，实现不同操作系统的资源共享，如今成为了十分安全，高效的文件服务。<br>Samba有以下主要功能：</p><ul><li>共享文件与打印机</li><li>提供身份认证，给不同身份的用户不同的访问权限和文件</li><li>可进行域名解析，将计算机的NetBIOS名解析为IP地址</li><li>samba能收集局域网上用户广播的主机信息，提供检索服务，也称为浏览服务，能显示共享目录，打印机等资源</li><li>支持SSL</li></ul><p>Samba整合了SMB协议和NetBIOS协议，基于TCP/IP。<br><strong>NetBIOS协议</strong><br>NetBIOS（Network Basic Input/Output System），网络基本输入输出系统协议，属于会话层协议。能通过该协议获取计算机主机名，并解析为IP地址。<br><strong>SMB协议</strong><br>SMB（Send Messsage Block），运行于NBT协议（NetBIOS over TCP/IP），属于表示层与应用层协议。端口号：139/TCP，137、138/UDP。</p><p><strong>SMB协议工作流程</strong></p><ol><li>协议协商<br>客户端向Samba服务器发送Negport请求报文，列出所有支持的SMB版本。服务器收到后回应Negport报文，列出希望客户端使用的SMB版本。</li><li>建立连接<br>确定了SMB版本，客户端会发送Session Setup请求报文，包含用户名与密码，建立连接。服务器收到后进行验证并回应报文，若验证通过，就返回为该用户分配的唯一UID，若失败则返回失败信息。</li><li>访问共享资源<br>客户端向服务器发送Tree Connect请求报文，包含要访问的共享资源名。服务器收到后，根据配置文件确定是否该用户能访问，返回一个响应报文，若允许访问，就给该用户与共享资源连接分配一个TID，用户即可访问该资源。</li><li>断开连接<br>客户端向服务器发送Tree Disconnect报文，请求服务器断开连接，服务器也回应一个响应，并断开连接。</li></ol><p><strong>Samba守护进程</strong></p><ul><li>用户若要访问Windows上的公共资源，必须加入该Windows主机的群组Workgroup，并该用户主机必须设置一个主机名（不是hostname），该主机名是建立在NetBIOS协议上的，可称为NetBIOS Name，在同一个群组中，该NetBIOS Name必须唯一。</li><li>用户是否能访问并对该文件进行操作不仅需要通过服务器身份认证，还需要对该文件具有权限。</li></ul><p>Samba服务有两个守护进程</p><ul><li>smbd：用于管理samba主机共享目录、文件、打印机等，利用TCP传输文件，开放端口为139/TCP和445/TCP</li><li>nmbd：用于管理群组、NetBIOS Name的解析，基于UDP，开启端口137/UDP，138/UDP进行解析</li></ul><p>Samba安装包：</p><ul><li>samba：包含samba的守护进程文件，samba文档，logrotate配置文件，开机默认选项配置文件</li><li>samba-common：包含samba主要配置文件smb.conf，配置文件检查程序testparm等</li><li>samba-client：samba客户端程序，提供客户端操作指令集</li></ul><h2 id="Samba基础配置"><a href="#Samba基础配置" class="headerlink" title="Samba基础配置"></a>Samba基础配置</h2><p>实验环境：</p><ul><li>两台虚拟机：<br>  samba服务器：192.168.163.103/24<br>  samba客户端：192.168.163.104/24</li><li>系统：CentOS7</li><li>Selinux：未开启</li><li>firewalld：未开启</li></ul><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p><strong>安装samba客户端</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install samba-common samba</span><br><span class="line">systemctl enable smb nmb</span><br><span class="line">systemctl start smb nmb</span><br></pre></td></tr></table></figure></p><p><strong>创建共享目录，可随意创</strong><br><code>mkdir /var/smbshare</code><br><strong>修改配置文件<code>/etc/samba/smb.conf</code></strong><br>配置文件中可在选项前加<code>;</code>使其不生效，相当于<code>#</code>注释<br>配置文件存在以下配置块：<br><code>[global]</code> 全局选项，对所有资源生效<br>基础配置则不需要修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">    workgroup = SAMBA   #设置群组</span><br><span class="line">    server string = Samba Server #设置服务器描述</span><br><span class="line">    netbios name = MYSERVER #设置NetBIOS Name</span><br><span class="line">    interfaces = lo eth0 192.168.163.0/24 # 设置监听接口、IP地址</span><br><span class="line">    hosts allow = 192.168.163. #白名单，设置允许的主机网段</span><br><span class="line">    hosts deny = #黑名单，黑白名单设置一个即可</span><br><span class="line">    security = user     #samba的安全模式，有三种模式：user、share、server</span><br><span class="line">    #user模式为每次访问服务器都会登录验证，share模式为不需登录。官方仅推荐user模式。</span><br><span class="line">    passdb backend = tdbsam #存放用户信息，有两种选择tdbsam和lsapsam，tdbsam不需要额外配置</span><br><span class="line">    log file = /var/log/samba/log.%m #设置日志文件路径，%m会替换为请求连接的NetBIOS名</span><br><span class="line">username map = /etc/samba/smbusers #设置用户映射，记录samba账号和虚拟账号的对应关系</span><br><span class="line"></span><br><span class="line">    #---打印配置---</span><br><span class="line">    printing = cups #打印配置，使用cups服务</span><br><span class="line">    printcap name = cups #通常设置为printcap文件</span><br><span class="line">    load printers = yes #自动加载打印机列表</span><br><span class="line">    cups options = raw #设置cups的选项，raw为允许在windows客户端上加载驱动</span><br></pre></td></tr></table></figure></p><p><code>[homes]</code>为特殊共享目录，表示用户主目录<br><code>[printers]</code>为特殊共享目录，表示打印机<br>配置共享资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[smbshare]</span><br><span class="line">    comment = smbshare  #资源描述</span><br><span class="line">    path = /var/smbshare #共享目录</span><br><span class="line">    public = no #是否允许匿名访问</span><br><span class="line">    guest ok = no #是否允许不输入密码访问</span><br><span class="line">    printable = Yes #是否可读</span><br><span class="line">    writable = yes #是否可写，只有该目录有写权限且此项为yes，才能写入</span><br><span class="line">    browseable = yes #是否可见</span><br><span class="line">    write list = mike #设定特定用户写权限</span><br><span class="line">    #若writable为no，此项仍能生效</span><br><span class="line">    create mask = 0600 #创建文件默认权限</span><br><span class="line">    directory mask = 0775 #创建目录默认权限链路</span><br><span class="line">    hosts allow =192.168.163. #白名单</span><br></pre></td></tr></table></figure></p><p>可通过<code>testparm</code>检查配置文件是否正确<br>可通过<code>man smb.conf</code>查看详细配置文件选项<br><strong>创建用户并添加到samba</strong><br>由于该用户是提供给客户端用于登录samba的，所以在服务器端应设置为不能登陆，并且为了安全性，不要设密码。<br><code>useradd mike -s /sbin/nologin</code><br><strong>注：</strong>samba并不是将系统中的用户变为samba用户的，samba的用户是独立于linux系统的，但必须在linux系统中存在，才能映射，所以linux系统中需要创建同名用户。<br>将用户添加到smb服务器的用户列表中，并设置smb登录密码<br><code>smbpasswd -a mike</code>，然后输入登录密码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd [options] [username]</span><br><span class="line">-a  add添加</span><br><span class="line">-d  disable禁止用户访问</span><br><span class="line">-n  no password不设置密码，需要smb.conf中global设置nullpasswords=true开启</span><br><span class="line">-x  delete删除用户</span><br></pre></td></tr></table></figure></p><p>或者使用另一条命令<code>pdbedit</code>，用于管理SMB服务的账号信息数据库<br><code>pdbedit -a -u mike</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pdbedit [options] [username]</span><br><span class="line">    -a 添加</span><br><span class="line">    -x 删除</span><br><span class="line">    -L 列出用户列表</span><br><span class="line">    -v 详细信息</span><br></pre></td></tr></table></figure></p><p><strong>注：</strong></p><ul><li>若安装并开启了firewalld，需要开启端口TCP139端口，UDP137、138端口，并放行服务samba。</li><li>若安装并开启了Selinux，需要添加上下文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">chcon -R -t samba_share_t /var/smbshare</span><br><span class="line">或semanage fcontext -a -t samba_share_t /var/smbshare</span><br><span class="line">然后</span><br><span class="line">setsebool -P samba_export_all_rw on</span><br><span class="line">setsebool -P samba_export_all_ro on</span><br><span class="line">若分享的是/home</span><br><span class="line">setsebool -P samba_enable_home_dirs on</span><br><span class="line">配置完后restorecon -Rv /var/smbshare</span><br></pre></td></tr></table></figure></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>安装samba客户端</strong><br><code>yum install samba-client cifs-utils</code><br><code>cifs-utils</code>是让Windows系统能使用公共文件系统的工具。<br><code>CIFS</code>是微软开发的公共Internet文件系统协议，能够支持网上邻居。<br><strong>查看服务器给指定用户提供的共享目录的信息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># smbclient -L //192.168.163.103/smbshare -U mike</span><br><span class="line">Enter SAMBA\mike&apos;s password:</span><br><span class="line"></span><br><span class="line">        Sharename       Type      Comment</span><br><span class="line">        ---------       ----      -------</span><br><span class="line">        print$          Disk      Printer Drivers</span><br><span class="line">        share           Disk      SHARE</span><br><span class="line">        smbshare        Disk      smbshare</span><br><span class="line">        IPC$            IPC       IPC Service (Samba 4.7.1)</span><br><span class="line">        mike            Disk      Home Directories</span><br><span class="line">Reconnecting with SMB1 for workgroup listing.</span><br><span class="line"></span><br><span class="line">        Server               Comment</span><br><span class="line">        ---------            -------</span><br><span class="line"></span><br><span class="line">        Workgroup            Master</span><br><span class="line">        ---------            -------</span><br><span class="line">        SAMBA                SYSTEM3</span><br></pre></td></tr></table></figure></p><p>从返回信息可得知共享资源以及群组和服务器名<br><strong>登录smb服务器，进入指定资源</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># smbclient //192.168.163.103/smbshare -U mike</span><br><span class="line">Enter SAMBA\mike&apos;s password:</span><br><span class="line">Try &quot;help&quot; to get a list of possible commands.</span><br><span class="line">smb: \&gt;</span><br></pre></td></tr></table></figure></p><p>已进入该共享目录，并进入samba客户端命令行模式，可通过<code>help</code>查看能进行的操作<br>常用命令如下：<br><code>put [本机文件路径] [资源中相对路径]</code> 上传文件<br><code>get [资源路径]</code> 下载文件</p><p><strong>客户端挂载</strong></p><ul><li>创建认证文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># vim /root/secure/auth.smb</span><br><span class="line">username=mike</span><br><span class="line">password=redhat</span><br><span class="line">domain=SAMBA</span><br></pre></td></tr></table></figure></li></ul><p>设置该文件的权限，这个文件的机密性很重要<br><code>chmod 700 /root/secure</code><br><code>chmod 600 /root/secure/auth.smb</code></p><ul><li>挂载共享目录<br><code>mount -t cifs -o rw,credentials=/root/secure/auth.smb //192.168.163.103/smbshare /shares/smbshare</code></li></ul><p><strong>Windows端登录及挂载</strong><br>在Windows端，可在文件资源管理器的地址栏输入<code>\\192.168.163.103\smbshare</code>登录进入smb服务器的该资源。<br>若要挂载，在“此电脑”中右击，选择“添加一个网络位置”，按“下一步”，进入以下界面，填入要挂载的共享目录</p><p>然后不断“下一步”，即可设置完成。在“此电脑”查看，已成功挂载。</p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> Samba </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL完全笔记</title>
      <link href="/2018/04/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/30/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>基于MySQL5.7</strong></p><p>本篇包含以下知识点：</p><ul><li><a href="#MySQL体系">MySQL体系结构</a></li><li><a href="#存储引擎">存储引擎</a></li><li><a href="#数据类型">数据类型</a><ul><li><a href="#运算符">运算符</a></li><li><a href="#函数">函数</a></li></ul></li><li><a href="#表操作">表操作</a></li><li><a href="#数据操作">数据操作</a><a id="more"></a></li><li><a href="#索引">索引</a></li><li><a href="#视图">视图</a></li><li><a href="#触发器">触发器</a></li><li><a href="#存储过程与函数">存储过程与函数</a></li><li><a href="#事务">事务</a></li><li><a href="#安全">安全</a></li><li><a href="#日志">日志</a></li><li><a href="#维护">维护</a></li></ul><img src="/2018/04/30/MySQL学习笔记/mysql.jpg" title="mysql"><h2 id="MySQL体系"><a href="#MySQL体系" class="headerlink" title="MySQL体系"></a>MySQL体系</h2><p>MySQL采用C/S体系，因此在使用时，是运行两个程序：</p><ul><li>mysqld：MySQL服务器程序，运行在数据库服务器上，负责监听并处理请求</li><li>mysql-client：运行在客户端上，负责连接到数据库服务器并发出指令。</li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL具有<strong>可替换存储引擎构架</strong>的特征。MySQL功能分为两部分：</p><ul><li>外层部分：完成与客户端的连接，调查SQL语句的内容</li><li>内层部分：即存储引擎部分，负责接收外层的数据操作指令，完成实际的数据输入输出及文件操作。<br>MySQL支持多种存储引擎，可通过<code>show engines;</code>查看mysql支持的存储引擎，MySQL共支持9种存储引擎，其中最主要的两个引擎为MyISAM和InnoDB，默认引擎为InnoDB。</li></ul><p>MyISAM与InnoDB的区别：</p><table><thead><tr><th>特性</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>存储限制</td><td>有</td><td>64TB</td></tr><tr><td>事务安全</td><td>不支持</td><td>支持</td></tr><tr><td>锁机制</td><td>表锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td></tr><tr><td>哈希索引</td><td>不支持</td><td>不支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>集群索引</td><td>不支持</td><td>支持</td></tr><tr><td>数据缓存</td><td></td><td>支持</td></tr><tr><td>索引缓存</td><td>支持</td><td>支持</td></tr><tr><td>数据可压缩</td><td>支持</td><td>不支持</td></tr><tr><td>空间使用</td><td>低</td><td>高</td></tr><tr><td>内存使用</td><td>低</td><td>高</td></tr><tr><td>批量插入速度</td><td>高</td><td>低</td></tr><tr><td>外键</td><td>不支持</td><td>支持</td></tr></tbody></table><ul><li>InnoDB只有表结构，数据全部存储在ibdata1文件中，算法复杂。</li><li>MyISAM将表，数据，索引全部单独存储。</li><li>MyISAM适合对事务完整型无要求并以访问为主的应用，访问速度快。</li><li>InnoDB适合频繁更新、删除操作，对事务要求高，需要实现并发控制的应用。</li></ul><p>可通过<code>show create table 表名</code>查询表中使用的存储引擎。<br>也可通过<code>alter table 表名 engine=引擎</code>更改表的存储引擎。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>整数</p><ul><li>tinyint：1字节</li><li>smallint：2字节</li><li>mediumint：3字节</li><li>int：4字节</li><li>bigint：8字节</li></ul><p>整数类型都分为有符号与无符号。默认有符号，可在类型前加上unsigned创建无符号类型。<br>插入数据只能插入整数，若字段设置了是整数类型，就算插入浮点数也会转换为整数。<br>零填充：zerofill，若数据位数不满设置位数值，则前面补充0，且若设置零填充，数据类型自动变为无符号类型。零填充意义：保持数据格式</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc my_int;</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">| tinyint_1   | tinyint(4)   | YES  |     | NULL    |       |</span><br><span class="line">| smallint_1  | smallint(6)  | YES  |     | NULL    |       |</span><br><span class="line">| mediumint_1 | mediumint(9) | YES  |     | NULL    |       |</span><br><span class="line">| int_1       | int(11)      | YES  |     | NULL    |       |</span><br><span class="line">| bigint_1    | bigint(20)   | YES  |     | NULL    |       |</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line"># 括号中的数值为显示位数（宽度），可修改，不会影响数据。</span><br><span class="line">mysql&gt; alter table my_int modify int_1 int zerofill;</span><br><span class="line"># zerofill 会在显示宽度不满时用0填满</span><br><span class="line">mysql&gt; select int_1 from my_int;</span><br><span class="line">+------------+</span><br><span class="line">| int_1      |</span><br><span class="line">+------------+</span><br><span class="line">| 0000000004 |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><ul><li><p>浮点数</p><ul><li>float：4字节，也可设置为float(M,D)</li><li>double：8字节</li><li>decimal(M,D)：定点数，M+2字节，取值范围与double一致，但有效范围由M与D决定，M为一共的位数，D为小数部分的位数。<br>小数部分超出没问题，会自动四舍五入，但整数部分不能超出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table my_float(</span><br><span class="line">float_1 float(5,2),</span><br><span class="line">double_1 double(5,2),</span><br><span class="line">decimal_1 decimal(5,2)</span><br><span class="line">);</span><br><span class="line">mysql&gt; insert into my_float values(1.115,1.115,1.115);</span><br><span class="line"># 整数部分不能超出规定长度，但小数部分可以，小数的超出部分会四舍五入。</span><br><span class="line">mysql&gt; select * from my_float;</span><br><span class="line">+---------+----------+-----------+</span><br><span class="line">| float_1 | double_1 | decimal_1 |</span><br><span class="line">+---------+----------+-----------+</span><br><span class="line">|    1.12 |     1.12 |      1.12 |</span><br><span class="line">+---------+----------+-----------+</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串</p><ul><li>char(length)：定长字符串，定义时指定长度，最大255字节。</li><li>varchar(length)：变长字符串，最大长度65536个字节，一般会自动多加一个字节。实际存储从第二个字节开始，接着要用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。<br>varchar 会保留字符串末尾的空格，而 char 会删除。</li><li>text：存储文字的文本字符串</li><li>blob：存储二进制的文本字符串<br>若数据量非常大（超过255字节），可选用文本字符串。</li><li>枚举字符串：enum()，用于规定数据格式，节省空间（枚举实际存储的是数值）。</li><li>集合字符串：set()，集合存储的也是数值，且可以多选</li></ul></li></ul><table><thead><tr><th>存储数据</th><th>char(4)</th><th>varchar(4)</th><th>char占用字节</th><th>varchar占用字节</th></tr></thead><tbody><tr><td>abcd</td><td>abcd</td><td>abcd</td><td>4x3</td><td>4x3+1</td></tr><tr><td>abcde</td><td>错误</td><td>错误</td><td>超出长度</td><td>超出长度</td></tr></tbody></table><p>如何选择定长或变长字符串？</p><pre><code>* 定长字符串：磁盘空间浪费，但效率高，若数据确定长度一样，就选定长（如身份证，电话号）* 变长字符串：磁盘空间节省，但效率低，若数据长度不确定，就选变长（如住址，姓名）</code></pre><p>枚举字符串举例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table my_enum(sex enum(&apos;m&apos;,&apos;f&apos;));</span><br><span class="line">mysql&gt; insert into my_enum values(&apos;m&apos;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"># 字段赋值必须填枚举中的字符串</span><br><span class="line">mysql&gt; insert into my_enum values(&apos;a&apos;);</span><br><span class="line">ERROR 1265 (01000): Data truncated for column &apos;sex&apos; at row 1</span><br></pre></td></tr></table></figure></p><p>在MySQL中，系统会自动转换数据类型。枚举中字符串是数值的证明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sex+0,sex from my_enum \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">sex+0: 1</span><br><span class="line">  sex: m</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">sex+0: 2</span><br><span class="line">  sex: f</span><br><span class="line"># 由此可知，枚举中字符串的数值是按照枚举顺序从1开始。</span><br><span class="line"># 于是也可以通过数值插入</span><br><span class="line">mysql&gt; insert into my_enum values(1),(2);</span><br><span class="line">Query OK, 2 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure></p><blockquote><p>枚举原理：枚举在进行数据规范（定义）的时候，系统会自动建立一个数字与枚举元素的对应关系（存放在日志），然后在进行数据插入时，系统自动将字符转换成对应的数字存储，在进行数据提取时，系统自动将数值转换成对应字符串显示。</p></blockquote><p>集合字符串举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table my_set(lang set(&apos;c&apos;,&apos;c++&apos;,&apos;python&apos;,&apos;java&apos;));</span><br><span class="line"># 与枚举类似，集合也可通过数值进行赋值</span><br></pre></td></tr></table></figure></p><ul><li>日期和时间<ul><li>date：4字节，1001年到9999年的日期</li><li>datetime：8字节，1001年到9999年的日期，并能保存时间</li><li>timestamp：4字节，1970年1月1日到现在的秒数，最大到2038年</li><li>time：3字节</li><li>year：1字节，最小值1901，最大值2155<br>MySQL提供函数<code>from_unixtime()</code>将unix时间戳转换为时间，<code>unix_timestamp()</code>将日期转换为unix时间戳。<br>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。<br>datetime与时区无关，timestamp与时区有关。</li></ul></li></ul><p>记录长度：<br>任何一条记录的长度最长不能超过65535个字节，一条记录的最长字节数为65534，但可以人为填满。<br>MySQL中text文本字符串不占用记录长度：额外存储，但text字符串也属于记录的一部分，所以一定要占据记录中的部分长度（10字节，保存数据的地址与长度）</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>算数运算符：加、减、乘、除、模<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select 6+4 加,</span><br><span class="line">     6-2 减,</span><br><span class="line">     6*4 乘,</span><br><span class="line">     6/4 除,</span><br><span class="line">     6 DIV 4 除,</span><br><span class="line">     6%4 模,</span><br><span class="line">     6 MOD 4 模;</span><br><span class="line">+----+----+----+--------+------+------+------+</span><br><span class="line">| 加 | 减 | 乘 | 除     | 除   | 模   | 模   |</span><br><span class="line">+----+----+----+--------+------+------+------+</span><br><span class="line">| 10 |  4 | 24 | 1.5000 |    1 |    2 |    2 |</span><br><span class="line">+----+----+----+--------+------+------+------+</span><br><span class="line">当除数为0时，结果为NULL</span><br></pre></td></tr></table></figure></p><p>比较运算符：大于、小于、等于、不等于、IS NULL、BETWEEN AND、IN、LIKE、REGEXP</p><table><thead><tr><th>比较运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;或&gt;=</td><td>大于或大于等于</td></tr><tr><td>&lt;或&lt;=</td><td>小于或小于等于</td></tr><tr><td>=或&lt;=&gt;</td><td>等于</td></tr><tr><td>!=或&lt;&gt;</td><td>不等于</td></tr><tr><td>BETWEEN AND</td><td>在指定范围</td></tr><tr><td>IS NULL</td><td>为空</td></tr><tr><td>IN</td><td>在指定集合</td></tr><tr><td>LIKE</td><td>通配符匹配</td></tr><tr><td>REGEXP</td><td>正则表达式匹配</td></tr></tbody></table><p>常用正则表达式</p><table><thead><tr><th>模式字符</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开始</td><td>‘^a’</td></tr><tr><td>$</td><td>匹配字符串结束</td><td>‘g$’</td></tr><tr><td>.</td><td>匹配字符串中任意一个字符</td><td>‘a.c’</td></tr><tr><td>[字符集合]</td><td>匹配字符集合内的任意一个字符</td><td>‘[abc]’</td></tr><tr><td>[\^字符集合]</td><td>匹配字符集合外的任意一个字符</td><td>‘^abc’</td></tr><tr><td>str1｜str2</td><td>匹配符合的字符串</td><td>‘abc｜cde’</td></tr><tr><td>*</td><td>匹配字符，包含0个和1个</td><td>‘a*‘</td></tr><tr><td>+</td><td>匹配字符，包含1个</td><td>‘a+‘</td></tr><tr><td>字符串{N}</td><td>字符串出现N次</td><td>‘abc{2}’</td></tr><tr><td>字符串(M,N)</td><td>字符串至少出现M次，最多N次</td><td>‘abc(2,3)’</td></tr></tbody></table><p>逻辑运算符<br><code>AND</code>(<code>&amp;&amp;</code>)：与，<code>OR</code>(<code>||</code>)：或，<code>NOT</code>(<code>!</code>)：非，<code>XOR</code>：异或</p><p>位运算符<br><code>&amp;</code>：按位与，<code>|</code>：按位或，<code>~</code>：按位取反，<code>^</code>：按位异或，<code>&lt;&lt;</code>：按位左移，<code>&gt;&gt;</code>：按位右移<br>可使用BIN()函数显示二进制。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>SQL语句的移植性较强，而函数的移植性不强，因为各种数据库软件都有自己特有的函数。<br>Mysql函数分为：</p><ul><li><a href="#字符串函数">字符串函数</a></li><li><a href="#数值函数">数值函数</a></li><li><a href="#日期函数">日期函数</a></li><li><a href="#系统信息函数">系统信息函数</a></li></ul><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>concat(str1,str2…)</td><td>连接字符串</td></tr><tr><td>insert(str,x,y,instr)</td><td>用字符串str的x位置开始y个字符长的子串替换字符串instr</td></tr><tr><td>lower(str)</td><td>将str的所有字符换为小写</td></tr><tr><td>upper(str)</td><td>将str的所有字符换为大写</td></tr><tr><td>left(str,x)</td><td>返回str的最左边的x个字符</td></tr><tr><td>right(str,x)</td><td>返回str的最右边的x个字符</td></tr><tr><td>lpad(str,n,pad)</td><td>使用pad字符串对str最左边进行填充直到长度为n</td></tr><tr><td>rpad(str,n,pad)</td><td>使用pad字符串对str最右边进行填充直到长度为n</td></tr><tr><td>ltrim(str)</td><td>去掉str左边的空格</td></tr><tr><td>rtrim(str)</td><td>去掉str右边的空格</td></tr><tr><td>trim(str)</td><td>去除str行头和行尾的空格</td></tr><tr><td>repeat(str,x)</td><td>返回str重复x次的结果</td></tr><tr><td>replace(str,a,b)</td><td>使用字符串b替换str中所有字符串a</td></tr><tr><td>strcmp(str1,str2)</td><td>比较字符串</td></tr><tr><td>substring(str,x,y)</td><td>返回str中从x位置起y个长度的字符串</td></tr></tbody></table><h4 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>abs(x)</td><td>返回x的绝对值</td></tr><tr><td>ceil(x)</td><td>返回大于x的最小整数值</td></tr><tr><td>floor(x)</td><td>返回小于x的最大整数值</td></tr><tr><td>mod(x)</td><td>返回x%y</td></tr><tr><td>rand()</td><td>返回0-1的随机数</td></tr><tr><td>rand(x)</td><td>返回0-1的随机数，x对应的随机数是固定的</td></tr><tr><td>round(x,y)</td><td>返回x的四舍五入后y位小数的值（y可选）</td></tr><tr><td>truncate(x,y)</td><td>返回x截断为y位小数的值</td></tr></tbody></table><h4 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>curdate()</td><td>获取当前日期</td></tr><tr><td>curtime()</td><td>获取当前时间</td></tr><tr><td>now()</td><td>获取当前日期和时间</td></tr><tr><td>unix_timestamp(date)</td><td>获取date的unix时间戳</td></tr><tr><td>from_unixtime(timestamp)</td><td>获取unix时间戳</td></tr><tr><td>week(date)</td><td>返回date为一年中的第几周</td></tr><tr><td>year(date)</td><td>返回date的年份</td></tr><tr><td>monthname(date)</td><td>返回date的月份</td></tr><tr><td>hour(time)</td><td>返回time的小时值</td></tr><tr><td>minute(time)</td><td>返回time的分钟值</td></tr></tbody></table><h4 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h4><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>version()</td><td>返回版本号</td></tr><tr><td>database()</td><td>返回当前数据库名</td></tr><tr><td>user()</td><td>返回当前用户</td></tr><tr><td>last_insert_id()</td><td>返回最近生成的Auto_Increment值</td></tr></tbody></table><h4 id="特殊功能函数"><a href="#特殊功能函数" class="headerlink" title="特殊功能函数"></a>特殊功能函数</h4><p>|password(str)|对str加密|<br>|format(x,n)|对x格式化，保留n位小数|<br>|inet_aton(ip)|将IP地址转换为数字|<br>|inet_ntoa(x)|将数字转换为IP地址|<br>|get_loct(name,time)|创建一个持续时间time的名为name的锁|<br>|release_loct(name)|对名字为name的锁解锁|<br>|benchmark(count,expr)|将表达式expr执行count次|<br>|convert(s USING cs)|将字符串s的字符集变为cs|<br>|convert(x,type)|将x转为type类型|</p><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><p>创建表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段1 数据类型,</span><br><span class="line">字段2 数据类型,</span><br><span class="line">......</span><br><span class="line">);</span><br><span class="line">也可直接create table 数据库名.表名(); # 这样不需要先进入库，直接建表。</span><br></pre></td></tr></table></figure></p><p>表创建后，数据库文件下会生成对应表的结构文件.frm（与存储引擎有关）。</p><p>查看创建语句<br><code>show create table 表名;</code><br>查看表结构<br><code>desc/show 表名;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc user;</span><br><span class="line"></span><br><span class="line"># field：字段名</span><br><span class="line"># type：字段类型</span><br><span class="line"># null：（列属性）是否允许为空，null不是数据类型</span><br><span class="line"># key：索引：pri主键，uni唯一键</span><br><span class="line"># defalut：（列属性）默认值</span><br><span class="line"># extra：（列属性）扩充属性</span><br></pre></td></tr></table></figure><p>更改表名<br><code>rename table 表名 to 新表名;</code><br>更改表属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 表选项 参数</span><br><span class="line"></span><br><span class="line">表选项:</span><br><span class="line">add column 字段名 数据类型 [位置]; # 新增字段</span><br><span class="line">modify 字段名 数据类型 [属性] [位置]; # 修改字段</span><br><span class="line">change 旧字段 新字段 数据类型 [属性] [位置]; # 重命名字段</span><br><span class="line">drop 字段名; # 删除字段</span><br><span class="line">位置：first：第一个，after 字段：在字段后</span><br></pre></td></tr></table></figure></p><p>删除表<br><code>drop table 表名;</code> 若要删除多张表，用<code>,</code>分隔表名</p><p>表约束：保证数据的合法性</p><ul><li>空属性：NULL（默认），NOT NULL（不为空）<br>  要做到数据不为空，空就没有意义，空数据无法参与运算，所以定义字段时就要设置not null，若字段未指定该选项，当字段为空时，MySQL会用NULL填充，而NULL会占用一个字节，当指定了not null后，该字段必须有值，确保数据准确性。</li><li>列描述comment：无实际含义，描述字段</li><li>默认值default：可在字段设置时添加default ，在插入字段时不赋初值就会使用默认值</li><li><p>主键primary key：一张表只有一个字段可以使用对应键，用来唯一的约束该字段里的数据，不能重复，一张表最多只有一个主键，主键默认不为空（not null）。<br>  增加主键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">法一：在创建字段时就添加primary key 关键字</span><br><span class="line">create table user(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(20)</span><br><span class="line">);</span><br><span class="line">法二：在创建表时，在所有字段后使用primary key(字段名) 创建主键，如有多个字段作为主键，可以是复合主键</span><br><span class="line">create table user(</span><br><span class="line">id int,</span><br><span class="line">name varchar(20),</span><br><span class="line">primary key(id,name)</span><br><span class="line">);</span><br><span class="line">mysql&gt; desc user1;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int(11)     | NO   | PRI | NULL    |       |</span><br><span class="line">| name  | varchar(20) | NO   | PRI | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">法三：追加主键</span><br><span class="line">alter table 表名 add primary key(字段); 或</span><br><span class="line">alter table 表名 modify 字段名 类型 primary key;</span><br><span class="line"># 前提：字段对应数据是独立的（不重复）</span><br></pre></td></tr></table></figure><p>  主键约束：主键字段数据不允许相同，若相同则数据操作失败<br>  主键删除：无法更新主键，只有删除了以后才能再添加<br>  <code>alter table 表名 drop primary key;</code></p><p>  分类</p><pre><code>逻辑主键：字段无业务含义（如id），一般以此类字段做主键业务主键：字段存放业务数据</code></pre></li><li><p>自增长auto-increment：若该字段未赋值或仅有默认值，会自动触发，会给字段值不断+1（当前字段中最大值），形成新字段，常与主键搭配。<br>  <strong>注：</strong> 字段做自增长的前提：本身是一个索引（key属性有值），字段值必须是整型数字。一张表最多只有一个字段自增长。<br>  修改自增长：修改的值必须比该字段当前最大值大(小的话不生效)<br>  <code>alter table 表 auto_increment = x;</code><br>  查看自增长变量<br>  <code>show variables like &#39;auto_increment%&#39;;</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;auto_increment%&apos;;</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| Variable_name            | Value |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">| auto_increment_increment | 1     |</span><br><span class="line">| auto_increment_offset    | 1     |</span><br><span class="line">+--------------------------+-------+</span><br><span class="line">increment为自增长步数</span><br><span class="line">offset为自增长起始值</span><br><span class="line">修改：set auto_increment_increment = x;</span><br><span class="line"># 修改是对整个数据库，且仅是会话级</span><br><span class="line">alter table 表 modify即可修改</span><br></pre></td></tr></table></figure></li><li><p>唯一键unique key：数据不能重复，允许为空，也可多个为空，空字段不参与唯一键比较。</p></li></ul><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><p><strong>数据插入</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名 values(字段1,字段2,...),(字段1,字段2,...),...;</span><br><span class="line"># 插入数据（直接插数据，字段要一一对应）</span><br><span class="line">insert into 表名 (字段1名,字段2名,...) values(字段1,字段2,字段3),...;</span><br><span class="line"># 可指定插入字段，就不用对齐了</span><br></pre></td></tr></table></figure></p><p>若主键冲突，即主键对应的值已存在，插入就会失败。有以下两种解决方法。<br>法一：更新<br><code>insert into 表名(字段(要包含主键)) values() on duplicate key update 字段 = 值;</code><br>法二：替换<br><code>replace into 表名(字段(包含主键)) values();</code></p><p>蠕虫复制：将已有的数据进行新增，数据成倍增加<br>    用法1：从已有表创建新表（仅仅复制表结构）<br>    <code>create table 表名 like 库名.表名;</code><br>    例：<code>mysql&gt; create table user_worm like user;</code><br>    用法2：将查出的数据复制到一张表<br>    <code>insert into 表名(字段) select 字段 from 表名;</code><br>    例：<code>mysql&gt; insert into user_worm (id,name,sex,age) select id,name,sex,age from user;</code><br><strong>蠕虫复制的意义：</strong> 可以快速让表中数据膨胀到一定数量级以测试表的压力与效率</p><p><strong>数据更新</strong><br><code>update 表名 set 字段 = 值 [where] [limit 限制更新数量（前几行）];</code></p><p><strong>数据删除</strong><br><code>delete from 表名 [where];</code><br><strong>数据删除不会改变表的结构，如自增长不会归零，只能删除表后再重建</strong><br><code>truncate 表名;</code> # 先删除该表后再创建该表</p><p><strong>数据查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select [选项] 字段[别名] from 表名 [where][group by][having][order by][limit];</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">all/* ：保留所有结果，默认（尽量不要打印所有）</span><br><span class="line">distinct：去重</span><br><span class="line">别名： 字段名 as 别名</span><br></pre></td></tr></table></figure></p><p>常用关键字：</p><ul><li><code>where</code>：where子句用于过滤满足条件的数据。子句返回结果为0或1。<br>where是唯一一个直接从磁盘读取数据时就开始判断的条件（从读取到第一条数据时就进行判断，成立就保存在内存）。<br>where后的参数</li></ul><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>between…and…</td><td>介于某个范围之内（闭区间）</td></tr><tr><td>not between…and…</td><td>不在某个范围之内</td></tr><tr><td>in(项1,项2…)</td><td>在指定项内</td></tr><tr><td>not in(项1,项2…)</td><td>不在指定项内</td></tr><tr><td>like</td><td>搜索匹配，常与模式匹配符配合使用</td></tr><tr><td>not like</td><td>like的反义</td></tr><tr><td>is null</td><td>空值判断符</td></tr><tr><td>is not null</td><td>非空判断符</td></tr><tr><td>not/and/or</td><td>逻辑运算符，分别表示否、并且、或，用于多个逻辑连接</td></tr><tr><td>%</td><td>模式匹配符，表示任意字串</td></tr></tbody></table><blockquote><p>优先级：NOT &gt; AND &gt; OR</p></blockquote><ul><li><code>group by</code>：根据某字段分组，用于按组统计数据<br>常用统计函数：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count()：统计分组后的记录数</span><br><span class="line">max()：每组中最大值</span><br><span class="line">min()：每组中最小值</span><br><span class="line">avg()：求平均值</span><br><span class="line">sum()：求和</span><br></pre></td></tr></table></figure></li></ul><p>可在<code>group by</code>后加上<code>asc</code>或<code>desc</code>，分别表示升序或降序。<br>若只是分类，并不会显示所有数据，仅仅是分组，列出有哪些组。</p><p>可以设置多个字段进行排序，会按照字段的书写顺序进行先后排序。<br>例如，<code>group by age,score</code>会先对age进行排序，然后对结果再进行score的排序。<br>函数<code>group_concat(字段名)</code>可对分组结果中的某个字段进行字符串的连接。</p><ul><li><p><code>with rollup</code>：回溯统计，根据当前分组字段向上级分组汇报<br>多字段回溯：考虑第一层分组会有回溯，第二层要看第一层分组的组数，组数是多少就回溯几次</p></li><li><p><code>having</code>：进行条件判断<br>在where判断后，由于数据已进入内存，所以不能再用where判断了，要对where判断的结果再次判断，就要用having。having能做where做到几乎所有事情，而where不能做having能做的很多事情。</p></li></ul><p>分组统计的结果只能having使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,score,count(*),group_concat(name) </span><br><span class="line">       from user </span><br><span class="line">       group by score </span><br><span class="line">       having count(*)&gt;=1;</span><br><span class="line">+-------+-------+----------+--------------------+</span><br><span class="line">| id    | score | count(*) | group_concat(name) |</span><br><span class="line">+-------+-------+----------+--------------------+</span><br><span class="line">| 10002 |    68 |        2 | mike,jessie        |</span><br><span class="line">| 10001 |    78 |        3 | jack,kate,lisi     |</span><br><span class="line">| 10006 |    86 |        2 | zhangsan,wangwu    |</span><br><span class="line">| 10005 |    97 |        1 | jason              |</span><br><span class="line">+-------+-------+----------+--------------------+</span><br></pre></td></tr></table></figure></p><ul><li><p><code>order by</code>：排序，依赖校对集，显示所有记录，认升序排序。<br>多字段排序：根据某个字段排序，然后对排序好的结果再按某字段排序</p></li><li><p><code>limit</code>：限制数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">用法1：limit 长度   限制记录数（排名前N个）</span><br><span class="line">mysql&gt; select * from user order by score desc limit 3;</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| id    | name     | sex  | age  | score |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| 10005 | jason    | m    |   22 |    97 |</span><br><span class="line">| 10008 | wangwu   | m    |   20 |    86 |</span><br><span class="line">| 10006 | zhangsan | m    |   21 |    86 |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line"></span><br><span class="line">用法2：limit 起始,长度      从某起始位置（最小为0）开始限制（实现分页）</span><br><span class="line">mysql&gt; select * from user order by score desc limit 4,8;</span><br><span class="line">+-------+--------+------+------+-------+</span><br><span class="line">| id    | name   | sex  | age  | score |</span><br><span class="line">+-------+--------+------+------+-------+</span><br><span class="line">| 10003 | kate   | f    |   19 |    78 |</span><br><span class="line">| 10007 | lisi   | f    |   19 |    78 |</span><br><span class="line">| 10002 | mike   | m    |   21 |    68 |</span><br><span class="line">| 10004 | jessie | f    |   20 |    68 |</span><br><span class="line">+-------+--------+------+------+-------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>关系分为：</strong></p><ul><li>一对一：一张表的一条记录最多只能与另一张表的一条数据对应</li><li>一对多：一张表的一条记录可与另一张表的多条数据对应</li><li>多对多：两张表互相存在一对多关系</li></ul><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><p>也称“并”（UNOIN），多次查询（多条select），在记录上进行拼接。<br>每一条select获取的字段数必须一致，字段名可以不一致，但字段数一定一致。会自动删除重复的记录（所有字段和值全部一致的记录）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 语句1 union select 语句2</span><br><span class="line">union选项：</span><br><span class="line">all       # 保留所有</span><br><span class="line">distinct  # 去重</span><br></pre></td></tr></table></figure></p><p><strong>联合查询的意义：</strong></p><ol><li>查询同一张表，但需求不同  </li><li>多表查询：多张表结构完全一样，保存数据类型也一致</li></ol><blockquote><p>在联合查询中，<strong>order by不能直接使用，必须搭配limit限定最大数</strong></p></blockquote><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; (select id,name,score </span><br><span class="line">    from user </span><br><span class="line">    order by score) </span><br><span class="line">    union </span><br><span class="line">    (select id,name,score </span><br><span class="line">    from stu </span><br><span class="line">    order by score);</span><br><span class="line">+-------+------------+-------+</span><br><span class="line">| id    | name       | score |</span><br><span class="line">+-------+------------+-------+</span><br><span class="line">| 10001 | jack       |    78 |</span><br><span class="line">| 10002 | mike       |    68 |</span><br><span class="line">| 10003 | kate       |    78 |</span><br><span class="line">| 10004 | jessie     |    68 |</span><br><span class="line">| 10005 | jason      |    97 |</span><br><span class="line">| 10006 | zhangsan   |    86 |</span><br><span class="line"></span><br><span class="line">并没有排序，当加上limit 后即可实现排序</span><br><span class="line">mysql&gt; (select id,name,score </span><br><span class="line">    from user </span><br><span class="line">    order by score desc </span><br><span class="line">    limit 999) </span><br><span class="line">    union </span><br><span class="line">    (select id,name,score </span><br><span class="line">    from stu </span><br><span class="line">    order by score desc </span><br><span class="line">    limit 999);</span><br><span class="line">是两张表分别进行排序，然后合并</span><br></pre></td></tr></table></figure></p><h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><p>将多张表进行数据的拼接。<br>分类：内连接（Inner Join），外连接（Outer Join），交叉连接（Cross Join）。<br>连接查询的速度很慢，通常使用子查询。</p><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>从左表中读取每一条记录与右表中所有记录匹配，只保留匹配的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">select 字段 </span><br><span class="line">from 左表 </span><br><span class="line">inner join 右表 </span><br><span class="line">on 左表.字段 = 右表.字段;</span><br></pre></td></tr></table></figure></p><blockquote><p>若这两张表要查询的字段唯一，就不需要加表名。<br>字段别名及表别名的使用：查询数据时，不同表有同名字段，可使用别名。</p></blockquote><p><strong>若内连接不指定on  ，效果会和交叉连接一样。可用where代替on（但where没on效率高）</strong></p><p>内连接根据不同的实现作用又分为：</p><ul><li>自然连接：natural join，仅进行匹配以及去重。不能指定执行过程中的匹配条件。</li><li>等值连接：用<code>=</code>匹配字段值相等的记录</li><li>不等连接：用<code>!=</code>匹配字段值不相等的记录</li></ul><p><strong>注：内连接和外连接都可以模拟自然连接，只要在连接后面加using(字段名)，就可使用同名字段作为连接条件，自动合并</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu join user using(id,name,score);</span><br></pre></td></tr></table></figure></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p>从主表中读取每一条记录与另一张表中所有记录匹配，会保留所有记录<br>以一张表为主，称为主表，根据主表的位置，外连接又分为左连接和右连接。</p><ul><li>左连接left join：以左表为主表</li><li>右连接right join：以右表为主表</li><li>全外连接full outer join：除了匹配的记录，还包括不匹配的记录<br>结果记录数至少为主表的总记录数，副表的为匹配的记录会显示为null<br>显示仍为左连接在表的靠左部分，右连接在表的靠右部分<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">左连接</span><br><span class="line">select 字段 from 左表  </span><br><span class="line">    left|right join 右表</span><br><span class="line">    on 左表.字段 = 右表.字段;</span><br></pre></td></tr></table></figure></li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>虽然可通过连接查询实现多表查询，但性能很慢，因此推荐使用子查询进行多表查询。</p><p><strong>子查询分类：</strong></p><ul><li>按位置分类：子查询在外部查询中出现的位置<ul><li>from子查询：子查询在from之后</li><li>where子查询：在where中</li><li>exist子查询：在exists中</li></ul></li><li>按结果分类：根据子查询得到的结果查询<ul><li>标量子查询：子查询得到的结果是一行一列</li><li>列子查询：结果是一列多行</li><li>行子查询：结果是多列一行（也可以多行多列）</li><li>表子查询：子查询得到的结果是多行多列（出现在from后）</li></ul></li></ul><p><strong>标量子查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from stu_info where id = (select id from stu where id = 20001);</span><br><span class="line">+-------+------------+------------+</span><br><span class="line">| id    | birthday   | birthplace |</span><br><span class="line">+-------+------------+------------+</span><br><span class="line">| 20001 | 1998-07-03 | 河南       |</span><br><span class="line">+-------+------------+------------+</span><br></pre></td></tr></table></figure></p><p><strong>列子查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">关键字IN的子查询</span><br><span class="line">mysql&gt; select * from stu_info </span><br><span class="line">    where birthplace </span><br><span class="line">    in (select birthplace </span><br><span class="line">    from stu_info </span><br><span class="line">    where birthplace = &apos;江苏&apos;);</span><br><span class="line">+-------+------------+------------+</span><br><span class="line">| id    | birthday   | birthplace |</span><br><span class="line">+-------+------------+------------+</span><br><span class="line">| 20003 | 1998-10-03 | 江苏       |</span><br><span class="line">| 20005 | 1998-10-02 | 江苏       |</span><br><span class="line">| 20007 | 1997-11-24 | 江苏       |</span><br><span class="line">+-------+------------+------------+</span><br><span class="line"></span><br><span class="line">关键字ANY（或SOME）的子查询</span><br><span class="line">    三种匹配规则：</span><br><span class="line">    1. = ANY ，与关键字IN作用相同</span><br><span class="line">    2. &gt; ANY（或&gt;=） ，比子查询中记录的最小值大的即可</span><br><span class="line">    3. &lt; ANY（或&lt;=） ，比子查询中记录的最大值小的即可</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from stu </span><br><span class="line">    where score &gt;= ANY (</span><br><span class="line">        select score </span><br><span class="line">        from stu </span><br><span class="line">        where age = 19);</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| id    | name     | sex  | age  | score |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| 20001 | chenning | f    |   20 |    98 |</span><br><span class="line">| 20004 | yunlu    | f    |   19 |    93 |</span><br><span class="line">| 20007 | chenliu  | m    |   20 |    94 |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line"></span><br><span class="line">关键字ALL的子查询</span><br><span class="line">    两种匹配规则：</span><br><span class="line">    1. &gt; ALL ，比子查询中记录的最大值还要大</span><br><span class="line">    2. &lt; ALL ，比子查询中记录的最小值还要小</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from stu </span><br><span class="line">    where score &gt; ALL (</span><br><span class="line">        select score </span><br><span class="line">        from stu where age = 19); </span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| id    | name     | sex  | age  | score |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| 20001 | chenning | f    |   20 |    98 |</span><br><span class="line">| 20007 | chenliu  | m    |   20 |    94 |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line"></span><br><span class="line">关键字EXISTS的子查询</span><br><span class="line">用于判断是否满足（跨表），接在where后，exists返回值只有0和1</span><br><span class="line">    两种匹配：</span><br><span class="line">    1. EXISTS，存在</span><br><span class="line">    2. NOT EXISTS，不存在</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from stu where not exists(select * from stu_info where birthplace = &apos;河南&apos;);</span><br><span class="line">解释：只要不存在河南的学生，就将所有学生信息打印出。EXISTS语句仅仅是判断where中的条件，并不会进行select的输出控制。</span><br></pre></td></tr></table></figure></p><p><strong>行子查询</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from stu </span><br><span class="line">    where (age,score) = (</span><br><span class="line">    select age,score </span><br><span class="line">    from stu where id = 20001);</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| id    | name     | sex  | age  | score |</span><br><span class="line">+-------+----------+------+------+-------+</span><br><span class="line">| 20001 | chenning | f    |   20 |    98 |</span><br><span class="line">+-------+----------+------+------+-------+</span><br></pre></td></tr></table></figure></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>系统通过算法将已有的数据单独建立一个文件，文件能实现快速查找匹配数据<br><strong>作用：</strong>1.提高查询数据效率 2.约束数据的有效性<br><strong>增加索引的前提条件：</strong>因为索引本身会产生文件（较大），所以若某个数据经常使用时就可使用索引。</p><p>根据存储类型，可将索引分为：B树索引（默认索引）和哈希索引。<br>InnoDB和MyISAM引擎都支持B树索引，Memory引擎支持哈希索引</p><p>Mysql支持六种索引：</p><ul><li>普通索引 index</li><li>唯一索引 unique</li><li>全文索引 fulltext index</li><li>单列索引</li><li>多列索引</li><li>空间索引</li></ul><p>以下情况时适合创建索引：</p><ol><li>经常被查询的字段，即where子句出现的字段</li><li>在分组的字段，即group by子句出现的字段</li><li>存在依赖关系的子表和父表间的联合查询，即主键和外键字段</li><li>设置唯一完整性约束的字段</li></ol><p>不适合创建索引的情况：</p><ol><li>查询中很少被使用的字段</li><li>拥有许多重复值的字段</li></ol><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><p>在创建索引时，不附加任何限制条件，可创建在任何数据类型上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 创建表时创建普通索引</span><br><span class="line">create table 表名(</span><br><span class="line">    字段 类型,</span><br><span class="line">    index|key 索引名(字段1(长度) &#123;ASC|DESC&#125;));</span><br><span class="line"></span><br><span class="line">2. 在已存在的表上创建普通索引</span><br><span class="line">create index 索引名</span><br><span class="line">    on 表名 (字段(长度) &#123;ASC|DESC&#125;);</span><br><span class="line"></span><br><span class="line">3. 修改表创建索引</span><br><span class="line">alter table 表名</span><br><span class="line">    add index|key 索引名(字段(长度) &#123;ASC|DESC&#125;);</span><br></pre></td></tr></table></figure><p>用INDEX或KEY参数都可创建索引。索引名与字段关联，可设置索引长度（因为不同存储引擎定义了表的最大索引数和最大索引长度），还可设置升降序。</p><blockquote><p>Mysql支持的存储引擎对每个表支持至少16个索引，总索引长度至少为256字节。</p></blockquote><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>创建索引时，限制索引的值必须唯一。根据创建索引的方式分为：自动索引和手动索引。<br>自动索引：在数据库表中设置完整性约束时，该表会被系统自动创建索引。<br>当设置表中的某个字段设置主键或唯一键完整性约束时，系统会自动关联该字段的唯一索引。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 在创建表时创建唯一索引</span><br><span class="line">create table 表名(</span><br><span class="line">    字段 类型,</span><br><span class="line">    unique index|key 索引名(字段(长度) &#123;ASC|DESC&#125;);</span><br><span class="line"></span><br><span class="line">2. 在已存在的表上创建唯一索引</span><br><span class="line">create unique index 索引名</span><br><span class="line">    on 表名(字段(长度) &#123;ASC|DESC&#125;);</span><br><span class="line"></span><br><span class="line">3. 修改表创建索引</span><br><span class="line">alter table 表名</span><br><span class="line">    add unique index|key 索引名(字段(长度) &#123;ASC|DESC&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h3><p>针对文章内部的关键字进行索引，表引擎必须为MyISAM。<br>主要用于关联数据类型为char、varchar、text的字段，以便能够更加快速地查询数据量较大的字符串类型的字段。<br>默认情况全文索引搜索不区分大小写，若全文索引所关联的字段为二进制类型，则以区分大小写搜索。</p><p><strong>注：不要在导入数据时使用fulltext，应该在导入后使用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. 创建表时创建全文索引</span><br><span class="line">create table 表名(</span><br><span class="line">    字段 属性,</span><br><span class="line">    fulltext index|key 索引名(字段(长度) &#123;ASC|DESC&#125;))engine=MYISAM;</span><br><span class="line"></span><br><span class="line">2. 在已存在的表上创建全文索引</span><br><span class="line">create fulltext index 索引名</span><br><span class="line">    on 表名(字段(长度) &#123;ASC|DESC&#125;);</span><br><span class="line"></span><br><span class="line">3. 修改表创建索引</span><br><span class="line">alter table 表名</span><br><span class="line">    add fulltext index|key 索引名(字段(长度) &#123;ASC|DESC&#125;);</span><br></pre></td></tr></table></figure></p><p>全文索引操作符：</p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td>+</td><td>包含</td></tr><tr><td>-</td><td>排除</td></tr><tr><td>&lt;</td><td>包含且增加等级</td></tr><tr><td>&gt;</td><td>包含且减少等级</td></tr><tr><td>( )</td><td>表达式</td></tr><tr><td>*</td><td>词尾通配符</td></tr><tr><td>“ “</td><td>字符串</td></tr></tbody></table><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>在创建索引时所关联的字段不是一个字段，而是多个字段。只有查询条件使用了关联字段的第一个字段，多列字段才会被使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 创建表时创建多列索引</span><br><span class="line">create table 表名(</span><br><span class="line">    字段 类型,</span><br><span class="line">    index|key 索引名(</span><br><span class="line">        字段1(长度) &#123;ASC|DESC&#125;,</span><br><span class="line">        ...</span><br><span class="line">        字段n(长度) &#123;ASC|DESC&#125;);</span><br><span class="line"></span><br><span class="line">2. 在已存在的表上创建多列索引</span><br><span class="line">create index 索引名</span><br><span class="line">    on 表名 (</span><br><span class="line">        字段1(长度) &#123;ASC|DESC&#125;,</span><br><span class="line">        ...</span><br><span class="line">        字段n(长度) &#123;ASC|DESC&#125;);</span><br><span class="line"></span><br><span class="line">3. 修改表创建索引</span><br><span class="line">alter table 表名</span><br><span class="line">    add index|key 索引名(</span><br><span class="line">        字段1(长度) &#123;ASC|DESC&#125;,</span><br><span class="line">        ...</span><br><span class="line">        字段n(长度) &#123;ASC|DESC&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>本质是一种虚拟表，内容与真实表相似，但并不在数据库中以存储的数据值形式存在，数据来自自定义视图的查询所引用基本表，并在具体引用视图时动态生成。</p><p>创建视图：<code>create view 视图名 as select语句;</code><br><strong>注：有多张基表时，要保证字段名不同，可用别名区分</strong><br>修改视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 使用ALTER语句修改视图</span><br><span class="line">alter view 视图名 </span><br><span class="line">    as select语句;</span><br><span class="line"></span><br><span class="line">2. 使用CREATE OR REPLACE语句修改视图</span><br><span class="line">create or replace view 视图名</span><br><span class="line">    as select 语句;</span><br><span class="line">这个方式修改视图会在视图存在的情况下直接修改，而若不存在就创建视图。</span><br></pre></td></tr></table></figure></p><p>删除视图：<code>drop view 视图名;</code></p><p><strong>可以向单表中插数据，但不能向多表插数据，且插入数据只能插视图中有的字段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看视图</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">查看视图详细信息</span><br><span class="line">show table status (from 数据库);</span><br><span class="line"></span><br><span class="line">查看视图定义信息</span><br><span class="line">show create view 视图名;</span><br><span class="line"></span><br><span class="line">查看视图设计信息</span><br><span class="line">desc 视图名;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器的执行是由事件来触发、激活从而实现执行。为某张表绑定一段代码，当对表操作时，就会触发代码执行。<br>触发器由三部分组成：</p><ul><li>事件类型：增删改–insert、delete、update</li><li>触发时间：before、after</li><li>触发对象：表中记录<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">创建触发器：</span><br><span class="line">create trigger 触发器名</span><br><span class="line">    before|after 触发事件</span><br><span class="line">    on 表名 for each row </span><br><span class="line">    触发后动作;</span><br><span class="line"># for each row 表示任何一条记录上的操作满足触发事件</span><br><span class="line"># 后面跟上的是激活触发器后执行的语句</span><br><span class="line"></span><br><span class="line">创建包含多条执行语句的触发器：</span><br><span class="line">create trigger 触发器名</span><br><span class="line">    before|after 触发事件</span><br><span class="line">    on 表名 for each row</span><br><span class="line">    begin</span><br><span class="line">        触发后动作</span><br><span class="line">    end</span><br><span class="line"># 在BEGIN和END间因为有多条语句需要使用分号隔开</span><br><span class="line"># 而在mysql中默认分号为结束，因此需要在创建触发器前将结束符重新设置，并在创建完成后再将触发器设置回分号。</span><br><span class="line">delimiter 结束符</span><br><span class="line"></span><br><span class="line">删除触发器</span><br><span class="line">drop trigger 触发器名;</span><br><span class="line"></span><br><span class="line">查看触发器</span><br><span class="line">show triggers;</span><br><span class="line"></span><br><span class="line">mysql&gt; show triggers\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">             Trigger: my_trigger1        # 触发器名</span><br><span class="line">               Event: INSERT             # 触发事件</span><br><span class="line">               Table: stu                # 操作表</span><br><span class="line">           Statement: begin              # 激活触发器后的动作</span><br><span class="line">insert into stu_journal values(&apos;insert&apos;,now());</span><br><span class="line">end</span><br><span class="line">              Timing: AFTER              # 触发器执行的时间</span><br><span class="line">             Created: 2018-07-08 14:10:54.01</span><br><span class="line">            sql_mode: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">             Definer: root@localhost</span><br><span class="line">character_set_client: gbk</span><br><span class="line">collation_connection: gbk_chinese_ci</span><br><span class="line">  Database Collation: utf8_general_ci</span><br><span class="line"></span><br><span class="line">查看系统表triggers中所有记录</span><br><span class="line">select * from information_schema.triggers\G</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from information_schema.triggers </span><br><span class="line">    where trigger_name=&apos;my_trigger1&apos;\G</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           TRIGGER_CATALOG: def</span><br><span class="line">            TRIGGER_SCHEMA: test</span><br><span class="line">              TRIGGER_NAME: my_trigger1</span><br><span class="line">        EVENT_MANIPULATION: INSERT</span><br><span class="line">      EVENT_OBJECT_CATALOG: def</span><br><span class="line">       EVENT_OBJECT_SCHEMA: test</span><br><span class="line">        EVENT_OBJECT_TABLE: stu</span><br><span class="line">              ACTION_ORDER: 1</span><br><span class="line">          ACTION_CONDITION: NULL</span><br><span class="line">          ACTION_STATEMENT: begin</span><br><span class="line">insert into stu_journal values(&apos;insert&apos;,now());</span><br><span class="line">end</span><br><span class="line">        ACTION_ORIENTATION: ROW</span><br><span class="line">             ACTION_TIMING: AFTER</span><br><span class="line">ACTION_REFERENCE_OLD_TABLE: NULL</span><br><span class="line">ACTION_REFERENCE_NEW_TABLE: NULL</span><br><span class="line">  ACTION_REFERENCE_OLD_ROW: OLD</span><br><span class="line">  ACTION_REFERENCE_NEW_ROW: NEW</span><br><span class="line">                   CREATED: 2018-07-08 14:10:54.01</span><br><span class="line">                  SQL_MODE: STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br><span class="line">                   DEFINER: root@localhost</span><br><span class="line">      CHARACTER_SET_CLIENT: gbk</span><br><span class="line">      COLLATION_CONNECTION: gbk_chinese_ci</span><br><span class="line">        DATABASE_COLLATION: utf8_general_ci</span><br></pre></td></tr></table></figure></li></ul><h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><p>一个完整的操作会包含 多条SQL语句，在执行过程中需要根据前面的SQL语句的执行结果有选择的执行后面的SQL语句。<br>存储过程与函数可理解为一条或多条SQL语句的集合，且也是事先经过编译并存储在数据库中的一段SQL语句集合，是一种没有返回值的函数。</p><p><strong>存储过程与函数的优点：</strong></p><ul><li>允许表春组件式编程，提高了SQL语句的重用性、共享性、可移植性</li><li>实现较快执行速度，减少网络流量</li><li>可被作为一种安全机制</li></ul><p>缺点：</p><ul><li>编写复杂</li><li>需要创建数据库对象的权限</li></ul><p>存储过程和函数的区别：</p><ul><li>函数必须有返回值，存储过程没有</li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">delimiter 结束符</span><br><span class="line">create procedure 过程名(procedure_parameter参数)</span><br><span class="line">    characteristic特性</span><br><span class="line">    begin</span><br><span class="line">        过程体</span><br><span class="line">    end 结束符</span><br><span class="line">delimiter ;</span><br><span class="line">与触发器类似，同样需要先用delimiter修改结束符</span><br></pre></td></tr></table></figure><p>其中procedure_parameter参数的格式如下<br><code>输入/输出类型 参数名 参数类型</code></p><p>输入输出类型有三种</p><ul><li>IN：输入类型，数据只从外部传入内部，可是数值也可是变量。存储过程可能会修改这个值，但是对于调用者来说，在存储过程返回结果时，所做的修改是不可见的。</li><li>OUT：输出类型，只允许过程使用内部数据，外部传入内部只能是变量。其初始值为NULL，当存储过程返回时，这个值对调用者来说是可见的。</li><li>INOUT：输入输出类型，外部可在内部使用，内部修改也可在外部使用，只能传变量，存储过程可能会修改这个值，当存储过程返回的时候，所做的修改对调用者来说是可见的。</li></ul><p>参数类型可为Mysql支持的任何类型</p><p>characteristic特性的可选参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[NOT] DETERMINSTIC：存储过程的执行结果是否确定</span><br><span class="line"># DETERMINSTIC表示确认，加NOT则为不确认</span><br><span class="line"></span><br><span class="line">&#123;CONTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA&#125;：表示使用SQL语句的限制</span><br><span class="line"># CONTAINS SQL：表示可包含SQL，但不包含读或写数据的语句</span><br><span class="line"># NO SQL：表示不包含SQL语句</span><br><span class="line"># READS SQL DATA：表示包含读数据语句</span><br><span class="line"># MODIFIES SQL DATA：表示包含写数据语句</span><br><span class="line"># 默认为CONTAINS SQL</span><br><span class="line"></span><br><span class="line">SQL SECURITY &#123;DEFINER|INVOKER&#125;：表示谁有权限执行</span><br><span class="line"># DEFINER：表示只有定义者自己能执行</span><br><span class="line"># INVOKER：表示调用者都可执行</span><br><span class="line"># 默认为DEFINER</span><br><span class="line"></span><br><span class="line">COMMENT 注释</span><br></pre></td></tr></table></figure></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line">create procedure proce_sel_stu(in stuid int)</span><br><span class="line">comment &apos;显示stu表指定学号的学生姓名和成绩&apos;</span><br><span class="line">bgein</span><br><span class="line">    select name,score from stu where id=stuid;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure></p><p>使用<code>call 存储过程名(参数);</code>对存储过程的调用。</p><p><strong>查看存储过程</strong><br>查看存储过程创建语句<br><code>show create procedure 存储过程名\G</code><br>查看存储过程状态信息<br><code>show procedure status like &#39;过程名&#39;\G</code></p><p>在<code>information_schema</code>库中存在一张存储所有存储过程和函数的表<code>routines</code>，因此此表也可查看存储过程和函数。</p><p><strong>修改存储过程</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter procedure 过程名</span><br><span class="line">  特性</span><br></pre></td></tr></table></figure></p><p>存储过程不能修改过程体，只能删除后重新创。<br><strong>删除存储过程</strong><br><code>drop procedure 存储过程名;</code></p><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建函数</span><br><span class="line">delimiter 结束符</span><br><span class="line">create function 函数名(参数)</span><br><span class="line">  returns 返回数据类型</span><br><span class="line">  特性</span><br><span class="line">  begin</span><br><span class="line">    函数体</span><br><span class="line">  end结束符</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"># 特性与存储过程一致</span><br><span class="line"># 参数不用指定输入输出</span><br></pre></td></tr></table></figure><p><strong>注：函数不存在“重写”，即函数名不能相同。并且推荐函数名的格式为func_XXX或function_XXX</strong><br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create function func_sel_stu(stuid int)</span><br><span class="line">  returns int</span><br><span class="line">  begin</span><br><span class="line">    return (select score from stu where id=stuid);</span><br><span class="line">  end $$</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure></p><p>使用<code>select 函数(参数);</code>调用函数。</p><p><strong>查看函数</strong><br>查看函数创建函数<br><code>show create function 函数名\G</code><br>查看函数状态信息<br><code>show function status like &#39;函数名&#39;\G</code><br><strong>修改函数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter function 函数名</span><br><span class="line">  特性</span><br></pre></td></tr></table></figure></p><p>存储过程不能修改函数体，只能删除后重新创。<br><strong>删除函数</strong><br><code>drop function 函数名;</code></p><h3 id="存储过程和函数表达式"><a href="#存储过程和函数表达式" class="headerlink" title="存储过程和函数表达式"></a>存储过程和函数表达式</h3><ul><li>变量<br>使用<code>declare 变量名（可多个，逗号分隔） 类型 [默认值]</code>声明变量<br>使用<code>set 变量名=XX（可以是值，也可以是赋值表达式，可多个，逗号分隔）;</code>赋值变量<br>也可以通过<code>select 字段 into 变量（可多个） from ...;</code>将查询结果赋给变量。<br><strong>注：将查询结果赋值给变量时，该查询语句的返回结果只能是单行</strong></li><li>条件<br>条件用于提高安全性。条件用于定义在处理过程中遇到问题时相应的处理步骤。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">定义条件</span><br><span class="line">declare 条件名 condition for condition_value状态值</span><br><span class="line"></span><br><span class="line">状态值：</span><br><span class="line">mysql_error_code     mysql错误值</span><br><span class="line">SQLSTATE[VALUE] sqlstate_value   指定sql状态</span><br><span class="line">不要使用mysql error code 0或以‘00’开头的code或一个SQLSTATE，因为这些指示成功而不是一个错误条件。</span><br><span class="line"></span><br><span class="line">定义处理</span><br><span class="line">delimiter 结束符</span><br><span class="line">declare 处理类型 handler </span><br><span class="line">  for 状态值（可多个）</span><br><span class="line">  begin</span><br><span class="line">    处理</span><br><span class="line">  end 结束符</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">处理类型，即当handler被触发后需要执行什么动作</span><br><span class="line">1. CONTINUE：继续执行</span><br><span class="line">2. EXIT：终止程序</span><br><span class="line">3. UNDO</span><br><span class="line"></span><br><span class="line">状态值，handler触发的条件：</span><br><span class="line">1. mysql error code或SQLSTATE value</span><br><span class="line">2. 定义条件时的条件名</span><br><span class="line">3. SQLWARNING：代表所有以01开头的SQLSTATE</span><br><span class="line">4. NOT FOUND：代表所有以02开头的SQLSTATE</span><br><span class="line">5. SQLEXCEPTION：代表除01和02开头的SQLSTATE</span><br></pre></td></tr></table></figure></li></ul><p><a href="https://www.cnblogs.com/mqxs/p/6019992.html" target="_blank" rel="noopener">详细SQLSTATE表</a></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE no_such_table CONDITION FOR 1051;</span><br><span class="line">DECLARE CONTINUE HANDLER FOR no_such_table</span><br><span class="line">  BEGIN</span><br><span class="line">    -- body of handler</span><br><span class="line">  END;</span><br></pre></td></tr></table></figure></p><ul><li>游标<br>指定由select语句返回的行集合结果集，并遍历该结果集，可看做一种数据类型，类似指针或数组下标。<br>使用<code>declare 游标名 cursor for select语句;</code>声明游标<br>使用<code>open 游标名</code>打开游标。打开时，游标指向的是第一条数据的前一位。<br>使用<code>fetch 游标名 into 变量名（可多个，逗号分隔）</code>使用游标，遍历赋值给变量。<br>使用<code>close 游标名</code>关闭游标</li><li>流程控制<br>条件控制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if条件分支</span><br><span class="line">if 条件 then</span><br><span class="line">  执行语句</span><br><span class="line">elseif</span><br><span class="line">  执行语句</span><br><span class="line">else</span><br><span class="line">  执行语句</span><br><span class="line">end if;</span><br><span class="line"></span><br><span class="line">case条件分支</span><br><span class="line">case 条件判断的变量</span><br><span class="line">  when 条件 then 执行语句</span><br><span class="line">  when 条件 then 执行语句</span><br><span class="line">end case</span><br></pre></td></tr></table></figure></li></ul><p><strong>注：创建条件控制需要修改语句结束符</strong><br>循环控制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[标签:]where 条件 do</span><br><span class="line">  执行语句</span><br><span class="line">end where[标签];</span><br><span class="line"></span><br><span class="line">循环控制：循环内部进行循环判断和控制</span><br><span class="line">interate：迭代，类似continue</span><br><span class="line">leave：离开，类似break</span><br><span class="line"></span><br><span class="line">[标签:]where 条件 do</span><br><span class="line">  执行语句</span><br><span class="line">  leave | interate 循环名;</span><br><span class="line">end where[标签];</span><br><span class="line"></span><br><span class="line">[标签:]loop</span><br><span class="line">  执行语句</span><br><span class="line">end loop[标签]</span><br><span class="line"></span><br><span class="line">[标签:]repeat 条件 do</span><br><span class="line">  执行语句</span><br><span class="line">end repeat[标签]</span><br><span class="line"></span><br><span class="line">可使用标签，两个标签分别代表循环的开始和结束，但必须一致，也可省略</span><br><span class="line">若要退出循环，使用leave 标签</span><br></pre></td></tr></table></figure></p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>为保证数据库记录的更新从一个一致性状态变更为另一个一致性状态。<br>事务的四个特性：</p><ul><li>原子性：事务中所有操作视为一个原子单元，对事务所进行的数据修改等操作只能是完全提交或完全回滚。</li><li>一致性：事务完成时，所有变更必须应用于事务的修改</li><li>隔离性：一个事务中的操作必须与其他事务所做的修改隔离，当前事务不会查看由另一个并发事务正在修改的数据（通过锁机制实现）</li><li>持久性：事务完成后，所做的所有修改对数据的影响是永久的</li></ul><p><strong>InnoDB支持事务，而MyISAM不支持事务</strong><br>事务安全：保护连续操作同时满足。意义：保证数据操作的完整性<br>事务操作分为：自动事务（默认），手动事务</p><p><strong>手动事务：</strong></p><ul><li>开启事务：告诉系统以下所有操作不直接写入数据表，先放到事务日志中。<br><code>start transaction;</code>或<code>begin;</code><br>此后的操作会保存在事务日志中，并不是真的对操作了数据表，所以若再通过另一个命令行用户登录查看时，该数据是未被操作的。</li><li>关闭事务：选择性的将日志文件中操作的结果同步到数据表<br>包含两个操作：</li></ul><ol><li>提交事务<code>commit</code>：同步数据表，操作成功     </li><li>回滚事务<code>rollback</code>：直接清空日志表，操作失败</li></ol><p><strong>自动事务：</strong><br>通过autocommit变量控制<br>查看自动事务状态<code>show variables like &#39;autocommit&#39;;</code>默认开启<br><code>set autocommit = off;</code>关闭事务自动提交。关闭自动后，需要手动选择处理提交或回滚</p><p>事务原理：<br>事务开启后，所有操作临时保存在事务日志，只有在commit时才会同步到数据表，其他情况都会导致清空。<br>其中日志文件分为两个：</p><ul><li>REDO日志：记录事务日志。每条SQL进行数据库更新操作时，首先将REDO日志写入到日志缓存区中。当客户端执行COMMIT命令提交时，日志缓冲区的内容被刷新到磁盘。<br>REDO日志对应<code>ib_logfile</code>文件，默认大小5MB，建议设置为512MB以便容纳较大的事务。<br>在Mysql崩溃恢复时，会重新执行REDO日志记录。</li><li>UNDO日志：也称为回滚段。用于事务异常时的回滚处理，复制事务前得到数据库内容到UNDO缓冲区，然后在合适的时间将内容刷新到磁盘。磁盘上不存在单独的UNDO日志文件，而是存放在表空间对应的<code>.ibd</code>数据文件中。</li></ul><p>回滚点：在某个成功的操作完成后，后续的操作可能成功可能失败，可以自当前成功的位置设置一个点，可以供后续失败操作返回到该位置，而不是返回所有操作。<br><code>savepoint  回滚点名;</code><br><code>rollback  回滚点名;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用start transaction 或 begin开启事务</span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">mysql&gt; update stu set age=22 where id=20007;</span><br><span class="line">mysql&gt; commit;    或</span><br><span class="line">mysql&gt; rollback;</span><br></pre></td></tr></table></figure></p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL定义了4种隔离级别，指定了事务中哪些数据改变其他事务可见，哪些数据改变其他事务不可见。<br>低隔离级别可支持更高并发处理，同时占用的系统资源更少。<br>可通过<code>show variables like &#39;tx_isolation&#39;</code>查看当前事务隔离级别。</p><ul><li><code>READ-UNCOMMITTED</code>：读取未提交内容，所有事务都可以看到其他未提交事务的执行结果。读取未提交的数据称为<strong>脏读</strong>。<br>开启A与B事务，A更新，B不操作，但A在提交前，B能读到更新后的数据，而此时A回滚了，也就是B还是读到了错误的数据。</li><li><code>READ-COMMITTED</code>：读取提交内容，一个事务从开始到提交前所做的任何改变都是不可见的，事务只能看见已经提交的变化。同一事务的其他实例在该实例处理时可能会有新的数据提交导致数据改变，所以同一查询可能返回不同结果。</li><li><code>REPEATABLE-READ</code>：可重读，Mysql默认事务隔离级别。确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。<br>存在问题：A的操作对表中所有行，B的操作是添加一行，于是A会发现有一行没有被修改。这个问题称为幻读。<br>解决：InnoDB的多版本并发控制MVCC机制。InnoDB通过为每个数据行增加两个隐含值的方式实现，两个隐含值记录行的创建时间和过期时间。每行记录事件发生时的系统版本号。每一次开始一个新事务时版本号会自动加1，每个事务保存开始时的版本号，每个查询根据事务的版本号查询结果。</li><li><code>SERIALIZABLE</code>：可串行化。最高的隔离级别。通过强制事务排序，使各事务不可能冲突。通过在每个读的数据行上加上共享锁实现。不推荐使用。</li></ul><h3 id="InnoDB锁机制"><a href="#InnoDB锁机制" class="headerlink" title="InnoDB锁机制"></a>InnoDB锁机制</h3><p>锁机制：为解决数据库并发控制问题，保证数据一致性，需要对并发操作控制，并实现Mysql各个隔离级别。<br>有以下类型：</p><ul><li>共享锁：S（Share），锁粒度是单行或多行。一个事务获取了共享锁后，可对锁定范围内的数据执行读操作。<br>事务A与B，若A获取了共享锁，B仍可获得共享锁，但不能获得排他锁。<br>若A获得了排他锁，B不能获得共享锁和排他锁。</li><li>排他锁：X（eXclusive），排他锁的粒度与共享锁相同。事务获取排他锁后，可对锁定范围的数据执行写操作。</li><li>意向锁：一种表锁，粒度为整张表。分为意向共享锁IS和意向排他锁IX。<br>表示一个事务有意对数据上共享锁或排他锁。锁与锁之间的关系，要么相容，要么互斥。<br>相容：事务A获得了锁a，事务B还可获得锁b<br>互斥：事务A获得了锁a，事务B在A释放a之前不能获得锁b</li></ul><p><strong>锁粒度</strong><br>锁粒度分为表锁和行锁。<br>innodb默认是行锁，但如果在事务操作的过程中，没有使用索引，那么系统会自动全表检索数据，自动升级为表锁。<br>行锁：只有当前行被锁住，别的用户不能操作。行锁支持最大并发。InnoDB使用行锁。支持并发读写。<br>表锁：整张表被锁住，别的用户不能操作。开销最小，允许的并发量也最小。MyISAM使用表锁。<br>当行或表被锁住时，若另一用户也要更改就只能等待锁被解除（commit或rollback），否则无法操作成功。</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="权限机制"><a href="#权限机制" class="headerlink" title="权限机制"></a>权限机制</h3><p>三张关于权限的表，存放在<code>mysql</code>库中。</p><ul><li>user</li><li>db</li><li>host</li></ul><h4 id="mysql-user表"><a href="#mysql-user表" class="headerlink" title="mysql.user表"></a>mysql.user表</h4><p>一共有45个字段，可分为4类：用户字段、权限字段、安全字段、资源控制字段</p><ul><li>用户字段<br>三个字段：host主机名，user用户名，password密码</li><li>权限字段<br>一系列以<code>_priv</code>结尾的字段，这些字段决定了权限。两个返回值，Y和N，默认为N。</li></ul><table><thead><tr><th>字段</th><th>权限名</th><th>权限范围</th></tr></thead><tbody><tr><td>Select_priv</td><td>select</td><td>查询表</td></tr><tr><td>Insert_priv</td><td>insert</td><td>插入表</td></tr><tr><td>Update_priv</td><td>update</td><td>更新表</td></tr><tr><td>Delete_priv</td><td>delete</td><td>删除表</td></tr><tr><td>Create_priv</td><td>create</td><td>库、表、索引</td></tr><tr><td>Drop_priv</td><td>drop</td><td>库、表</td></tr><tr><td>Reload_priv</td><td>reload</td><td>库、表</td></tr><tr><td>Shutdown_priv</td><td>shutdown</td><td>关闭服务器</td></tr><tr><td>Process_priv</td><td>process</td><td>服务器管理</td></tr><tr><td>File_priv</td><td>file</td><td>加载服务器主机的文件</td></tr><tr><td>Grant_priv</td><td>grant</td><td>库、表、存储过程、函数</td></tr><tr><td>References_priv</td><td>references</td><td>库、表</td></tr><tr><td>Index_priv</td><td>index</td><td>用索引查表</td></tr><tr><td>Alter_priv</td><td>alter</td><td>修改表</td></tr><tr><td>Show_db_priv</td><td>show databases</td><td>服务器</td></tr><tr><td>Super_priv</td><td>super</td><td>超级权限</td></tr><tr><td>Create_tmp_table_priv</td><td>create temporary tables</td><td>临时表</td></tr><tr><td>Lock_tables_priv</td><td>lock tables</td><td>锁定表</td></tr><tr><td>Execute_priv</td><td>execute</td><td>执行存储过程或函数</td></tr><tr><td>Repl_slave_priv</td><td>replication slave</td><td>服务器管理</td></tr><tr><td>Repl_client_priv</td><td>replication client</td><td>服务器管理</td></tr><tr><td>Create_view_priv</td><td>create view</td><td>创建视图</td></tr><tr><td>Show_view_priv</td><td>show view</td><td>查看视图</td></tr><tr><td>Create_routine_priv</td><td>create routine</td><td>创建存储过程或函数</td></tr><tr><td>Alter_routine_priv</td><td>alter routine</td><td>修改存储过程或函数</td></tr><tr><td>Create_user_priv</td><td>create user</td><td>创建用户</td></tr><tr><td>Event_priv</td><td>event</td><td>计时器</td></tr><tr><td>Trigger_priv</td><td>create trigger</td><td>触发器</td></tr><tr><td>Create_tablespace_priv</td><td>create tablespace</td><td>创建表空间</td></tr></tbody></table><ul><li>安全字段<br>用于判断用户是否能够登录成功</li></ul><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>ssl_type</td><td>支持ssl加密的安全字段</td></tr><tr><td>ssl_cipher</td><td>支持ssl加密的安全字段</td></tr><tr><td>x509_issuer</td><td>支持x509的字段</td></tr><tr><td>x509_subject</td><td>支持x509的字段</td></tr></tbody></table><p>可通过以下方式查看是否字段支持ssl加密<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;have_openssl&apos;;</span><br><span class="line">+---------------+----------+</span><br><span class="line">| Variable_name | Value    |</span><br><span class="line">+---------------+----------+</span><br><span class="line">| have_openssl  | DISABLED |</span><br><span class="line">+---------------+----------+</span><br></pre></td></tr></table></figure></p><ul><li>资源控制字段</li></ul><table><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td>max_questions</td><td>每小时允许执行多少次查询</td></tr><tr><td>max_updates</td><td>每小时允许执行多少次更新</td></tr><tr><td>max_connections</td><td>每小时允许建立多少次连接</td></tr><tr><td>max_user_connections</td><td>单个用户可同时具有的连接数</td></tr></tbody></table><p>所有资源控制字段的默认值为0，表示是没有限制。</p><h3 id="用户机制"><a href="#用户机制" class="headerlink" title="用户机制"></a>用户机制</h3><p>包括：登录和退出Mysql，创建用户，删除用户，修改用户密码，修改用户权限等。</p><p>连接Mysql服务器的命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql </span><br><span class="line">  -h Mysql服务器的地址，可用域名，也可用IP地址</span><br><span class="line">  -p 指定所连接Mysql服务器的端口，默认3306</span><br><span class="line">  -u 登录Mysql使用的用户</span><br><span class="line">  -p 将提示输入密码</span><br><span class="line">  DBname 指定登录到的库</span><br><span class="line">  -e 指定执行的SQL语句</span><br></pre></td></tr></table></figure></p><p>对用户的操作：</p><ul><li><p><strong>创建用户：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. create user 用户名[@主机] [identified by &quot;密码&quot;];</span><br><span class="line"></span><br><span class="line">2. insert into mysql.user(Host,User,Password) values(主机名,用户名,PASSWORD(&quot;密码&quot;));</span><br><span class="line"># 要使用PASSWORD()对密码加密</span><br><span class="line"></span><br><span class="line">3. grant 权限 on 库.表 to 用户名[@主机] [identified by &quot;密码&quot;];</span><br><span class="line">在赋予权限后，要flush privileges;刷新权限</span><br></pre></td></tr></table></figure></li><li><p><strong>修改用户账户密码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. mysqladmin -u 用户名 -p 原密码 &quot;新密码&quot;</span><br><span class="line"># 新密码必须用双引号括起来</span><br><span class="line"></span><br><span class="line">2. set password=PASSWORD(&quot;新密码&quot;);</span><br><span class="line"># 修改当前登录用户的密码（即只修改自己的密码）</span><br><span class="line"></span><br><span class="line">3. update mysql.user set password=PASSWORD(&quot;新密码&quot;) where user=&quot;用户名&quot; and host=&quot;localhost&quot;;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改普通用户账户密码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. grant 权限 on 库.表 to 用户名 [identified by &quot;密码&quot;];</span><br><span class="line"></span><br><span class="line">2. set password for 用户名[@主机]=PASSWORD(&quot;新密码&quot;);</span><br><span class="line"></span><br><span class="line">3. update mysql.user set password=PASSWORD(&quot;新密码&quot;) where user=&quot;用户名&quot; and host=&quot;主机名&quot;;</span><br><span class="line"></span><br><span class="line">4. set password=PASSWORD(&quot;新密码&quot;);</span><br><span class="line"># 修改当前登录用户的密码（即只修改自己的密码）</span><br></pre></td></tr></table></figure></li><li><p><strong>删除普通用户账号：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. drop user 用户名1,用户名2....</span><br><span class="line"></span><br><span class="line">2. delete from mysql.user where user=&quot;用户名&quot; and host=&quot;主机&quot;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="对用户的权限管理"><a href="#对用户的权限管理" class="headerlink" title="对用户的权限管理"></a>对用户的权限管理</h3><ul><li><p><strong>对用户授权：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grant 权限 on 库.表 to 用户 [identified by &quot;密码&quot;] with 选项;</span><br><span class="line"># with后有以下选项：</span><br><span class="line">GRANT OPTION：被授权用户可将权限授权给其他用户</span><br><span class="line">MAX_QUERIES_PER_HOUR count：设置每小时可执行count次查询</span><br><span class="line">MAX_UPDATES_PER_HOUR count：设置每小时可执行count次更新</span><br><span class="line">MAX_CONNECTIONS_PER_HOUR count：设置每小时可建立count次查询</span><br><span class="line">MAX_USER_CONNECTIONS count：设置单个用户可同时具有count个连接</span><br></pre></td></tr></table></figure></li><li><p><strong>查看用户拥有权限：</strong><br><code>show grant for 用户名[@主机];</code></p></li><li><strong>收回用户拥有权限：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限 on 库.表 from 用户名 [identified by &quot;密码&quot;];</span><br><span class="line"></span><br><span class="line">若要直接回收全部权限，可使用以下语句</span><br><span class="line">revoke all privileges,grant option from 用户名 [identified by &quot;密码&quot;];</span><br></pre></td></tr></table></figure></li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>Mysql日志分为：</p><ul><li>二进制日志：以二进制形式记录数据库的各种操作，但不记录查询语句</li><li>错误日志：记录Mysql服务器启动、关闭、运行时的错误信息</li><li>通用查询日志：记录Mysql启动和关闭信息、客户端连接信息、更新数据SQL语句、查询SQL语句</li><li>慢查询日志：记录执行时间超过指定时间的各种操作，可用于定位Mysql性能瓶颈</li></ul><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志默认关闭。可通过mysql配置文件<code>my.ini</code>的<code>log-bin</code>参数，将注释去掉即可开启二进制日志。<br><code>log-bin = 二进制日志路径</code><br>路径是可选。若没指定路径，会使用默认名<code>主机名-bin.number</code>，number格式为000001开始的计数，并保存到默认目录：数据库的数据文件目录，即<code>C:\ProgramData\MySQL\MySQL Server 5.7\Data</code>。</p><blockquote><p>每次重启Mysql服务器都会生成一个新的二进制日志文件，number会递增</p></blockquote><p>可通过<code>mysqlbinlog 二进制日志</code>查看。<strong>不能直接打开，否则是乱码。</strong></p><p>若要停止二进制日志，只要将<code>my.ini</code>中的log-bin恢复注释或删除即可。或者在数据库中通过对变量的设置实现开启或关闭二进制日志。<br><code>set SQL_LOG_BIN=</code>若为1表示开启，若为0表示关闭</p><blockquote><p>只有有super权限的用户才能执行set语句</p></blockquote><p>删除二进制日志<br><code>reset master;</code>可删除所有二进制日志文件<br><code>purge master logs to 日志文件</code>可删除number所有小于该日志的日志<br><code>purge master logs before &#39;yyyy-mm-dd hh:MM:ss&#39;</code>删除指定日期前创建的二进制日志</p><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>Mysql默认开启错误日志，也无法被禁止。同样该日志默认也存放在<code>C:\ProgramData\MySQL\MySQL Server 5.7\Data</code>中，文件名称格式为<code>Mysql主机名.err</code>。可修改<code>my.ini</code>的<code>error-bin</code>修改日志的路径。</p><p>错误日志以文本文件形式存储信息，可直接打开。<br>命令<code>mysqladmin -u root -p flush-logs</code>会先创建一个新的错误日志，然后将旧的错误日志改名为<code>原文件名-old</code>。</p><h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>由于该日志记录了客户端Mysql的所有请求，若实例的访问量较大，则此日志会急剧增大，影响Mysql性能，一般建议关闭。</p><p>若要开启通用查询日志，设置<code>my.ini</code>的<code>general-log=1</code>，默认未开启。<br><code>general_log_file</code>设置通用查询日志的路径，格式为<code>文件名.log</code>，默认为<code>主机名.log</code>。</p><p>也可通过设置环境变量开启或关闭，<code>set global general_log = on;</code>开启通用查询日志。若要关闭，设为off即可。<br>通过<code>show variables like &#39;%general_log%&#39;;</code>查看相关变量（只有是否开启和文件路径）。</p><p>同样可以使用<code>mysqladmin -u root -p flush-logs</code>删除日志，但Mysql会创建一个新日志覆盖旧日志。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>默认慢查询日志是关闭的。可通过<code>my.ini</code>的<code>slow-query-log=1</code>开启。<br>可通过<code>slow_query_log_file</code>设置慢查询日志的路径，文件格式为<code>文件名-slow.log</code>，默认为<code>主机名-slow.log</code>。默认存放在<code>C:\ProgramData\MySQL\MySQL Server 5.7\Data</code>。<br>可通过<code>long_query_time</code>设置超时时间，默认为10s。<br>修改配置后需要重启Mysql才能生效。所以最好通过修改环境变量动态开启关闭。<br><code>set global slow_query_log=on;</code>开启慢查询日志<br><code>set global long_query_time=3;</code>设置超时时间，对设置后的新连接有效，可重新连接Mysql。</p><p>Mysql提供工具<code>mysqldumpslow.pl</code>对慢查询日志文件进行分析，该工具在<code>C:\Program Files\MySQL\MySQL Server 5.7\bin</code>中。<br><strong>该工具由perl语言编写，因此需要perl环境</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow.pl</span><br><span class="line">    -s 分析慢查询日志时指定排序参数，有以下可选参数</span><br><span class="line">        al 平均锁定时间</span><br><span class="line">        ar 平均返回记录数</span><br><span class="line">        at 平均查询时间</span><br><span class="line">    -t 只显示指定的行数</span><br></pre></td></tr></table></figure></p><p>若要停止慢查询日志，可将<code>my.ini</code>的<code>slow-query-log</code>与<code>long_query_time</code>注释即可。或通过修改环境变量<code>slow-query-log=off</code>关闭。<br>若要删除慢查询日志，可通过命令<code>mysqladmin -u root -p flush-logs</code>创建新的日志，会覆盖旧日志。</p><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2><h3 id="数据库备份与还原"><a href="#数据库备份与还原" class="headerlink" title="数据库备份与还原"></a>数据库备份与还原</h3><p>使用<code>mysqldump</code>命令进行数据备份<br><code>mysqldump -u [username] -p [dbname] [table1]... &gt; [path]/[filename].sql</code><br>备份单个数据库，可指定表（可多张），若不指定，就备份整个库。导出的sql文件路径与名称都可自定义。<br><code>mysqldump -u [username] -p --databases [dbname]... &gt; [path]/[filename].sql</code>备份多个数据库<br><code>mysqldump -u [username] -p --all -databases &gt; [path]/[filename].sql</code>备份所有数据库</p><p><strong>还原数据</strong><br>需要先在mysql中创建对应库，然后在数据库外执行命令。<br><code>mysql -u [username] -p [dbname] &lt; [path]/[filename].sql</code><br>可指定数据库，指定就还原该数据库下的表，不指定就还原所有库。</p><p>若要通过复制对数据恢复，则需要保证两个Mysql的版本号一致，且只能对存储引擎为MYISAM的表有效。</p><p><strong>将数据库表与文本文件互相导入导出</strong><br>导出有三种方法：</p><ul><li><code>select ...into outfile...;</code>命令</li><li><code>mysqldump</code>命令</li><li><code>mysql</code>命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. select 字段名 from 表名 过滤条件    # 第一部分是普通的查询语句</span><br><span class="line">      into outfile 文件名 选项;   # 设置要导出到的文件以及文件的参数选项</span><br><span class="line">有六种选项：</span><br><span class="line">    fields terminated by 字符串：用于设置字段的分隔符，默认为&apos;\t&apos;</span><br><span class="line">    fields enclosed by 字符：用于设置括上字段值的字符符号，默认不使用任何符号</span><br><span class="line">    fields optionally enclosed by 字符：用于设置括上char、varchar、text等字段值的字符符号，默认不使用任何符号</span><br><span class="line">    fields escaped by 字符：用于设置转义字符的字符符号，默认为&apos;\&apos;</span><br><span class="line">    lines starting by 字符：用于设置每行开头的字符符号，默认不使用任何符号</span><br><span class="line">    lines terminated by 字符串：用于设置每行结束时的字符串符号，默认为&apos;\n&apos;</span><br><span class="line"></span><br><span class="line">例：select * from user</span><br><span class="line">        into outfile &apos;.\user.txt&apos;</span><br><span class="line">        fields terminated by &apos;\,&apos;</span><br><span class="line">        optionally enclosed by &apos;\&quot;&apos;</span><br><span class="line">        lines terminated by &apos;\r\n&apos;;</span><br><span class="line"></span><br><span class="line">2. mysqldump -u 用户名 -p -T 文件目录 数据库 表名 选项</span><br><span class="line">有四种选项：</span><br><span class="line">    --fields-terminated-by=字符串 ：设置字段的分隔符，默认为&apos;\t&apos;</span><br><span class="line">    --fields-enclosed-by=字符 ：设置括上字段值的字符符号，默认不使用任何符号</span><br><span class="line">    --fields-optionally-enclosed-by=字符 ：设置括上char、varchar、text等字段值的字符符号，默认不使用任何符号</span><br><span class="line">    --lines-terminated-by=字符串 ：设置每行结束时的字符串符号，默认为&apos;\n&apos;</span><br><span class="line"></span><br><span class="line">例：mysqldump -u 用户名 -p -T &apos;.\&apos; test user &quot;--fields-terminated-by=,&quot; &quot;--lines-terminated-by=\r\n&quot;</span><br><span class="line">使用mysqldump命令不仅会在指定目录中生成[表名].txt文件，还会生成[表名].sql文件。</span><br><span class="line"></span><br><span class="line">3. mysql -u 用户名 -p -e &quot;select 字段 from 表名&quot; 数据库名 &gt; 文件名</span><br><span class="line">     -e选项用于执行查询语句</span><br><span class="line"></span><br><span class="line">例：mysql -u root -p -e &quot;select * from user&quot; test &gt; .\user.txt</span><br></pre></td></tr></table></figure><p>导入有两种方法：</p><ul><li><code>load data infile</code>命令</li><li><code>mysqlimport</code>命令</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. load data infile 文件名 into table 表名 选项;</span><br><span class="line">有九种选项。前六种与导出的select六种一致，后三种为：</span><br><span class="line">     ignore N lines ：忽视文件的前N行数据</span><br><span class="line">     字段列表：实现根据字段列表中的字段和顺序加载记录</span><br><span class="line">     set column=EXPR ：设置列的转换条件EXPR，即所指定的列经过相应转换后才会被加载</span><br><span class="line"></span><br><span class="line">例：load data infile &apos;.\uesr.txt&apos; into table user</span><br><span class="line">        into outfile &apos;.\user.txt&apos;</span><br><span class="line">        fields terminated by &apos;\,&apos;</span><br><span class="line">        optionally enclosed by &apos;\&quot;&apos;</span><br><span class="line">        lines terminated by &apos;\r\n&apos;;</span><br><span class="line"></span><br><span class="line">2. mysqlimport -u 用户名 -p 数据库名 文件名 选项</span><br><span class="line">有六种选项。其中四种与导出的mysqldump选项一致，其余两种为： </span><br><span class="line">    --fields-escaped-by=字符 ：设置转移字符</span><br><span class="line">    --ignore-lines=N ：忽略文件的前N行记录</span><br><span class="line"></span><br><span class="line">例：mysqlimport -u root -p test &quot;.\user.txt&quot; &quot;--fields-terminated-by=,&quot; &quot;--lines-terminated-by=\r\n&quot;</span><br></pre></td></tr></table></figure><h3 id="数据库迁移"><a href="#数据库迁移" class="headerlink" title="数据库迁移"></a>数据库迁移</h3><p>分为三种情况：</p><ul><li><p>相同版本间迁移：使用mysqldump和mysql进行备份与恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">mysqldump -h 主机A -u root -p=密码 -all-databases </span><br><span class="line">| </span><br><span class="line">mysql -h 主机B -u root -p=密码</span><br><span class="line"># 其中 | 即为管道符</span><br></pre></td></tr></table></figure></li><li><p>不同版本间迁移：又分为高版本向低版本迁移和低版本向高版本迁移</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高版本向低版本迁移：</span><br><span class="line">高版本会兼容低版本</span><br><span class="line">若表的存储引擎为MYISAM，可直接复制或使用命令mysqlhotcopy。</span><br><span class="line">若表的存储引擎为InnoDB，可使用mysqldump与mysql的组合进行备份与恢复</span><br><span class="line"></span><br><span class="line">而低版本并不兼容高版本，所以迁移会较困难</span><br></pre></td></tr></table></figure></li><li><p>不同数据库间迁移<br>若从MYSQL迁移到SQL SERVER，可通过MyODBC实现。若从MYSQL迁移到ORACLE，可先导出sql文件，然后手动修改create语句。</p></li></ul><h3 id="简单的性能优化思路"><a href="#简单的性能优化思路" class="headerlink" title="简单的性能优化思路"></a>简单的性能优化思路</h3><ul><li>可通过<code>show variables</code>和<code>show status</code>查看修改配置和变量参数进行调优</li><li>若多个任务中一个执行缓慢，会影响其他任务。可通过<code>show processlist</code>显示所有活动进程，或执行<code>kill</code>终结消耗资源过多的进程</li><li>最好多次试验连接或子查询，找到效率最高的搜索方法。在select时可通过<code>explain</code>语句查看select的执行情况</li><li>使用存储过程的速度会提高</li><li>若不必要，不要直接执行<code>select *</code>语句</li><li>使用UNION连接select语句，比一系列OR条件的select语句效率高</li><li>对象索引可改善数据检索的性能，但会损失插入、更新、删除的性能。对于不常查询的表最好不要创建索引</li><li>关键字like的执行效率很低，一般会通过<code>full text</code>代替like</li></ul><h3 id="常见查看命令显示解析"><a href="#常见查看命令显示解析" class="headerlink" title="常见查看命令显示解析"></a>常见查看命令显示解析</h3><h4 id="SHOW-TABLE-STATUS"><a href="#SHOW-TABLE-STATUS" class="headerlink" title="SHOW TABLE STATUS"></a>SHOW TABLE STATUS</h4><p><code>show table status (from 数据库名) (like 表达式);</code><br>会直接显示该数据库中所有表的状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">           Name: stu         # 表名或视图名</span><br><span class="line">         Engine: InnoDB      # 存储引擎</span><br><span class="line">        Version: 10          # .frm文件版本</span><br><span class="line">     Row_format: Dynamic     # 行存储格式</span><br><span class="line">           Rows: 7           # 行数目</span><br><span class="line"> Avg_row_length: 2340        # 行平均长度</span><br><span class="line">    Data_length: 16384       # 文件长度</span><br><span class="line">Max_data_length: 0           # 文件最大长度</span><br><span class="line">   Index_length: 0           # 索引文件长度</span><br><span class="line">      Data_free: 0           # 表被整序后，但未使用的字节数目</span><br><span class="line"> Auto_increment: NULL        # 下一个Auto_increment值</span><br><span class="line">    Create_time: 2018-07-07 08:58:34   # 表的创建时间</span><br><span class="line">    Update_time: 2018-07-07 09:01:00   # 最后一次更新时间</span><br><span class="line">     Check_time: NULL        # 最后一次检查时间</span><br><span class="line">      Collation: utf8_general_ci       # 字符集</span><br><span class="line">       Checksum: NULL        # 表的活性校验</span><br><span class="line"> Create_options:             # 表的额外选项</span><br><span class="line">        Comment:             # 表的注释</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>MYSQL数据库应用从入门到精通（第二版）<br><a href="https://blog.csdn.net/ashic/article/details/52126979" target="_blank" rel="noopener">Mysql 异常处理–condition和handler</a><br><a href="http://www.cnblogs.com/f-ck-need-u/p/7586194.html" target="_blank" rel="noopener">Mysql系列–骏马金龙</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>YAML学习笔记</title>
      <link href="/2018/04/29/YAML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/29/YAML%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="YAML语言学习"><a href="#YAML语言学习" class="headerlink" title="YAML语言学习"></a>YAML语言学习</h2><p><img src="/2018/04/29/YAML学习笔记/yaml.gif" title="yaml &amp;}</p> <p><strong>本篇介绍YAML的语法，包括以下部分：</strong></p> <ul> <li>YAML简介</li> <li>规范</li> <li>数据结构</li> </ul> <a id=" more"=""> </p><h3 id="YAML简介"><a href="#YAML简介" class="headerlink" title="YAML简介"></a>YAML简介</h3><p>YAML是一个类似 XML、JSON 的标记性语言。YAML 强调以数据为中心，并不是以标识语言为重点。因而 YAML 本身的定义比较简单，号称“一种人性化的数据格式语言”。实质上是一种通用的数据串行化格式，专门用于写配置文件。</p> <p><strong>YAML与XML、JSON的区别：</strong> YAML比XML和JSON都简单，易阅读，并且能表示出更加复杂的结构，运行效率也很高。</p> <h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul> <li>大小写敏感</li> <li>使用缩进表示层级关系</li> <li>缩进时不能使用Tab键，只能用空格</li> <li>缩进空格数不重要，只要相同层级左侧对齐即可（类似Python）</li> <li><code>#</code>表示注解</li> </ul> <h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul> <li>对象：键值对的集合</li> <li>数组：按次序排列的值，也称序列、列表</li> <li>纯量：单个，不可再分的值</li> </ul> <h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>通过冒号分隔键、值<br><br><code>person: zhangsan</code> <br><br>也可通过行内表示法，写成行内对象<br><br><code>person: { name: zhangsan, age: 20 }</code></p> <h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>一组连词线开头的行，构成一个数组<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">wangwu</span></span><br></pre></td></tr></table></figure></p> <p>也可通过行内表示法 <br><br><code>person: [zhangsan, lisi, wangwu]</code> <br></p> <h4 id="复合结构"><a href="#复合结构" class="headerlink" title="复合结构"></a>复合结构</h4><p>对象和数组可以结合使用，形成复合结构。<br></p> <ul> <li><p>对象嵌套对象</p> <figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age:</span></span><br><span class="line"><span class="attr"> zhangsan:</span> <span class="number">20</span></span><br><span class="line"><span class="attr"> lisi:</span> <span class="number">21</span></span><br><span class="line"><span class="attr"> wangwu:</span> <span class="number">19</span></span><br></pre></td></tr></table></figure> </li> <li><p>对象嵌套数组</p> <figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lang:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">c</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">python</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">java</span></span><br></pre></td></tr></table></figure> </li> <li><p>数组嵌套数组<br><strong>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格，yaml语法会自动只空一格</strong></p> <figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">c</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">java</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">python</span></span><br><span class="line"><span class="string">还可这样表示</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">java</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">python</span></span><br><span class="line"><span class="string">还可这样表示</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">[c,</span> <span class="string">java,</span> <span class="string">python]</span></span><br></pre></td></tr></table></figure> </li> <li><p>数组嵌套对象</p> <figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> </span><br><span class="line"><span class="attr"> id:</span> <span class="number">1</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="bullet">-</span> </span><br><span class="line"><span class="attr"> id:</span> <span class="number">2</span></span><br><span class="line"><span class="attr"> name:</span> <span class="string">lisi</span></span><br></pre></td></tr></table></figure> </li> <li><p>综合实例</p> <figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="attr"> - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr"> targetPort:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr"> - port:</span> <span class="number">81</span></span><br><span class="line"><span class="attr"> targetPort:</span> <span class="number">8083</span></span><br></pre></td></tr></table></figure> </li> </ul> <h4 id="纯量"><a href="#纯量" class="headerlink" title="纯量"></a>纯量</h4><p>纯量的数据类型与js相同</p> <ul> <li>字符串</li> <li>布尔值 <code>true</code>和<code>false</code></li> <li>整数</li> <li>浮点数</li> <li>Null <code>~</code></li> <li>时间：采用ISO8601标准 <code>time: 2018-04-29T17:30:08+08:00</code></li> <li>日期：采用ISO8601标准 <code>date: 2018-04-29</code><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">integer:</span> <span class="number">12345</span> <span class="comment"># 整数标准形式</span></span><br><span class="line"><span class="attr">octal:</span> <span class="number">0</span><span class="string">o34</span> <span class="comment"># 八进制表示，第二个是字母 o</span></span><br><span class="line"><span class="attr">hex:</span> <span class="number">0xFF</span> <span class="comment"># 十六进制表示</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">1.23e+3</span> <span class="comment"># 浮点数</span></span><br><span class="line"><span class="attr">fixed:</span> <span class="number">13.67</span> <span class="comment"># 固定小数</span></span><br><span class="line"><span class="attr">minmin:</span> <span class="bullet">-.inf</span> <span class="comment"># 表示负无穷</span></span><br><span class="line"><span class="attr">notNumber:</span> <span class="string">.NaN</span> <span class="comment"># 无效数字</span></span><br><span class="line"><span class="attr">null:</span> <span class="comment"># 空值</span></span><br><span class="line"><span class="attr">boolean:</span> <span class="string">[true,</span> <span class="literal">false</span><span class="string">]</span> <span class="comment"># 布尔值</span></span><br></pre></td></tr></table></figure> </li> </ul> <p>YAML允许使用两个感叹号，强制转换数据类型<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">下面是可转换的类型（内置类型）</span></span><br><span class="line"> <span class="type">!!int</span> <span class="comment"># 整数类型</span></span><br><span class="line"> <span class="type">!!float</span> <span class="comment"># 浮点类型</span></span><br><span class="line"> <span class="type">!!bool</span> <span class="comment"># 布尔类型</span></span><br><span class="line"> <span class="type">!!str</span> <span class="comment"># 字符串类型</span></span><br><span class="line"> <span class="type">!!binary</span> <span class="comment"># 也是字符串类型</span></span><br><span class="line"> <span class="type">!!timestamp</span> <span class="comment"># 日期时间类型</span></span><br><span class="line"> <span class="type">!!null</span> <span class="comment"># 空值</span></span><br><span class="line"> <span class="type">!!set</span> <span class="comment"># 集合</span></span><br><span class="line"> <span class="type">!!omap</span><span class="string">,</span> <span class="type">!!pairs</span> <span class="comment"># 键值列表或对象列表</span></span><br><span class="line"> <span class="type">!!seq</span> <span class="comment"># 序列，也是列表</span></span><br><span class="line"> <span class="type">!!map</span> <span class="comment"># 键值表</span></span><br></pre></td></tr></table></figure></p> <figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">例：</span></span><br><span class="line"><span class="attr">obj1:</span> <span class="type">!!str</span> <span class="number">123</span></span><br><span class="line"><span class="attr">obj2:</span> <span class="type">!!str</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">omap:</span> <span class="type">!!omap</span></span><br><span class="line"><span class="attr"> - Mark:</span> <span class="number">65</span></span><br><span class="line"><span class="attr"> - Sammy:</span> <span class="number">63</span></span><br><span class="line"><span class="attr"> - Key:</span> <span class="number">58</span></span><br><span class="line"><span class="attr">set:</span> <span class="type">!!set</span> <span class="comment"># ? 表示键为数组，在这里数组为 null</span></span><br><span class="line"> <span class="string">?</span> <span class="string">Mark</span></span><br><span class="line"> <span class="string">?</span> <span class="string">Sammy</span></span><br><span class="line"> <span class="string">?</span> <span class="string">Key</span></span><br></pre></td></tr></table></figure> <h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><strong>字符串默认不使用引号表示</strong><br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">hello</span></span><br></pre></td></tr></table></figure></p> <p>如果字符串之中包含空格或特殊字符，需要放在引号之中。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">hello,world</span></span><br></pre></td></tr></table></figure></p> <p>单引号和双引号都可以使用，双引号不会对特殊字符转义。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str1:</span> <span class="string">hello</span> <span class="comment">#会将\n识别为换行</span></span><br><span class="line"><span class="attr">str2:</span> <span class="string">hello</span> <span class="comment">#会认为字符串就是hello\n</span></span><br></pre></td></tr></table></figure></p> <p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">这是</span></span><br><span class="line"> <span class="string">多行</span></span><br><span class="line"> <span class="string">字符串</span></span><br></pre></td></tr></table></figure></p> <p>多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str1:</span> <span class="string">|</span></span><br><span class="line"><span class="string"> abc</span></span><br><span class="line"><span class="string"> def # 会保存</span></span><br><span class="line"><span class="string"></span><span class="attr">str2:</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string"> abd</span></span><br><span class="line"><span class="string"> def # 不会保存</span></span><br></pre></td></tr></table></figure></p> <p><code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s1:</span> <span class="string">|</span></span><br><span class="line"><span class="string"> abc</span></span><br><span class="line"><span class="string"># 即表示s1: abc\n</span></span><br><span class="line"><span class="string"></span><span class="attr">s2:</span> <span class="string">|+</span></span><br><span class="line"> <span class="string">abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即表示s2: abc\n\n</span></span><br><span class="line"><span class="attr">s3:</span> <span class="string">|-</span></span><br><span class="line"> <span class="string">abc</span> </span><br><span class="line"><span class="comment"># 即表示s3: abc</span></span><br></pre></td></tr></table></figure></p> <p>字符串之中可以插入 HTML 标记。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">page:</span> <span class="string">|</span></span><br><span class="line"><span class="string"> &lt;div&gt;abcabc&lt;/div&gt;</span></span><br></pre></td></tr></table></figure></p> <h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。<br><br><code>&amp;</code>用来建立锚点（defaults），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span> <span class="meta">&amp;stu</span> <span class="comment"># &amp;用于起别名</span></span><br><span class="line"><span class="attr"> zhangsan:</span> <span class="number">1</span></span><br><span class="line"><span class="attr"> lisi:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">class1:</span></span><br><span class="line"> <span class="string">&lt;&lt;:</span> <span class="meta">*stu</span></span><br><span class="line"><span class="string">等同于</span></span><br><span class="line"><span class="attr">class1:</span></span><br><span class="line"><span class="attr"> zhangsan:</span> <span class="number">1</span></span><br><span class="line"><span class="attr"> lisi:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p> <h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>YAML 文件可以由一或多个文档组成（也即相对独立的组织结构组成），文档间使用<code>---</code>在每文档开始作为分隔符。同时，文档也可以使用<code>...</code>作为结束符（可选，但标明后会有利于网络上传输）。<br><figure class="highlight" yaml=""><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">文件1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">文件2</span></span><br></pre></td></tr></table></figure></p> <p><br><br><br></p> <blockquote> <p>参考文章：<br>YAML 语言教程-阮一峰 <a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a><br>YAML书写规范 <a href="http://www.cnblogs.com/wdliu/p/7080305.html">http://www.cnblogs.com/wdliu/p/7080305.html</a><br>YAML最最基础语法 <a href="https://blog.csdn.net/vincent_hbl/article/details/75411243">https://blog.csdn.net/vincent_hbl/article/details/75411243</a><br>yaml1.2官方文档 <a href="http://yaml.org/spec/1.2/spec.html">http://yaml.org/spec/1.2/spec.html</a></p> </blockquote>"><p></p>]]></content>
      
      
        <tags>
            
            <tag> Lang </tag>
            
            <tag> YAML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>I/O学习笔记</title>
      <link href="/2018/04/29/I-O%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/29/I-O%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>本篇包含以下知识点：</p><ul><li>同、异步概念</li><li>五种Unix I/O模型<ul><li>同步模型</li><li>异步模型</li></ul></li></ul><a id="more"></a><h3 id="同、异步"><a href="#同、异步" class="headerlink" title="同、异步"></a>同、异步</h3><p><strong>同步：</strong> 指的是在两个或多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。<br><br>同步处理过程：提交请求-&gt;等待服务器处理（期间客户端浏览器不能干任何事）-&gt;处理完毕返回<br><br><strong>异步：</strong> 异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。<br><br>异步处理过程：请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p><blockquote><p>同步、异步关注的是消息通知机制，针对的是客户端。</p></blockquote><p><strong>阻塞与非阻塞</strong><br><br>阻塞：调用结果返回之前，调用者会被挂起（不可中断），调用者只有在得到返回结果后才能继续。<br>非阻塞：调用结果返回前，不会被挂起，调用不会阻塞调用者。在内核的数据还未准备好时，会立即返回，进程可以去干其他事情。</p><blockquote><p>阻塞、非阻塞关注的是调用者等待被调用者返回结果时的状态，针对的是服务器端。</p></blockquote><p><strong>阻塞、非阻塞与同步、异步的区别</strong><br><br><strong>同步是在I/O中的一系列操作都是调用者（用户进程）自己完成（自己去问内核）。而异步是调用者在发起调用后，自己不管了，等内核数据准备好了以后，内核自己告诉进程，即让内核去通知进程，实现回调。</strong> <br><br><strong>至于阻塞与非阻塞，是决定是否让调用者挂起。</strong></p><p>网络I/O的本质是socket的读取，socket在linux系统被抽象为流，I/O可以理解为对流的操作。这个操作又分为两个阶段：</p><pre><code>1.等待流数据准备，即等待网络上的数据分组到达，然后被复制到内核的某个缓冲区2.从内核向进程复制数据，把数据从内核缓冲区复制到应用进程缓冲区</code></pre><h3 id="五种Unix-I-O模型"><a href="#五种Unix-I-O模型" class="headerlink" title="五种Unix I/O模型"></a>五种Unix I/O模型</h3><p><strong>I/O模型：</strong><br>进程是无法直接操作I/O设备的，其必须通过系统调用请求内核来协助完成I/O动作，而内核会为每个I/O设备维护一个buffer。 用户进程发起请求，内核接受到请求后，从I/O设备中获取数据到buffer中，再将buffer中的数据copy到用户进程的地址空间，该用户进程获取到数据后再响应客户端。<br>如下图中，真正称为I/O的就是<strong>内核内存与与进程内存间的过程</strong><br><br><img src="/2018/04/29/I-O学习笔记/iomoxing.bmp" title="iomoxing"></p><h4 id="同步I-O模型"><a href="#同步I-O模型" class="headerlink" title="同步I/O模型"></a>同步I/O模型</h4><p><strong>阻塞I/O（Blocking I/O）：</strong> 当用户进程进行系统调用read()时，进程发起recvform系统调用，内核就开始了I/O的第一个阶段，准备数据到缓冲区中，当数据都准备完成后，则将数据从内核缓冲区中拷贝到用户进程的内存中，这时用户进程才解除block的状态重新运行。整个过程中用户进程都是阻塞的。不会消耗CPU时间，执行效率高。<br><br><img src="/2018/04/29/I-O学习笔记/zuseio.jpg" title="zuseio"></p><p><strong>非阻塞I/O（Non-Blocking I/O）：</strong> 用户进程只有在第二个阶段被阻塞了，而第一个阶段没有阻塞。在第一个阶段中，recvform系统调用调用之后，内核马上返回给进程，如果数据还没准备好，此时会返回一个error，进程在返回之后，可以干点别的事情，然后再发起recvform系统调用，用户进程需要盲等，不停的去轮询内核，看数据是否准备好了。在拷贝数据整个过程，进程仍然是属于阻塞的状态。由于用户进程轮询内核，所以该模型是比较消耗CPU的，效率较低。<br><br><img src="/2018/04/29/I-O学习笔记/feizuseio.jpg" title="feizuseio"></p><p><strong> I/O复用（I/O Multiplexing）：</strong> I/O执行的两个阶段都是用户进程都是阻塞的，但是两个阶段是独立的，在一次完整的I/O操作中，该用户进程是发起了两次系统调用。使用select()、poll()或epoll()（poll的改进版）进行调用，可支持两路调用。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><blockquote><p>select调用是内核级别的，select轮询可以等待多个socket，当其中任何一个socket的数据准备好了（通过内核监视），就能返回进行可读，然后进程再进行recvform系统调用。select在此模式下最多只支持1024个并发。</p></blockquote><img src="/2018/04/29/I-O学习笔记/iofuyong.jpg" title="iofuyong"><p><strong>I/O复用应用场景：</strong> <br></p><ul><li>服务器需要同时处理多个处于监听状态或多个连接状态的套接字。</li><li>服务器需要同时处理多种网络协议的套接字。</li></ul><p><strong>信号驱动I/O（Signal Driven I/O）：</strong> 也称基于事件的I/O。只有在I/O执行的第二阶段阻塞了用户进程，而在第一阶段是没有阻塞的。在I/O执行的第一阶段，当数据准备完成之后，内核会主动的通知用户进程数据已经准备完成（通过返回一个SIGIO信号），即对用户进程做一个回调。该通知分为两种，一为水平触发，即如果用户进程不响应则会一直发送通知，二为边缘触发，即只通知一次。</p><blockquote><p>注：需要先开启套接字的信号驱动I/O功能，并使系统调用sigaction安装一个信号处理函数</p></blockquote><img src="/2018/04/29/I-O学习笔记/xinxiqudongio.jpg" title="xinxiqudongio"><h4 id="异步I-O模型"><a href="#异步I-O模型" class="headerlink" title="异步I/O模型"></a>异步I/O模型</h4><p><strong>异步I/O（Asynchrnous I/O）：</strong> 当用户进程发起系统调用后，立刻就可以开始去做其它的事情，然后直到I/O执行的两个阶段都完成之后，内核会给用户进程发送通知，告诉用户进程操作已经完成了。由于在调用后进程会立刻返回，所以在整个输入操作的等待和复制期间，进程都不会阻塞。</p><blockquote><p>异步I/O不需要select或poll 主动询问，也没有询问描述符的数量限制。</p></blockquote><img src="/2018/04/29/I-O学习笔记/yibuio.jpg" title="yibuio"><p><br><br><br></p><blockquote><p>参考文章：<br>简明网络I/O模型—同步异步阻塞非阻塞之惑 <a href="https://www.jianshu.com/p/55eb83d60ab1" target="_blank" rel="noopener">https://www.jianshu.com/p/55eb83d60ab1</a><br>浅谈Linux下的五种I/O模型 <a href="https://www.cnblogs.com/chy2055/p/5220793.html" target="_blank" rel="noopener">https://www.cnblogs.com/chy2055/p/5220793.html</a><br>Linux 网络 I/O 模型简介（图文） <a href="https://blog.csdn.net/anxpp/article/details/51503329" target="_blank" rel="noopener">https://blog.csdn.net/anxpp/article/details/51503329</a><br>socket 和 网络I/O模型 <a href="https://www.jianshu.com/p/7ac69db65a0e" target="_blank" rel="noopener">https://www.jianshu.com/p/7ac69db65a0e</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> I/O </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker网络学习笔记-1</title>
      <link href="/2018/04/27/Docker%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/04/27/Docker%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><strong>主要是对docker文档(v18.03)的翻译以及自己的学习笔记</strong></p><p>本篇涉及知识点：</p><ul><li><a href="#Docker网络模式">Docker网络模式</a></li><li><a href="#跨主机网络">跨主机网络</a><ul><li><a href="#Overlay">Overlay</a></li><li><a href="#Macvlan">Macvlan</a></li></ul></li><li><a href="#补充知识点">补充知识点</a><ul><li><a href="#支持IPv6">支持IPv6</a></li><li><a href="#配置iptables">配置iptables</a></li></ul></li></ul><a id="more"></a><h1 id="Docker网络模式"><a href="#Docker网络模式" class="headerlink" title="Docker网络模式"></a>Docker网络模式</h1><p>目前Docker容器共有5种网络模式：</p><ul><li>桥接模式（bridge）</li><li>主机模式（host）</li><li>容器模式（container）</li><li>无网络模式（none）</li><li>用户自定义模式（user-defined）</li></ul><p>当安装完docker后，会默认创建三个网络，可通过<code>docker network ls</code>查看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">01ec14a3a84c        bridge              bridge              local</span><br><span class="line">56d5a7a9b06c        host                host                local</span><br><span class="line">9cbd2d449df7        none                null                local</span><br></pre></td></tr></table></figure></p><p>用户可在运行容器时通过<code>--network=</code>指定网络。</p><h2 id="桥接模式bridge"><a href="#桥接模式bridge" class="headerlink" title="桥接模式bridge"></a>桥接模式bridge</h2><p>bridge是docker默认选择的网络，而网桥就是docker0通过<code>ifconfig</code>即可看到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig</span><br><span class="line">docker0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>创建容器时若未指定network或网桥，就会默认挂到docker0网桥上。<br>docker0的网段为172.17.0.0/16，网关地址为172.17.0.1，可通过<code>docker inspect bridge</code>查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># docker inspect bridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;bridge&quot;,</span><br><span class="line">        ......</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;172.17.0.0/16&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p><p>docker daemon会创建一对对等接口：虚拟网桥上的vethxxx和容器的eth0。veth放置在宿主机的命名空间中，将宿主机上的所有网络为bridge的容器都连接到这个内部网络中，同时daemon会从网桥的私有地址空间中分配一个IP地址和子网给该容器。</p><img src="/2018/04/27/Docker网络学习笔记/bridge.png" title="bridge"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig</span><br><span class="line">......</span><br><span class="line">veth7576df5: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::9023:faff:fe28:14b3  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 92:23:fa:28:14:b3  txqueuelen 0  (Ethernet)</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">vethab244c0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet6 fe80::d047:b2ff:fee4:89c8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether d2:47:b2:e4:89:c8  txqueuelen 0  (Ethernet)</span><br><span class="line">......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>连接同一个bridge网络的容器间能够通过IP地址互相通信。<br>由于运行容器默认使用bridge网络，所以若要运行对外提供访问的服务，如web服务，就必须暴露端口，通过<code>-p</code>（指定容器暴露端口）或<code>-P</code>（发布容器所有端口）发布容器暴露的端口。</p><blockquote><p>默认情况下，创建容器时不会将任何端口发布到外部。若通过<code>-p</code>或<code>--publish</code>发布端口，会创建一个防火墙规则，将容器端口映射到宿主机上的端口。</p></blockquote><p>Docker在bridge网络上不支持服务自动发现。如果需要通过容器名实现容器间的互相通信，就要设置连接属性<code>--link=容器名:别名</code>（官方并不推荐，已快被淘汰，官方推荐用<code>user-definded</code>网络实现互通）。<br>容器内所有的环境变量都可供连接到它的容器使用，可能会造成安全隐患。</p><h2 id="主机模式host"><a href="#主机模式host" class="headerlink" title="主机模式host"></a>主机模式host</h2><p>在此模式下，容器网络与宿主机网络间的隔离将被禁止，容器共享宿主机的网络命名空间，使容器直接暴露在公共网络中。因此，需要通过端口映射（Port Mapping）进行协调。</p><img src="/2018/04/27/Docker网络学习笔记/host.png" title="host"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it --network=host alpine</span><br><span class="line">/ # ifconfig</span><br><span class="line">br-7673688a6ae1 Link encap:Ethernet  HWaddr 02:42:DC:D4:64:FA</span><br><span class="line">          inet addr:172.22.0.1  Bcast:172.22.255.255  Mask:255.255.0.0</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:81:58:18:0C</span><br><span class="line">          inet addr:172.17.0.1  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">ens33     Link encap:Ethernet  HWaddr 00:0C:29:58:0C:12</span><br><span class="line">          inet addr:192.168.163.101  Bcast:192.168.163.255  Mask:255.255.255.0</span><br><span class="line">  ......</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>由此可知，当使用host模式网络时，容器实际上继承了宿主机的IP地址，并且在容器中可以看到宿主机的所有网卡。</p><p>因为没有路由开销，因此主机模式会比bridge模式更快。但是由于容器直接被暴露在公共网络中，会有安全隐患。</p><h2 id="容器网络container"><a href="#容器网络container" class="headerlink" title="容器网络container"></a>容器网络container</h2><p>在该模式，新创建的容器和已经存在的一个容器共享一个网络命名空间。两个容器除了网络的命名空间，其他的如文件系统、进程列表等仍然是隔离的。两个容器可以通过环回口进行设备通信。该模式也是Kubernetes使用的网络模式。</p><img src="/2018/04/27/Docker网络学习笔记/container.jpg" title="container"><p>该模式通过<code>--network=container:另一个已存在的容器</code>实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it --name container_A alpine</span><br><span class="line">/ # ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:05</span><br><span class="line">          inet addr:172.17.0.5  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># docker run -it --name container_B --network=container:container_A alpine</span><br><span class="line">/ # ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:05</span><br><span class="line">          inet addr:172.17.0.5  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></p><h2 id="无网络模式none"><a href="#无网络模式none" class="headerlink" title="无网络模式none"></a>无网络模式none</h2><p>该模式关闭了容器的网络功能，容器处于自己独立的网络命名空间中，且不进行任何配置。</p><p>使用场景：1.容器并不需要网络（例如只需要写磁盘卷的批处理任务，或生成随机密钥）2.自定义网络</p><h2 id="用户自定义模式user-defined"><a href="#用户自定义模式user-defined" class="headerlink" title="用户自定义模式user-defined"></a>用户自定义模式user-defined</h2><p>本模式使用户可自定义网络中的参数，以满足特定需求，例如DNS服务器。同一个自定义网络中，可以使用对方容器的容器名、服务名、网络别名来找到对方。这个时候帮助进行服务发现的是Docker内置的DNS。所以，无论容器是否重启、更换IP，内置的DNS都能正确指定到对方的位置。</p><blockquote><p>docker内嵌DNS Server，但只有在用户自定义模式才能使用。</p></blockquote><p>docker提供的网络驱动：<strong>User-defined bridge</strong>，<strong>overlay</strong>，<strong>macvlan</strong>，<strong>host</strong>，<strong>Third-party network plugins</strong>。</p><p>可通过<code>docker network create --driver=[driver] [network-name] [--subnet] [--gateway]</code>指定网络驱动创建网络，并指定网段和网关。</p><p><strong>bridge</strong>用于在同一主机内的通信。<br><strong>macvlan</strong>和<strong>overlay</strong>用于跨主机通信。</p><p><strong>macvlan</strong>：当从VM设置迁移或需要<strong>容器看起来像网络上的物理主机</strong>时使用，可以使<strong>每个容器都具有唯一的MAC地址</strong>。</p><p><strong>overlay</strong>：当需要在<strong>不同Docker主机上运行的容器</strong>进行通信，或者当<strong>多个应用程序使用swarm服务一起工作</strong>时使用。</p><p><strong>host</strong>和网络模式对应的作用相同，host驱动仅可用于v17.06版本以上的docker swarm集群。<br><strong>network plugins</strong>是第三方为docker制作的网络插件。</p><ul><li>bridge驱动: 用于创建类似bridge网络模式的网络，加入该网络的容器必须在同一台宿主机，仅适合一台主机上的小型网络。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># docker network create --driver=bridge mybridge --subnet=10.1.1.0/24 --gateway=10.1.1.1</span><br><span class="line"># docker inspect mybridge</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Name&quot;: &quot;mybridge&quot;,</span><br><span class="line">        ......</span><br><span class="line">        &quot;Driver&quot;: &quot;bridge&quot;,</span><br><span class="line">        &quot;EnableIPv6&quot;: false,</span><br><span class="line">        &quot;IPAM&quot;: &#123;</span><br><span class="line">            &quot;Driver&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">            &quot;Config&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;Subnet&quot;: &quot;10.1.1.0/24&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;10.1.1.1&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">......</span><br><span class="line"># docker run -it --network=mybridge alpine</span><br><span class="line">/ # ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:0A:01:01:02</span><br><span class="line">          inet addr:10.1.1.2  Bcast:10.1.1.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>同主机容器间通信，分为：IP通信，DNS Server，Joined容器。</p><p><strong>IP通信：</strong> 容器处于两个不同网络中，通过<code>docker network connect [对端容器所处网络名][本端容器]</code>连接容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--alias 设置对端网络别名</span><br><span class="line">--ip 指定对端网络上该IP地址的容器</span><br><span class="line">--ip6 同上，为IPv6地址</span><br><span class="line">--link 指定连接的容器名</span><br><span class="line">--link-local-ip 为容器添加一个连接本地的地址</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it --name container_A alpine</span><br><span class="line"># docker network connect mybridge container_A</span><br><span class="line"># docker run -it --network=mybridge --name=container_B alpine</span><br><span class="line"># docker inspect container_B -f &apos;&#123;&#123;.NetworkSettings.Networks.mybridge.IPAddress&#125;&#125;&apos;</span><br><span class="line">10.1.1.4</span><br><span class="line"></span><br><span class="line"># docker inspect container_A -f &apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos;</span><br><span class="line">172.17.0.3</span><br><span class="line"></span><br><span class="line"># docker attach container_A</span><br><span class="line">/ # ping 10.1.1.4</span><br><span class="line">PING 10.1.1.4 (10.1.1.4): 56 data bytes</span><br><span class="line">64 bytes from 10.1.1.4: seq=0 ttl=64 time=0.294 ms</span><br><span class="line">/ # ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03</span><br><span class="line">          inet addr:172.17.0.3  Bcast:172.17.255.255  Mask:255.255.0.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ......</span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 02:42:0A:01:01:03</span><br><span class="line">          inet addr:10.1.1.3  Bcast:10.1.1.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ......</span><br></pre></td></tr></table></figure><p>原理如图（图为docker文档的，ip地址有偏差），docker会在本容器上创建一个新的网卡，由指定的网络分配IP地址，实现与指定的网桥中容器的连接（如上面ifconfig中eth1）。</p><img src="/2018/04/27/Docker网络学习笔记/bridge3.png" title="bridge3"><p><strong>DNS：</strong> 使用对方容器的容器名、服务名、网络别名来找到对方，无论容器是否重启、更换IP，内置的DNS都能正确指定到对方的位置。</p><p><strong>Joined容器：</strong> 即container网络模式，使两个及以上的容器共享一个网络栈，共享网卡和配置。</p><p><strong>容器访问外网</strong><br>容器默认就能访问外网，这里外网指容器外的网络，不只是互联网。</p><p>处理流程：1.容器发数据包，docker0收到数据包后查看IP头，发现是发往外网的，交给NAT处理。2.NAT将源地址转为宿主机IP地址，并从主机网卡发出。</p><p><strong>外网访问容器</strong><br>外网通过端口映射访问容器，每个映射的端口，宿主机都会启动一个docker-proxy进程处理访问容器的流量，可在宿主机通过<code>ps -ef | grep docker-proxy</code>查看端口映射情况<br>下图为内外网的完整访问流程图</p><img src="/2018/04/27/Docker网络学习笔记/wwfwrq.png" title="wwfwrq"><h1 id="跨主机网络"><a href="#跨主机网络" class="headerlink" title="跨主机网络"></a>跨主机网络</h1><p>docker容器有多种访问外网的方案，其中docker提供两个原生方案：overlay和macvlan。还可选择第三方方案：flannel，weave，calico。</p><p>众多的docker网络方案通过libnetwork与容器网络模型（Container Network Model）集成在一起，其中libnetwork为docker容器网络库，而其核心即为容器网络模型，对容器网络进行了抽象，由以下三个组件组成：</p><ul><li>Sandbox：容器的网络栈，包含容器接口、路由表和DNS设置。Sandbox的实现标准为Linux Network Namespace，可以包含来自不同Network的Endpoint。</li><li>Endpoint：将Sandbox接入Network，典型实现为Veth Pair。一个Endpoint只属于一个网络，也只属于一个Sandbox。</li><li>Network：包含一组Endpoint，同一Network的Endpoint可以直接通信。</li></ul><h2 id="Overlay"><a href="#Overlay" class="headerlink" title="Overlay"></a>Overlay</h2><p>Overlay网络驱动创建了多docker主机间的分布式网络，允许与其连接的容器互相安全地通信，服务和容器能同时连接多个网络，但也仅能在连接的网络间通信。虽然可以将集群服务和单独的容器都连入一个overlay网络，但overlay对于集群与单独容器的默认配置是不同的，对于不同对象有不同的选项。</p><p>在创建overlay网络之前，需要使用docker swarm初始化作为swarm manager，或者使用<code>docker swarm join</code>将其加入到现有swarm中。这两者都创建缺省的swarm服务使用的默认overlay网络<code>ingress</code>。</p><p><strong>实验环境：</strong><br>swarm manager：192.168.163.102<br>swarm worker：192.168.163.103</p><p>在manager上初始化docker swarm<br><code>docker swarm init</code><br>worker上加入docker swarm（将manager上生成的命令复制粘贴到worker上运行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker swarm join --token SWMTKN-1-077i43tqnp5df8y29nrrh8apm9y2a4khzggg8nydd2yy8nzzjw-0i1qu8z1xl2s7ngy8y1gcnfnb 192.168.163.102:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><p>创建overlay网络my_overlay：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># docker network create -d overlay my_overlay</span><br><span class="line"># docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8cc4b6f2ddfa        bridge              bridge              local</span><br><span class="line">5db2b494b1af        docker_gwbridge     bridge              local</span><br><span class="line">5a1cfdddfd60        host                host                local</span><br><span class="line">y6l4bambmqoj        ingress             overlay             swarm</span><br><span class="line">bdv2xdmkujbu        my_overlay          overlay             swarm</span><br><span class="line">7ec96e1718f1        none                null                local</span><br></pre></td></tr></table></figure></p><p>若要创建一个overlay网络供群集服务或独立容器与其他Docker守护程序上运行的其他独立容器进行通信，要添加<code>--attachable</code>参数。<code>ingress</code>网络创建时没有<code>--attachable</code>选项，说明只有swarm服务可以使用它，而不是独立的容器。通过在创建网络时添加<code>--attachable</code>选项使得运行在不同Docker守护进程上的独立容器能够进行通信，而无需在各个Docker守护进程主机上设置路由。</p><p><strong>容器发现</strong><br>对于大多数情况，应该连接到服务名，而不是单独容器，因为服务是负载均衡的且是由所有服务后的容器（即任务task）处理的。要获取支持该服务的所有任务（task）的列表，可以执行DNS查找<code>tasks.&lt;service-name&gt;</code></p><p><strong>overlay网络加密</strong><br>默认docker对swarm服务在GCM模式下使用AES算法加密，集群中的manager节点每12小时就轮换用于加密gossip（反熵算法）数据的密钥。</p><p>要加密应用程序数据，需要在创建overlay网络时添加<code>--opt encrypted</code>。这使得vxlan级别的IPSEC加密成为可能。这种加密会带来不可忽视的性能损失，所以应该在生产中使用它之前对其进行测试。</p><p>当启用overlay加密时，Docker会在所有节点之间创建IPSEC隧道，在这些节点上调度连接到overlay网络服务的任务。这些通道在GCM模式下也使用AES算法，manager节点每12小时自动轮换一次密钥。</p><blockquote><p>不要将Windows节点添加到加密的overlay网络。<br>Windows上不支持overlay网络加密。如果Windows节点尝试连接到加密的overlay网络，虽不会报告错误，但节点无法通信。</p></blockquote><p><strong>默认ingress网络</strong><br>默认overlay网络ingress的作用：当自动选择的子网与网络中已存在的子网冲突或需要自定义某项低层的网络配置（例如MTU）时，默认的ingress网络会很有用。<br>通常在Swarm中创建服务前对ingress网络进行删除或重建操作。如果已有发布端口的服务，在删除ingress网络前必须先删除这些服务。<br>若没有ingress网络且不发布端口的服务在运行却没有进行负载均衡，那么那些发布端口的服务会受到影响。</p><p>可在创建网络时加上<code>--ingress</code>选项创建ingress网络并自定义网络参数。只能创建一个ingress网络。</p><p><strong>默认docker_gwbridge网络</strong><br>docker_gwbridge是一个虚拟网桥，它将overlay网络（包括ingress网络）连接到单独的Docker守护进程的物理网络。初始化群集或将Docker主机加入群集时，Docker会自动创建它，但它不是Docker设备。它存在于Docker主机的内核中。如果需要自定义其设置，则必须在将Docker主机加入集群之前或临时从集群中暂时删除主机之后执行该自定义操作。</p><p>若要删除docker_gwbridge网络，需要先停止docker，再删除docker_gwbridge网络，由于停止了docker，所以要通过<code>ip link</code>删除该网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ip link set docker_gwbridge down</span><br><span class="line"># ip link del docker_gwbridge</span><br></pre></td></tr></table></figure></p><p>再启动docker，但不要加入或初始化swarm。重建一个docker_gwbridge网络，然后再加入或初始化swarm。</p><p><strong>在overlay网络发布端口</strong><br>连接在同一个overlay网络的集群服务可以有效地互相发布所有端口。若要使一个端口能在服务外能访问，必须在<code>docker service create</code>或<code>docker service update</code>后加上<code>-p</code>选项发布指定端口。支持冒号分隔的旧语法<code>-p 8080:80/tcp</code>和逗号分隔的新语法<code>-p published=8080,target=80,protocol=tcp</code>。</p><p><strong>绕过集群服务的路由网格（routing mesh）</strong><br>默认情况下，发布端口的群集服务使用路由网格来完成。当连接到任何swarm节点上的已发布端口（无论是否运行给定服务）时，都会透明地重定向到正在运行该服务的worker。实际上，Docker充当群集服务的负载平衡器。使用路由网格的服务以虚拟IP（VIP）模式运行。即使在每个节点上运行的服务（通过<code>--global</code>标志）也使用路由网格。使用路由网格时，不能保证哪个Docker节点服务客户端会请求。</p><p>要绕过路由网格，可以通过设置选项<code>--endpoint-mode dnsrr</code>来使用<code>DNS Round Robin（DNSRR）</code>模式启动服务且必须在服务前运行自定义的负载均衡器。对Docker主机上服务名的DNS查询会返回运行该服务的节点的IP地址列表，可以通过配置负载均衡器使用此列表并且平衡各节点间的流量。</p><p><strong>单独控制和数据</strong><br>默认情况下，尽管群集控制流量是加密的，但群集管理和应用程序之间的控制流量运行在同一个网络上，可以配置Docker使用单独的网络接口来处理两种不同类型的流量。初始化或加入群集时，分别指定<code>--advertise-addr</code>和<code>--datapath-addr</code>，加入集群的每个节点都要执行此操作。</p><p><strong>实验（根据官方文档的实验）</strong><br>Manager（system2）:192.168.163.102<br>Worker-1（system3）：192.192.168.163.103<br>Worker-2（system4）：192.192.168.163.104</p><p>在manager上初始化swarm，worker节点加入swarm。在manager上查看节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># docker node ls</span><br><span class="line">ID                            HOSTNAME              STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">ohfkwg8uu4zkjtyk1l1nbze4p *   system2.example.com   Ready               Active              Leader              18.03.1-ce</span><br><span class="line">6dbboj25t5tws0ohd1pdhsahl     system3.example.com   Ready               Active                                  18.03.1-ce</span><br><span class="line">aug4gnqnm0na4pwu835dku51x     system4.example.com   Ready               Active                                  18.03.1-ce</span><br></pre></td></tr></table></figure></p><p>可通过<code>--filter role=worker|manager</code>过滤节点信息</p><p>在manager上创建overlay网络。不需要在其他节点上创建overlay网络，当其中一个节点开始运行需要overlay网络的服务时，它将自动创建。<br><code>docker network create -d overlay nginx-net</code><br>在manager上创建一个nginx服务（只能在manager上创建服务）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># docker service create \</span><br><span class="line">--name my-nginx \</span><br><span class="line">-p 80:80 \</span><br><span class="line">--replicas=5 \          #设置创建的任务个数</span><br><span class="line">--network nginx-net \</span><br><span class="line">nginx</span><br><span class="line"></span><br><span class="line"># docker service ls</span><br><span class="line">ID                  NAME                MODE                REPLICAS            IMAGE               PORTS</span><br><span class="line">nvxzb5kzihl6        my-nginx            replicated          5/5                 nginx:latest        *:80-&gt;80/tcp</span><br></pre></td></tr></table></figure></p><p>在manager和worker上查看nginx-net网络情况，以及容器情况<code>docker inspect nginx-net</code></p><p>新建overlay网络，将服务更新到新的网络上<br><code>docker network create -d overlay nginx-net-2</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker service update \</span><br><span class="line">--network-add nginx-net-2 \  # 将my-nginx添加进nginx-net-2网络中</span><br><span class="line">--network-rm nginx-net \  # 将my-nginx从nginx-net网络中删除</span><br><span class="line">my-nginx</span><br></pre></td></tr></table></figure></p><blockquote><p>注：overlay网络会因为需要自动创建，但不会自动删除（当服务不需要该网络后）。需要手动删除服务和网络。<br><code>docker service rm my-nginx</code><br><code>docker network rm nginx-net nginx-net-2</code></p></blockquote><h2 id="Macvlan"><a href="#Macvlan" class="headerlink" title="Macvlan"></a>Macvlan</h2><p>一些应用类似传统应用或监视网络流量的应用，希望直接连接到物理网络，可以使用macvlan网络驱动为每个容器的虚拟网络接口分配MAC地址，需要指定宿主机上的物理接口用于Macvlan，以及Macvlan的子网和网关。可以使用不同的物理网络接口来隔离Macvlan网络。<br>网络设备需要能够处理“混杂模式”，其中一个物理接口可以分配多个MAC地址。网络模式最好是<code>bridge</code>或<code>overlay</code>。可以在bridge模式或vlan的trunk模式中创建macvlan网络。</p><p><strong>在bridge网络模式中创建macvlan网络</strong><br>在<code>docker network create</code>后添加<code>-d macvlan</code>，也可再指定流量通过的实际网卡<code>-o parent=ens33</code>。若要排除在macvlan中使用的IP地址，可添加选项<code>--aux-addresses=&quot;aux-addr=&quot;</code>，参数值为一组键值对。一张网卡仅能被一个macvlan网络设为<code>parent</code>。</p><p><strong>在vlan trunk模式中创建macvlan网络</strong><br>通过在网卡名后加<code>.[数字]</code>创建网卡子接口，例如<code>-o parent=ens33.10</code>。</p><p><strong>使用IPvlan</strong><br>可以使用三层IPvlan取代二层Macvlan。通过指定<code>-o ipvlan_mode=l2</code></p><h2 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h2><p><strong>支持IPv6</strong><br>只有Linux主机的docker支持IPv6。<br>修改<code>/etc/docker/daemon.json</code>，添加<code>{&quot;ipv6&quot;: true}</code>开启IPv6。然后重新加载配置文件<code>systemctl daemon-reload</code>或<code>systemctl reload docker</code>。在创建网络的时候可以加上<code>--ipv6</code>选项，在创建容器时加上<code>--ip6</code>选项</p><p><strong>配置iptables</strong><br>Docker通过iptables规则来提供网络隔离，不应修改Docker已设置的iptables规则。<br>所有Docker的iptables规则都被添加到<code>DOCKER</code>链中，不要手动操作此表。如果需要添加能在加载Docker规则之前加载的规则，应该将它们添加到<code>DOCKER-USER</code>链中，这些规则在Docker自动创建任何规则之前加载。</p><p>默认情况下，所有外部源IP都被允许连接到Docker守护进程。若要只允许特定的IP或网络访问容器，可在<code>DOCKER</code>过滤器链的顶部插入否定规则。</p><p>例：<code>iptables -I DOCKER-USER -i ens33 ! --source 192.168.163.0/24 -j DROP</code><br>为防止Docker修改iptables策略，在<code>/etc/docker/daemon.json</code>中设置<code>{&quot;iptables&quot;: false}</code>，官方不推荐这样设置，因为这样所有关于docker的iptables配置都要手动管理。</p><p><strong>DNS选项</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--dns 指定一个或多个DNS服务器</span><br><span class="line">--dns-search 设置dns搜索域</span><br><span class="line">--dns-opt 键值对，可参考/etc/resolv.conf</span><br><span class="line">--hostname 设置容器的主机名，默认就是容器名</span><br></pre></td></tr></table></figure></p><p><strong>docker代理</strong><br>在Docker客户端上编辑启动容器的用户主目录<code>~/.docker/config.json</code>文件。添加字段，可用<code>httpsProxy</code>或<code>ftpProxy</code>指定代理服务器的类型，并指定代理服务器的地址和端口，可以同时配置多个代理服务器。</p><p>通过将<code>noProxy</code>键设置为一个或多个逗号分隔的IP地址或主机，指定排除的代理服务器，支持<code>*</code>字符作为通配符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;proxies&quot;:</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;default&quot;:</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;httpProxy&quot;: &quot;http://127.0.0.1:3001&quot;,</span><br><span class="line">     &quot;noProxy&quot;: &quot;*.test.example.com,.example.com&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在创建容器时可通过<code>--env</code>设置环境变量，通过环境变量指定代理服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--env HTTP_PROXY=&quot;&quot;</span><br><span class="line">--env HTTPS_PROXY=&quot;&quot;</span><br><span class="line">--env FTP_PROXY=&quot;&quot;</span><br><span class="line">--env NO_PROXY=&quot;&quot;</span><br></pre></td></tr></table></figure></p><blockquote><p>参考文档<br>Cloudman 《每天五分钟玩转docker容器技术》<br><a href="https://docs.docker.com/network" target="_blank" rel="noopener">docker官方文档-网络板块</a><br><a href="http://dockone.io/article/1261" target="_blank" rel="noopener">docker网络模式</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Chrony/NTP学习笔记</title>
      <link href="/2018/01/31/Chrony%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/01/31/Chrony%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="Chrony-NTP学习笔记"><a href="#Chrony-NTP学习笔记" class="headerlink" title="Chrony/NTP学习笔记"></a>Chrony/NTP学习笔记</h2><p><strong>本篇包含以下内容</strong></p><ul><li>chrony介绍</li><li>chrony配置</li><li>ntpd配置</li></ul><a id="more"></a><h5 id="NTP协议介绍"><a href="#NTP协议介绍" class="headerlink" title="NTP协议介绍"></a>NTP协议介绍</h5><p>NTP全称Network Time Protocol网络时间协议，用于同步计算机时间。保证局域网服务器与时间服务器的时间保持一致，并支持使用加密确认的方式防止恶意协议攻击。<br></p><p>自CentOS7.2后，chronyd服务代替原来的ntpd服务，性能提高且配置简单。</p><p>根据红帽文档，chronyd与ntpd的区别在于：</p><ul><li>chronyd使用更好的算法，同步精度、速度与对系统的影响都比ntpd更好。</li><li>chronyd可以在更大的范围内调整系统时间速率，且能在时钟损坏或不稳定的计算机上正常工作。</li><li>当网络故障时，chronyd仍能很好地工作，而ntpd必须定时轮询时间参考才能正常工作。</li><li>chronyd可以快速适应时钟速率的突然变化，ntpd则需要一段时间才能稳定。</li><li>chronyd提供对孤立网络的支持，手动输入校准时间，并通过算法计算实时时间，估计计算机增减时间的速率，从而调整时间。</li></ul><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>环境</p><ul><li>CentOS7.4</li></ul><h5 id="Chrony基础搭建"><a href="#Chrony基础搭建" class="headerlink" title="Chrony基础搭建"></a>Chrony基础搭建</h5><p>步骤</p><ol><li>安装chrony服务（默认已安装）<br> <code>yum install chrony</code><br><br> 安装完后会有两个程序，一个chronyd服务，一个chronyc监控配置程序。</li><li>启动服务，设置开机自启<br><br> <code>systemctl start chronyd</code><br><br> <code>systemctl enable chronyd</code><br></li><li><p>chrony的配置文件/etc/chrony.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">server ntp.sjtu.edu.cn iburst</span><br><span class="line">server s1a.time.edu.cn iburst</span><br><span class="line">server s1b.time.edu.cn iburst</span><br><span class="line">server s1d.time.edu.cn iburst</span><br><span class="line">//server 添加时间服务器，能添加很多</span><br><span class="line"></span><br><span class="line">driftfile /var/lib/chrony/drift</span><br><span class="line">//chronyd中的校准文件，根据实际时间计算出计算机增减时间的比率，能在重启后做出补偿</span><br><span class="line"></span><br><span class="line">makestep 1.0 3</span><br><span class="line">//当系统时钟漂移过快后，会通过很长的调整期纠正，该命令指定在调整期大于某阈值时才调整</span><br><span class="line">//此处是当偏移大于1秒，系统时钟调整3次。</span><br><span class="line"></span><br><span class="line">rtcsync</span><br><span class="line">//启用内核模式，系统时间每11分钟拷贝到实时时钟</span><br><span class="line"></span><br><span class="line">#allow 192.168.0.0/16</span><br><span class="line">//允许指定网段或主机使用服务</span><br><span class="line"></span><br><span class="line">#keyfile /etc/chrony.keys  </span><br><span class="line">//设置密钥文件，可做NTP加密</span><br><span class="line"></span><br><span class="line">logdir /var/log/chrony</span><br><span class="line">//设置日志文件</span><br></pre></td></tr></table></figure></li><li><p>防火墙放行并重启服务<br><br><code>firewall-cmd --permanent --add-service=ntp</code><br><br><code>firewall-cmd --permanent --add-rich-rule=&#39;rule family=ipv4 port port=123 protocol=udp accept&#39;</code><br><br><code>firewall-cmd --reload</code><br><br><code>systemctl restart chronyd</code></p></li><li><p>查看同步源信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chronyc sourcestats</span><br><span class="line">//查看同步源状态</span><br><span class="line">210 Number of sources = 4</span><br><span class="line">Name/IP Address            NP  NR  Span  Frequency  Freq Skew  Offset  Std Dev</span><br><span class="line">==============================================================================</span><br><span class="line">202.120.2.100.dns.sjtu.e&gt;   0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">10.112.202.in-addr.arpa.&gt;   0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">ntpa.nic.edu.cn             0   0     0     +0.000   2000.000     +0ns  4000ms</span><br><span class="line">time.njnet.edu.cn           4   3    10   +810.140  43784.844  +7121us    14ms</span><br><span class="line"></span><br><span class="line">chronyc sources //查看同步源，结果与上一条类似</span><br></pre></td></tr></table></figure></li><li><p>自动同步时间<br><br><code>chronyc sources -v</code></p></li></ol><p>若要局域网内同步时间，只要客户端都安装chrony，且配置文件的server设置为此服务器ip即可。</p><h5 id="ntpd基础搭建"><a href="#ntpd基础搭建" class="headerlink" title="ntpd基础搭建"></a>ntpd基础搭建</h5><ol><li>安装ntpd服务<br><code>yum install ntp</code></li><li>修改配置文件<code>/etc/ntp.conf</code><br>在restrict段添加允许的主机网段<br><code>restrict 192.168.163.0 mask 255.255.255.0</code><br>允许指定网段或主机使用服务（类似chrony的allow）<br>server字段与chrony类似，指定上游ntp服务器。</li><li>重启ntpd<code>systemctl restart ntpd.service</code></li></ol><p>在ntpd服务未开启时，可用命令<code>ntpdate 0.centos.pool.ntp.org</code>手动同步。这条命令只能在ntpd未开启时才有效。</p><p>命令<code>ntpq -p</code>列出NTP服务器与上游服务器的连接状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># ntpq -p</span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line">*static-5-103-13 .GPS.            1 u   19   64    1  777.937  -99.910 133.624</span><br><span class="line">+mx.comglobalit. 128.227.205.3    2 u   19   64    1  413.258   84.278  15.570</span><br><span class="line">-ntp6.flashdance 192.36.143.130   2 u   18   64    1  438.957  196.165  32.565</span><br><span class="line">+119.79-161-57.c 129.242.4.241    2 u   50   64    1  670.566   58.678  51.049</span><br><span class="line"></span><br><span class="line">remote：上层ntp的IP地址或主机名，&apos;+&apos;表示优先，&apos;*&apos;表示次优先</span><br><span class="line">refid：参考的上一层NTP主机的地址</span><br><span class="line">st：stratum阶层</span><br><span class="line">poll：下次更新在几秒后</span><br><span class="line">offset：时间补偿的结果</span><br></pre></td></tr></table></figure></p><p><strong>扩展内容</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">系统时间与BIOS时间不一定相同。</span><br><span class="line">查看硬件BIOS时间：</span><br><span class="line"># hwclock -r</span><br><span class="line">Wed 02 May 2018 05:00:32 PM CST  -0.854732 seconds</span><br><span class="line">将当前系统时间写入BIOS中</span><br><span class="line"># hwclock -w</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> Chrony </tag>
            
            <tag> NTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iSCSI学习笔记</title>
      <link href="/2018/01/29/iSCSI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/01/29/iSCSI%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="iSCSI学习笔记-1"><a href="#iSCSI学习笔记-1" class="headerlink" title="iSCSI学习笔记-1"></a>iSCSI学习笔记-1</h2><p><strong>第一篇iSCSI笔记主要是基础配置，包含以下内容</strong></p><ul><li>iSCSI介绍</li><li>iSCSI基础搭建</li></ul><a id="more"></a><h5 id="常见存储方式"><a href="#常见存储方式" class="headerlink" title="常见存储方式"></a>常见存储方式</h5><ul><li>DAS 直接附加存储：外接存储设备直接连在服务器内部总线上，数据存储设备是整个服务器结构的一部分。</li><li>NAS 网络接入存储：存储设备独立于服务器，作为文件服务器独立存在与网络中。存储设备通过标准的网络拓扑（如以太网）添加到一群计算机。</li><li>SAN 存储区域网络：创造了存储的网络化。包含两种部署方式<ol><li>FCSAN：使用光纤通道</li><li>IPSAN：使用IP通道（如以太网线与iSCSI技术）</li></ol></li></ul><h5 id="SCSI与iSCSI"><a href="#SCSI与iSCSI" class="headerlink" title="SCSI与iSCSI"></a>SCSI与iSCSI</h5><ul><li>SCSI 小型计算机系统接口：一种通用接口标准，多用于服务器系统级接口。SCSI 结构基于C/S模式，其通常应用环境是：设备互相靠近，并且这些设备由 SCSI 总线连接。</li><li>iSCSI Internet小型计算机系统接口：一种基于TCP/IP的协议，用于建立管理IP存储设备、主机与客户机之间的连接，并创建SAN。SAN 使得 SCSI 协议应用于高速数据传输网络成为可能，这种传输以数据块级别（block-level）在多个数据存储网络间进行。</li></ul><p>iSCSI 的主要功能是在 TCP/IP 网络上的主机系统（启动器 initiator）和存储设备（目标器 target）之间进行大量数据的封装和可靠传输。此外，iSCSI 提供了在 IP 网络封装 SCSI 命令，且运行在 TCP 上。</p><ul><li>服务器：target   </li><li>客户端：initiator</li></ul><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>环境<br></p><ul><li>CentOS7，内核3.10</li><li>两台虚拟机，system1与system2，system1为服务器，system2为客户端</li><li>虚拟机网段192.168.163.0/24</li><li>system1 IP：192.168.163.100/24</li><li>system2 IP：192.168.163.102/24</li></ul><p>首先搭建服务器</p><ol><li><p>安装target与targetcli并开机启动<br>服务器端要安装的服务为targetd，还需安装targetcli程序进行配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install targetd targetcli</span><br><span class="line">systemctl enable targetd target</span><br><span class="line">systemctl start targetd target</span><br></pre></td></tr></table></figure></li><li><p>确保系统有空闲可用的裸磁盘<br>本处选择/dev/sdc1，大小5G</p></li><li>进入<code>targetcli</code>程序配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">目录结构</span><br><span class="line">o- /                </span><br><span class="line">  o- backstores     </span><br><span class="line">  | o- block        </span><br><span class="line">  | o- fileio       </span><br><span class="line">  | o- pscsi        </span><br><span class="line">  | o- ramdisk      </span><br><span class="line">  o- iscsi          </span><br><span class="line">  o- loopback</span><br></pre></td></tr></table></figure></li></ol><p>进入block，创建设备disk1<br><code>create dev=/dev/sdc1 name=disk1</code><br>另一种写法<br><code>create disk1 /dev/sdc1</code><br>然后进入iscsi目录，设置服务器端识别号</p><blockquote><p>识别号规范：iqn.年-月.域名反置:服务器主机名</p></blockquote><p><code>create wwn=iqn.2018-01.com.example:system1</code><br>该标识符可以自己设定如上配置，也可让系统自动生成直接在iscsi目录中<code>create</code><br>设置后iscsi目录结构如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">o- iscsi </span><br><span class="line">  o- iqn.2018-01.com.example:system1 </span><br><span class="line">    o- tpg1 </span><br><span class="line">      o- acls </span><br><span class="line">      o- luns </span><br><span class="line">      o- portals </span><br><span class="line">        o- 0.0.0.0:3260</span><br></pre></td></tr></table></figure></p><p>进入acls/ 添加客户端身份标识<br><code>create wwn=iqn.2018-01.com.example:system2</code><br>进入luns/ 给该组设置可用的存储设备<br><code>create /backstores/block/disk1</code><br>disk1就是block中创建的设备名<br>此时iscsi目录结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">o- iscsi </span><br><span class="line">  o- iqn.2018-01.com.example:system1 </span><br><span class="line">    o- tpg1 </span><br><span class="line">      o- acls </span><br><span class="line">      | o- iqn.2018-01.com.example:system2 </span><br><span class="line">      |   o- mapped_lun0 </span><br><span class="line">      o- luns </span><br><span class="line">      | o- lun0 </span><br><span class="line">      o- portals </span><br><span class="line">        o- 0.0.0.0:3260</span><br></pre></td></tr></table></figure></p><p>进入portals/ 修改服务端端口号<br>有可能里面没有默认配置，直接创建。若有默认配置就先删除再创建<code>delete 0.0.0.0 ip_port=3260</code><br><code>create 192.168.163.100 3260</code><br>此处ip地址为服务器端IP，端口号为3260<br>全部配置完exit退出配置程序</p><ol><li>防火墙放行对应端口号，重启服务<br>端口号3260，且tcp端口放行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --add-port=3260/tcp</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">systemctl restart targetd target</span><br></pre></td></tr></table></figure></li></ol><p>然后是客户端搭建</p><ol><li>安装客户端软件<br><code>yum install iscsi-initiator-utils</code></li><li>设置客户端识别号<br>该文件需要自己输入配置，输入客户端的识别码<br><code>vim /etc/iscsi/initiatorname.iscsi</code><br><code>initiatorname=iqn.2018-01.com.example:system2</code></li><li>启动服务<br><code>systemctl enable iscsi iscsid</code><br><code>systemctl start iscsi iscsid</code></li><li>获取硬盘<br><code>iscsiadm -m discovery -t st -p 192.168.163.100 -l</code><blockquote><p>iscsiadm 用于管理iSCSI数据库配置文件的命令行工具<br>-m discovery 表示发现查找<br>-t senbtargets  表示发布的target，简写st<br>-p IP 指定服务器地址<br>-l 表示login，可不加</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连接成功信息:</span><br><span class="line">Logging in to [iface: default, target: iqn.2018-01.com.example:system1, portal: 192.168.163.100,3260] (multiple)</span><br><span class="line">Login to [iface: default, target: iqn.2018-01.com.example:system1, portal: 192.168.163.100,3260] successful.</span><br></pre></td></tr></table></figure><p>通过命令<code>lsblk</code>查看是否拿到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@system2 ~]# lsblk</span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   20G  0 disk </span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   19G  0 part </span><br><span class="line">  ├─centos-root 253:0    0   17G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb               8:16   0    5G  0 disk </span><br><span class="line">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure></p><p>发现出现了sdb，大小为5G，已成功获取</p>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> iSCSI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS学习笔记（1）</title>
      <link href="/2018/01/28/DNS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/01/28/DNS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="DNS-学习笔记"><a href="#DNS-学习笔记" class="headerlink" title="DNS 学习笔记"></a>DNS 学习笔记</h2><p><strong>本篇DNS笔记包含以下内容</strong></p><ul><li><a href="#DNS简介">DNS简介</a></li><li><a href="#DNS解析原理">DNS解析原理</a></li><li><a href="#DNS深入理解">DNS深入理解</a></li><li><a href="#基本配置">基本配置</a></li></ul><a id="more"></a><h3 id="DNS简介"><a href="#DNS简介" class="headerlink" title="DNS简介"></a>DNS简介</h3><p>DNS全称Domain Name System域名解析服务，用于解析域名与IP地址对应关系。</p><p>DNS基于UDP，UDP端口号53，也会使用TCP的53端口，先会用UDP查找，若UDP查不到或请求大于512字节时才用TCP查找。同时，UDP进行名称解析，TCP进行区域解析。</p><p><strong>DNS组成：</strong></p><ul><li>域名服务器：提供域名解析服务的软件。DNS域名解析服务中最高效的是Bind。Bind的程序名叫named。</li><li>解析器：访问域名服务器的客户端，负责解析从域名服务器获取的响应。如nslookup。</li></ul><p>目前互联网的命名方式为层次树状结构，任何互联网上的主机或路由器都有唯一层次结构的名字，即域名。</p><p><strong>功能</strong></p><ul><li>正向解析：根据域名查找对应IP</li><li>反向解析：根据IP查找对应域名</li></ul><h3 id="DNS解析原理"><a href="#DNS解析原理" class="headerlink" title="DNS解析原理"></a>DNS解析原理</h3><h4 id="DNS域名解析原理（迭代）"><a href="#DNS域名解析原理（迭代）" class="headerlink" title="DNS域名解析原理（迭代）"></a>DNS域名解析原理（迭代）</h4><ol><li>客户端将域名解析请求发给本地域名服务器或<code>/etc/resolv.conf</code>中列出的服务器</li><li>本地域名服务器收到后，查询本地缓存，若有就返回</li><li>若没有就把请求发给根域名服务器，迭代查询</li><li>本地域名服务器会将最终的结果存入缓存，同时将结果返回给主机。<blockquote><p><code>/etc/resolv.conf</code>用于定义dns查询指向的服务器以及解析顺序<br>文件结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">domain  domain_name       # 声明本地域名，即解析时自动隐式补齐的域名</span><br><span class="line">search  domain_name_list  # 指定域名搜索顺序(最多6个)，和domain不能共存，若共存了，则后面的行生效</span><br><span class="line">nameserver  IP-Address           # 设置DNS指向，最多3个</span><br><span class="line">options timeout:n attempts:n  # 指定解析超时时间(默认5秒)和解析次数(默认2次)</span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="域名解析方法"><a href="#域名解析方法" class="headerlink" title="域名解析方法"></a>域名解析方法</h4><ul><li>递归：服务器收到请求时，若不能解析，则把请求转发到下一台服务器直到有一台解析成功。注：是收到请求的服务器去问，一个问下一个，最后解析完成后原路返回。</li></ul><img src="/2018/01/28/DNS学习笔记/digui.png" title="digui"><ul><li>迭代：服务器收到请求时，若不能解析，则按根域-&gt;一级域名-&gt;二级域名-&gt;三级域名依次询问，直到解析成功。注：是本地服务器去不断问。</li></ul><img src="/2018/01/28/DNS学习笔记/diedai.png" title="diedai"><p>禁止递归查询的原因：对于授权域名服务器，若打开了递归查询，相当于配置为开放DNS服务器，会造成大量数据流量。所以在授权域名服务器上，应该禁用递归查询。<br><code>recursion no;</code></p><ul><li>反向解析：根据IP查找对应域名。将创建一个in-addr.arpa的专门的域处理。</li><li>高速缓存：DNS会将解析的信息保存在高速缓存中。每条记录都对应一个TTL，设置在缓存中保存的时间。</li></ul><h3 id="DNS深入理解"><a href="#DNS深入理解" class="headerlink" title="DNS深入理解"></a>DNS深入理解</h3><p><strong>DNS报文解析</strong><br><img src="/2018/01/28/DNS学习笔记/format.png" title="format"></p><p><strong>分类</strong></p><ul><li>主域名服务器master server：在特定区域内具有唯一性的域名解析服务器</li><li>辅域名服务器slave server：从主服务器获取域名解析信息并维护，以防主服务器宕机。会通过TCP与主域名服务器通信，获取zone数据。</li><li>缓存服务器Caching-Only Server：向其他服务器查询域名解析信息，每获取一个就放在高速缓存中，提高重复查询效率。</li></ul><p><strong>域名服务器类型</strong></p><ul><li>根域名服务器：最高层次的域名服务器，存放所有顶级域名服务器的IP地址与域名。当一个本地域名服务器对一个域名无法解析时，就会直接找根域名服务器，根域名服务器会告知应该去哪个顶级域名服务器查询。全球共13个根域名服务器。可通过<code>dig</code>查看。</li><li>顶级域名服务器：负责管理在该服务器上注册的二级域名服务器的IP地址和域名。</li><li>授权域名服务器：DNS采用分区方式设置域名服务器。一个服务器所管理的范围为区。区的范围小于等于域的范围，每个区都设有一台权限域名服务器，负责将其分区的主机域名解析。由专业域名服务公司维护，若授权域名服务器出现故障，域名将不能被解析。</li><li>本地域名服务器：也称默认域名服务器，当主机发出DNS查询报文时，会最先询问本地域名服务器。</li></ul><p><strong>域名结构</strong><br>每一级域名都由英文字母与数字组成，不超过63字符，且不区分大小写，完整域名不超过255字符。<br>目前顶级域名TLD（Top Level Domain）三大类：国家顶级域名、国际顶级域名、通用顶级域名。<br>互联网的命名空间是按照机构的组织划分的，与物理网络无关，与IP子网无关。</p><ul><li>. 根域，管理一级域名</li><li>com、or、gov、cn等一级域名，管理二级域名</li><li>baidu、google等二级域名，管理三级域名，当国家为一级域名时，com等一级域名便会下降一级别，依次类推</li><li>依次会有三级，四级</li><li>www、ftp、mail等主机域名，为提供服务的主机名</li></ul><p>DNS系统采用阶层式管理，上一级的服务器只记录下一层的主机名（服务器名）</p><p><strong>资源记录</strong><br>语法 {name} {TTL} class record-type record-specfic-data</p><ul><li>name：域记录名。通常只有第一个DNS资源记录会配置，其他资源记录的name可能为空，那么其他资源记录会接受先前资源记录的名字。</li><li>TTL：生存时间。指定该数据在数据库中保存的时间，此栏若为空，表示默认生存时间在授权资源记录中指定。</li><li>class：记录的类。大范围用于Internet地址和其他信息地址类为IN（基本都是IN）。</li><li>record-type：记录类型。常为A、NS、MX、CNAME</li><li>record-specfic-data：记录指定数据。</li></ul><p>记录类型：</p><ul><li><p>A：IPv4地址记录，将主机映射到IPv4地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t A baidu.com</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              5       IN      A       123.125.115.110</span><br><span class="line">baidu.com.              5       IN      A       220.181.57.216</span><br></pre></td></tr></table></figure></li><li><p>AAAA：IPv6地址记录，将主机名映射到IPv6地址</p></li><li><p>CNAME：规范名称记录，将一个记录别名化为另一个记录，其中应具有A或AAAA记录。<br>  当DNS解析器收到CNAME记录为查询响应时，DNS解析器会使用规范名称重新发出查询。CNAME记录数据可指向DNS中任何位置的名称，无论在区域内还是区域外。<br>  应避免将CNAME记录指向其他CNAME记录以避免CNAME循环。CNAME记录链必须以A或AAAA记录结束。当使用CDN时，也可使用CNAME链。NS和MX记录不可指向CNAME记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t CNAME baidu.com</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.baidu.com.          5       IN      CNAME   www.a.shifen.com.</span><br></pre></td></tr></table></figure></li><li><p>PTR：指针记录，将IPv4或IPv6地址映射到主机名，用于反向DNS解析。对行为类似于主机名的IP进行编码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t PTR 202.108.22.220</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">220.22.108.202.in-addr.arpa. 5  IN      PTR     xd-22-220-a8.bta.net.cn.</span><br></pre></td></tr></table></figure></li><li><p>NS：名称服务器记录，将域名映射到DNS名称服务器。区域的每个公开授权名称服务器必须具有NS记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t NS baidu.com</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              5       IN      NS      ns7.baidu.com.</span><br></pre></td></tr></table></figure></li><li><p>SOA：授权起始记录，提供有关DNS区域工作方式的信息。每个区域正好有一个SOA记录，指定主服务器，以及辅（从）服务器更新副本的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t SOA baidu.com</span><br><span class="line">;; AUTHORITY SECTION:</span><br><span class="line">baidu.com.              5       IN      SOA     dns.baidu.com. sa.baidu.com. 2012138777 300 300 2592000 7200</span><br><span class="line"># dns.baidu.com.   主名称服务器  </span><br><span class="line"># sa.baidu.com.    DNS区域负责人的邮箱地址</span><br><span class="line"># 2012138777       区域版本号</span><br><span class="line"># 300              检查区域更新频率（单位s）</span><br><span class="line"># 300              在重试失败的刷新前应等待的时间（单位s）</span><br><span class="line"># 2592000          刷新失败，在停止使用其旧区域副本前等待的时间（单位s）</span><br><span class="line"># 7200             若解析器查询某个名称并该名称不存在，解析器将“记录不存在”信息进行缓存的时间（单位s）</span><br></pre></td></tr></table></figure></li><li><p>MX：邮件交换记录，将域名映射到邮件交换。邮件交换将接收该名称的电子邮件。<br>  数据为优先级，用于在多个MX记录间确定顺序，以及用于该名称的邮件交换的主机名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t MX baidu.com</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              5       IN      MX      10 mx.maillb.baidu.com.</span><br></pre></td></tr></table></figure></li><li><p>TXT：文本记录，将名称映射到文本。通常用于提供发送方策略框架SPF、域密钥识别邮件DKIM、基于域的消息身份验证报告一致性DMARC等数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host -v -t TXT  baidu.com</span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">baidu.com.              5       IN      TXT     &quot;google-site-verification=GHb98-6msqyx_qqjGl5eRatD3QTHyVB6-xQ3gJB5UwM&quot;</span><br></pre></td></tr></table></figure></li><li><p>SRV：服务记录，用于查找支持域的特定服务的主机。<br>  使用格式设置为包含服务和协议名称的域名。如<code>_service._protocol.domainname</code>，SRV记录可记录为域提供服务的主机名和服务端口号，还包括优先级和权重值。</p></li></ul><blockquote><p>名称服务器Name Server：存储域名资源信息的程序，会响应解析器的请求。利用该服务器，整个网络可划分为一个域的分层结构。整个域名空间可划分为多个区域zone，zone通常表示管理界限的划分，也就是DNS树状结构上的一点。每个zone都有一个主域名服务器，还可有多个辅域名服务器。</p></blockquote><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>环境</p><ul><li>CentOS7，内核3.10</li><li>虚拟机网段：192.168.163.0/24</li><li>DNS服务器IP地址：192.168.163.102/24</li><li>DNS服务器主机名：system2.example.com</li><li>网关：192.168.163.254</li><li>客户端主机名：system3.example.com</li></ul><p>DNS服务相关配置文件</p><ul><li>/etc/named.conf    主配置文件</li><li>/etc/named.rfc1912.zones    区域配置文件</li></ul><p><strong>步骤</strong></p><ul><li>安装bind服务<br><code>yum groupinstall DNS\ Server</code></li><li>开启named服务<br>防火墙放行dns，rich rules放行UDP和TCP的53端口<br><code>systemctl enable named.service</code><br><code>firewall-cmd --add-service=dns --permanent</code><br><code>firewall-cmd --permanent --add-rich-rule=&#39;rule family=ipv4 port port=53 protocol=udp protocol=tcp accept&#39;</code><br><code>firewall-cmd --reload</code></li><li>修改配置文件<br>修改配置文件最好先做备份 <code>cp -a XX XX.bak</code><br>首先修改/etc/named.conf<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">只摘取部分</span><br><span class="line">options &#123;//指定bind服务参数</span><br><span class="line">//listen-on  指定bind侦听的本机IP及端口</span><br><span class="line">listen-on port 53 &#123; any; &#125;;</span><br><span class="line">//要将&#123;&#125;中改为any，本机的任意IP都监听（一台服务器可能有多个IP）</span><br><span class="line">listen-on-v6 port 53 &#123; ::1; &#125;;</span><br><span class="line">//directory 指定区域配置文件的路径</span><br><span class="line">//若使用chroot则该路径是相对路径，对应/var/named/chroot/var/named/</span><br><span class="line">directory &quot;/var/named&quot;;</span><br><span class="line">//改为any，接受任意IP的DNS查询请求</span><br><span class="line">//也可指定网段，只给该网段做DNS</span><br><span class="line">allow-query   &#123; any; &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">zone &quot;.&quot; IN &#123;//指定当前bind可管辖的区域</span><br><span class="line">type hint;//指定区域类型</span><br><span class="line">file &quot;named.ca&quot;;//指定区域配置文件</span><br><span class="line">&#125;;</span><br><span class="line">//以下是区域配置文件和密钥文件</span><br><span class="line">include &quot;/etc/named.rfc1912.zones&quot;;</span><br><span class="line">include &quot;/etc/named.root.key&quot;;</span><br></pre></td></tr></table></figure></li></ul><p>然后修改/etc/named.rfc1912.zones<br>配置正向解析区域文件<br>named.conf中也能写区域配置，但为了安全和管理，将主配置和区域配置分开为两个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;example.com&quot; IN &#123;</span><br><span class="line">type master;    //指定区域类型master</span><br><span class="line">file &quot;example.com.zone&quot;; </span><br><span class="line">//指定区域配置文件路径（相对路径，相对于named.conf中directory指定路径）</span><br><span class="line">//表示若要解析example.com的域名就要去该文件找</span><br><span class="line">allow-update &#123; none; &#125;;</span><br><span class="line">//不允许客户机动态更新解析信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DNS区域类型</p><ul><li>master：主要区域，拥有该区域数据文件，并对此区域提供管理数据</li><li>slave：辅助区域，拥有主要区域数据的只读副本，从主区域同步所有区域数据</li><li>hint：dns启动时，使用hint区域的信息查找最近的根域名服务器，没有就使用默认根服务器</li></ul><p>然后配置解析数据信息文件/var/named/example.com.zone<br>配置文件有模板，可复制/var/named/named.localhost并改名<br>最好将文件名改为域名.zone<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$TTL 1D</span><br><span class="line">@       IN SOA  example.com. root.example.com. (</span><br><span class="line">                                0   ;   serial    //更新序列号</span><br><span class="line">                                1D    ; refresh   //更新时间</span><br><span class="line">                                1H    ; retry     //重试延时</span><br><span class="line">                                1W    ; expire    //失效时间</span><br><span class="line">                                3H )  ; minimum   //无效解析记录的缓存时间</span><br><span class="line">        NS      ns.example.com.</span><br><span class="line">ns      IN A    192.168.163.102</span><br><span class="line">        IN MX 10        mail.example.com.</span><br><span class="line">mail    IN A    192.168.163.102</span><br><span class="line">www     IN A    192.168.163.102</span><br><span class="line"></span><br><span class="line">// TTL 指定资源记录存放在缓存中的时间，单位秒，一般直接调用$TTL的值</span><br><span class="line">// @为当前域，根据主配置文件的zone区域决定</span><br><span class="line">// IN是网络类型，表示自身</span><br><span class="line">// SOA记录：起始授权记录，在一个区域一定是唯一的，定义区域的全局参数</span><br><span class="line">// example.com. DNS区域地址（完整的，要加.根域）</span><br><span class="line">// root.example.com. 服务器邮箱地址（完整）</span><br><span class="line">//NS记录：名称服务器记录，在一个区域至少一条，记录区域的授权服务器，一般就指定为主机名ns</span><br><span class="line">//该记录下一行就指定该服务器的ip地址</span><br><span class="line">//ns 为主机名 A为地址记录，写域名对应IP</span><br><span class="line">//MX邮件交换记录：指定邮件服务器，用于根据收件人地址后缀定位邮件服务器，为管理员自己接收邮件的域名</span><br><span class="line">//其他主机名也是一样</span><br></pre></td></tr></table></figure></p><blockquote><pre><code>主和辅服务器都应该列在上级域的NS记录中，才能形成一个正式的授权。也应该列在自己主机的域文件中，任何列在NS记录中的服务器必须配置为那个域的授权域名服务器。</code></pre></blockquote><p><strong>反向解析配置</strong><br>修改/etc/named.rfc1912.zones，添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zone &quot;163.168.192.in-addr.arpa&quot; IN &#123;</span><br><span class="line">        type master;    # 服务类型master</span><br><span class="line">        file &quot;192.168.163.arpa&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反向解析的参考配置文件为/var/named/named.loopback</p><p>可通过<code>named-checkconf</code>或<code>named-checkzone</code>检查配置文件语法是否正确。<br>至此基础配置完成，重启服务</p><ul><li>使用命令<code>nslookup</code><br>输入域名测试<img src="/2018/01/28/DNS学习笔记/nslookup.png" title="nslookup"></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p><strong>host：</strong>查询某个域名或主机名所对应的所有IP地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># host baidu.com</span><br><span class="line">baidu.com has address 123.125.115.110</span><br><span class="line">baidu.com has address 220.181.57.216</span><br></pre></td></tr></table></figure></p><p><strong>nslookup：</strong>查询一台主机IP及对应的域名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">两种模式：</span><br><span class="line">交互式：不加参数   非交互式：加参数</span><br><span class="line"># nslookup baidu.com</span><br><span class="line">Server:         192.168.163.254</span><br><span class="line">Address:        192.168.163.254#53</span><br><span class="line"></span><br><span class="line"># nslookup</span><br><span class="line">&gt; baidu.com</span><br><span class="line">Server:         192.168.163.254</span><br><span class="line">Address:        192.168.163.254#53</span><br></pre></td></tr></table></figure></p><blockquote><p>参考书籍：<br>骏马金龙 DNS &amp; bind从基础到深入<a href="http://www.cnblogs.com/f-ck-need-u/p/7367503.html" target="_blank" rel="noopener">http://www.cnblogs.com/f-ck-need-u/p/7367503.html</a><br>骏马金龙 Linux的网络管理<a href="http://www.cnblogs.com/f-ck-need-u/p/7074594.html" target="_blank" rel="noopener">http://www.cnblogs.com/f-ck-need-u/p/7074594.html</a><br>Linux就该这么学<br>Linux运维最佳实践<br>Linux系统管理与网络管理<br>Linux服务器架设指南<br>Linux服务器架设、性能调优、集群管理教程</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> server </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
