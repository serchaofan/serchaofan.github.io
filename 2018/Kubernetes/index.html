<!DOCTYPE html>
<html lang="zh-CN">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.7.7'>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="Volantis" content="5.7.7">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="https://tianyigu.top/2018/kubernetes/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
    <link rel="shortcut icon" type='image/x-icon' href="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202202240150263.jpg">
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>Kubernetes - Tianyi的技术随笔</title>
  <meta name="keywords" content="Kubernetes,undefined">
  <meta desc name="description" content="Tianyi的技术随笔 - Tianyi Gu - Tianyi的技术随笔">
  
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes">
<meta property="og:url" content="https://tianyigu.top/2018/Kubernetes/index.html">
<meta property="og:site_name" content="Tianyi的技术随笔">
<meta property="og:description" content="Kubernetes 概述Kubernetes 协调一个高可用的计算机集群，这些计算机连接起来作为一个单元工作，以更有效的方式自动化跨集群分发和调度应用程序容器。kubernetes 具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户应用之称能力、透明的服务注册和服务发现机制、内建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2018-07-13T12:33:37.000Z">
<meta property="article:modified_time" content="2023-04-20T18:13:43.297Z">
<meta property="article:author" content="Tianyi Gu">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #3dd9b6;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.dock .top {
  margin-bottom: 48px;
}
.cover-wrapper.dock .menu {
  background: rgba(255,255,255,0.5);
  position: absolute;
  bottom: 0;
  max-width: 100%;
}
.cover-wrapper.dock .menu .list-h {
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  margin: 4px;
}
.cover-wrapper.dock .menu .list-h a+a {
  margin-left: 4px;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h {
    overflow-x: scroll;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar {
    height: 0;
    width: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece {
    background: transparent;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb {
    background: #3dd9b6;
    cursor: pointer;
    border-radius: 0;
    -webkit-border-radius: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover {
    background: #ff5722;
  }
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.dock .menu {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1580px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1580px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1612px;
    left: calc((100% - 1612px) * 0.5);
  }
}
@media screen and (max-width: 1612px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "env"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: "env",
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1682016589825),
    sidebar: {
      for_page: ["blogger","category","tagcloud"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2020/01/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-sharp fa-solid fa-book fa-fw'></i>文档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="文档"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-sharp fa-solid fa-book fa-fw'></i>文档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="none" class='cover-wrapper post dock' style="display: none;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://gcore.jsdelivr.net/gh/MHG-LAB/cron@gh-pages/bing/bing.jpg"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">Volantis</p>
    
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              active-action="action-v4getting-started">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f5c3.svg'><p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              active-action="action-faqs">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f516.svg'><p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              active-action="action-examples">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f396.svg'><p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              active-action="action-contributors">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f389.svg'><p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              active-action="action-archives">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              active-action="action-https:githubcomvolantis-xhexo-theme-volantis">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f9ec.svg'><p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="https://tianyigu.top/2018/Kubernetes/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Tianyi的技术随笔">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="Tianyi的技术随笔">
    <meta itemprop="description" content="Tianyi的技术随笔">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        Kubernetes
      </h1>
      <div class='new-meta-box'>
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/Kubernetes/">Kubernetes</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/Kubernetes/" itemprop="url"><span itemprop="name">Kubernetes</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2018-07-13T20:33:37+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：2018年7月13日</p>
  </a>
</div>

          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="Kubernetes-概述"><a href="#Kubernetes-概述" class="headerlink" title="Kubernetes 概述"></a>Kubernetes 概述</h1><p>Kubernetes 协调一个高可用的计算机集群，这些计算机连接起来作为一个单元工作，以更有效的方式自动化跨集群分发和调度应用程序容器。kubernetes 具有完备的集群管理能力，包括多层次的安全防护和准入机制、多租户应用之称能力、透明的服务注册和服务发现机制、内建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制，以及多粒度的资源配额管理能力。因此，K8s 是一个全新的基于容器技术的分布式架构解决方案以及一个一站式完备的分布式系统开发和支撑平台。</p>
<p>在 K8s 中，服务（Service）是分布式集群架构的核心。一个 Service 对象的关键特征：</p>
<ul>
<li>一个唯一指定的名字</li>
<li>一个虚拟 IP（Cluster IP、Service IP、VIP）和端口号</li>
<li>提供某种远程服务能力</li>
<li>被映射到提供这种服务能力的一组容器应用上</li>
</ul>
<p>Service 服务进程都基于 Socket 通信对外服务，一个 Service 通常由多个相关服务进程提供服务，每个服务进程都有独立 Endpoint 访问点，但是 k8s 能让我们通过 service 连接到指定的服务。service 一旦创建就不再变化，意味着不需要关心服务 IP 的变化了。</p>
<p>k8s 通过 pod 对象，将每个服务进程包装到相应 pod 中，使其成为 pod 中的一个容器。为了简历 service 和 pod 的映射关系，k8s 首先给每个 pod 打上标签 label，然后给相应的 service 定义标签选择器（label selector）。这样，service 便能选择所有符合标签选择器的 pod。</p>
<p>pod 运行在节点中，一个节点可运行几百个 pod。每个 pod 中有两种容器，一种是 Pause 容器，只有一个，一种是业务容器，业务容器共享 Pause 容器和 Volume 挂载卷，使得数据交换更加高效，因此可以在设计时将多个密切相关的服务进程放入同一个 pod。并不是每个 pod 和里面运行的容器都能映射到一个 service，只有提供服务的一组 pod 才会被映射成一个服务。</p>
<p>K8s 集群节点的两种角色：Master 管理节点和 Nodes 工作节点。</p>
<p><strong>每个节点都有一个 Kubelet，它是管理节点并与 Master 通信的代理。</strong> 该节点还应具有用于处理容器操作的工具，例如 Docker 或 rkt。 <strong>处理生产流量的 Kubernetes 集群应至少有三个节点。</strong></p>
<p>节点使用主服务器公开的 Kubernetes API 与 Master 进行通信。用户还可以直接使用 Kubernetes API 与群集进行交互。</p>
<p>K8s 对外提供容器服务偏向于 Mesos 方式，即用户提交容器集群运行所需要的资源的申请（通常是一个配置文件），然后有 k8s 负责完成这些容器的调度，自动为容器选择运行的宿主机。</p>
<p><strong>K8S 的功能：</strong></p>
<ul>
<li>自动化容器的部署和复制 ，控制器维护 pod 副本数量，保证一个 pod 或一组同类 pod 数量始终可用</li>
<li>随时扩展或收缩容器规模，弹性伸缩，自动缩放 pod 副本数</li>
<li>将容器组织成组（pod），并且提供容器间的负载均衡，集群服务入口为 ClusterIP</li>
<li>服务发现与注册，可使用环境变量或 DNS 插件保证容器中程序发现 pod 入口</li>
<li>使用数据卷，实现 pod 间共享数据</li>
<li>应用程序健康检查，保证健壮性</li>
<li>很容易地升级应用程序容器的新版本，滚动更新，服务不中断，一次更新一个 pod</li>
<li>服务编排，通过文件描述部署服务</li>
<li>资源监控，node 节点集成 cAdvisor 资源收集，通过 Heapster 汇总整个集群节点资源数据，存储到 InfluxDB</li>
<li>提供认证和授权，支持属性访问控制（ABAC）、角色访问控制（RBAC）</li>
</ul>
<h2 id="k8s-结构与组件"><a href="#k8s-结构与组件" class="headerlink" title="k8s 结构与组件"></a>k8s 结构与组件</h2><p><strong>Master</strong>节点组件：Master 也可以叫做控制平面（Control Plane）</p>
<ul>
<li><strong>kube-apiserver</strong>：K8s API，集群的统一入口，以 HTTP API 提供接口服务，所有对象资源的增删改查和监听工作都交给 API Server 处理，再交给 etcd 存储（可选），是集群控制的入口进程。是无状态应用，可运行多个以用于平衡实例请求的流量。</li>
<li><strong>kube-controller-manager</strong>：控制器管理，k8s 资源对象的自动化控制中心，可理解为资源对象的大总管。处理集群中常规后台任务，一个资源对应一个控制器。</li>
<li><strong>kube-scheduler</strong>：用于 watch 监听 apiserver 的资源变动，并根据调度算法调度到合适的后端节点，从而创建 pod。</li>
</ul>
<p>Master 流程概述：用户通过 API、web、CLI 向 apiserver 发送请求，kube-scheduler 监听 apiserver 的资源变动，同时通过调度算法从 node 中选出最适合的节点开始调度，并将调度的结果存在 etcd 中。</p>
<p><strong>Node</strong>节点组件：Node 也可以叫做数据平面（Data Plane）</p>
<ul>
<li><strong>kubelet</strong>：Master 在 Node 上的 Agent，<strong>管理本机运行的容器的生命周期</strong>，如创建容器、挂载数据卷，获取节点状态等工作，将每个 pod 转换为一组容器。</li>
<li><strong>kube-proxy</strong>：在 Node 节点上实现 pod 网络代理，<strong>维护网络规划和四层负载均衡</strong>工作，实现<strong>k8s service 的通信和负载均衡</strong>。</li>
<li><strong>Container-Runtime</strong>：底层容器引擎，如 docker、rkt 等。</li>
</ul>
<p>Node 流程概述：kubelet 监听 apiserver 的资源变动，在符合的 node 上通过 kubelet 调用相关 docker 进行后续打包构建。Node 节点能在运行期间动态添加到 k8s 集群中，在默认情况下 kubelet 会向 Master 注册自己，这也是 Kubernetes 推荐的 Node 管理方式。<br>一旦 Node 被纳入集群管理范围， kubelet 进程就会定时向 Master 节点汇报自身的情报，例如操作系统、 Docker 版本、机器的 CPU 和内存情况，以及当前有哪些 Pod 在运行等 ， 这样 Master 可以获知每个 Node 的资源使用情况，并实现高效均衡的资源调度策略。而某个 Node 超过指定时间不上报信息时，会被 Master 判定为“<strong>失联</strong>”， Node 的状态被标记为<strong>不可用</strong>（ Not Ready ），随后 Master 会触发“工作负载大转移”的自动流程 。</p>
<p>第三方服务：</p>
<ul>
<li><strong>etcd</strong>：分布式键值存储系统，用于保持集群状态，如 pod、service 对象信息。</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071602665.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071602665.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ul>
<li><strong>cloud-controller-manager</strong>：K8s 与云厂商提供的服务能力对接的关键组件，也称 k8s cloudprovider。</li>
</ul>
<h2 id="k8s-基础对象"><a href="#k8s-基础对象" class="headerlink" title="k8s 基础对象"></a>k8s 基础对象</h2><p>k8s 提供如 Pod、Service、Namespace、Volume 的基础对象</p>
<ul>
<li>pod：最小的部署单元，包含一组容器和卷。同一个 Pod 里的容器共享同一个网络命名空间，可以使用 localhost 互相通信。Pod 是短暂的，不是持续性实体。</li>
<li>service：是一个应用服务抽象，定义了<strong>pod 逻辑集合</strong>和<strong>访问这个 pod 集合的策略</strong>，对外提供一个访问入口，会有一个集群的 IP 地址，会将目的是该 IP 的请求负载均衡到 pod 的容器。</li>
<li>volume：存储卷，支持很多类型的存储系统，如分布式存储、临时存储、网络存储等</li>
<li>namespace：名称空间，即资源的作用域</li>
<li>label：标签，用于区分对象（pod，service），每个对象可以有多个标签，可通过标签关联对象。</li>
</ul>
<p>基于基本对象的更高层次抽象，称为 Controller 控制器，提供额外的功能。</p>
<ul>
<li><p>ReplicaSet：下一代的 Replication Controller。确保任何给定时间指定的 pod 副本数量，并提供声明式更新等功能。</p>
<blockquote>
<p>Replication Controller：确保任意时间都有指定数量的 Pod 副本在运行。能根据指定的副本数量动态增加或删除副本。<br>ReplicaSet 和 Replication Controller 的区别：前者支持新的基于集合的标签，后者仅支持基于等式的标签</p>
</blockquote>
</li>
<li><p>Deployment：管理 ReplicaSets 和 pod，提供声明式更新等功能。官方建议用 Deployment 管理 ReplicaSets，而不是直接使用 ReplicaSets。</p>
</li>
<li><p>StatefulSet：适合持久化的应用，具有唯一的网络标识符（IP 地址）、持久存储、有序部署、扩展、删除和滚动更新。</p>
</li>
<li><p>DaemonSet：确保所有或一些节点运行同一个 pod，当节点加入 k8s 集群中，pod 会被调度到该节点上运行，当节点从集群中删除时，pod 也会被删除。</p>
</li>
<li><p>Job：一次性任务，运行完成后 pod 销毁。</p>
</li>
</ul>
<h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><h4 id="Pause容器"><a href="#Pause容器" class="headerlink" title="Pause容器"></a>Pause容器</h4><p>每个 Pod 都有一个特殊的被称为“根容器”的 <strong>Pause 容器</strong> 。 Pause 容器对应的镜像属于 Kubenetes 平台的一部分，除了 Pause 容器，每个 Pod 还包含一个或多个紧密相关的用户业务容器。</p>
<p>设置该 Pause 容器的目的：</p>
<ul>
<li>引入与业务无关且不宜死亡的 Pause 容器作为 pod 的根容器，以它的状态代表整个容器组的状态，为每个pod提供1号进程，并收集pod内的僵尸进程。</li>
<li>pod 的多个业务容器共享 Pause 容器的 IP，共享 Pause 容器挂接的 Volume，既简化了密切关联的业务容器之间的通信问题，也解决了它们之间的文件共享问题。</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202207161821472.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202207161821472.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>k8s 为每个 pod 分配一个 <strong>pod IP</strong>，pod 的<strong>容器组共享 pod IP</strong>，k8s 要求底层网络支持集群内任意两个 pod 之间的 TCP&#x2F;IP 直接通信，通常通过虚拟二层网络实现（如 Flannel、Open vSwitch）。<strong>在 k8s 中，一个 pod 里的容器能直接与另一主机上的 pod 的容器通信。</strong></p>
<h4 id="pod类型"><a href="#pod类型" class="headerlink" title="pod类型"></a>pod类型</h4><ul>
<li>普通 pod：一旦被创建，就会放入 etcd 存储，随后被 k8s master 调度到某个具体 node 上并进行绑定，该 pod 被对应 Node 上的 kubelet 进程实例化成一组相关 docker 容器并启动。若 pod 中某个容器停止，则 k8s 会直接重启这个 pod，若 node 宕机，则 k8s 会将 node 上所有 pod 重新调度到其他 node。</li>
<li>静态 pod：没有被存放在 etcd 中，而是存放在某个具体的 node 上一个文件中，只能在此 node 上运行启动。</li>
</ul>
<p>Pod Volume：被定义在 pod 上，然后被各自的容器挂载到自己的文件系统中，能实现一些扩展。</p>
<p>每个 pod 都可以对其能使用的计算资源设置限额，包括 CPU 和内存，cpu 的资源单位为 cpu 数量，<strong>在 k8s 中以千分之一的 cpu 配额为最小单位（m 表示）</strong>，<strong>cpu 配额是绝对值</strong>。通常一个容器的 cpu 配额被定义为 <strong>100-300m，即占用 0.1-0.3 个 cpu</strong>。内存配额也是绝对值，单位是内存字节数。</p>
<p>在 k8s 中，进行配额需设置两个参数：</p>
<ul>
<li>Requests：该资源的最小申请量，系统必须满足要求</li>
<li>Limits：该资源的最大允许使用量，不能突破，当容器试图超过这个量时，k8s 会杀掉该容器并重启</li>
</ul>
<p>通常会把 Requests 设置为一个较小的数值，符合容器平时负载的要求，把 Limits 设为峰值负载下最大资源占用量。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">例：</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 Kubernetes 中运行的 Pod 正在一个私密的隔离网络上运行。默认情况下，它们可以从同一个 kubernetes 集群中的其他 pod 和服务中看到，但不能在该网络之外。当我们使用 kubectl 时，我们通过 API 端点进行交互以与我们的应用程序进行通信。</p>
<p>kubectl 命令可以创建一个代理，将代理转发到群集范围的专用网络。</p>
<h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>label 标签时一个 key-val 键值对，可被附加到各种资源对象上，一个资源对象可定义任意数量 label，同个 label 可被添加到任意数量资源对象上。label 通常在资源对象定义时确定，也可在对象创建后动态添加或删除。</p>
<p>常见 label 示例：</p>
<ul>
<li>版本标签：<code>release: stable</code>、<code>release: canary</code></li>
<li>环境标签：<code>environment: dev</code>、<code>environment: qa</code>、<code>environment: production</code></li>
<li>架构标签：<code>tier: frontend</code>、<code>tier: backend</code>、<code>tier: middleware</code></li>
<li>分区标签：<code>partition: customerA</code>、<code>partition: customerB</code></li>
<li>质量管控标签：<code>track: daily</code>、<code>track: weekly</code></li>
</ul>
<p>通过 Label Selector（标签选择器）查询与筛选指定 label 的资源对象，实现了类似 sql 的简单查询机制。<br>有两种 label selector 表达式：</p>
<ul>
<li>基于等式：例：<code>name=xxx</code>（具有标签）和<code>env!=xxx</code>（不具有标签）</li>
<li>基于集合：例：<code>name in (xxx,xxxx)</code>（具有标签）和<code>name not in (xxx,xxxx)</code>（不具有标签）</li>
</ul>
<p>多个表达式之间用<code>,</code>分隔。</p>
<p><strong>管理对象 RC 和 Service 通过 selector 字段设置关联 pod 的 label</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">例：</span></span><br><span class="line"><span class="comment"># pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-1</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理对象</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span> <span class="comment"># 或 Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web-1</span></span><br><span class="line">  <span class="string">.....</span></span><br></pre></td></tr></table></figure>

<p><strong>其他管理对象如 Deployment、ReplicaSet、DaemonSet、Job 可通过 Selector 使用集合筛选条件</strong><br><code>matchLabels</code>定义一组 label，和直接写在<code>selector</code>中一样。<code>matchExpressions</code>定义一组基于集合的筛选条件，可用的条件运算符包含<code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>DoesNotExists</code>。若同时设置了<code>matchLables</code>和<code>matchExpressions</code>，则为 AND 关系。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">matchLabels:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">matchExpressions:</span></span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">tier</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">frontend</span>] &#125;</span><br><span class="line">  <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">environment</span>, <span class="attr">operator:</span> <span class="string">NotIn</span>, <span class="attr">values:</span> [<span class="string">dev</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>label selector 的常见使用场景：</p>
<ul>
<li>kube-controller 在 RC 上定义的 label selector 来筛选要监控的 pod 副本数量，使 pod 副本数量始终符合预期</li>
<li>kube-proxy 通过 Service 的 label selector 选择对应 pod，自动建立每个 Service 到对应 pod 的请求转发路由表，实现 Service 的智能负载均衡</li>
<li>对某些 node 定义特殊 label，并在 pod 定义文件中使用 NodeSelector 标签调度策略，kube-scheduler 可实现 pod 定向调度的特性。</li>
</ul>
<h3 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h3><p>用于声明某种 pod 的副本个数在任何时刻都符合某个预期值。RC 包含以下部分：</p>
<ul>
<li>Pod 的期望数量</li>
<li>筛选 Pod 的 Label Selector</li>
<li>当 Pod 副本数量小于预期时，用于创建新 Pod 的 Pod 模板</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">例：</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line">  <span class="string">......</span></span><br></pre></td></tr></table></figure>

<p>当定义一个 RC 并提交到 K8s 集群后，Master 上的 Controller Manager 就会得到通知，定期巡检系统中存活的目标 Pod，确保目标 Pod 实例数量刚好等于 RC 的期望值，若超出则停掉些 Pod，若不足则新建些 Pod。可通过修改 RC 的期望值，实现 Pod 的动态缩放（Scaling）。<br>删除 RC 不会影响该 RC 已创建的 Pod，若要删除所有指定 Pod，可以将<code>replicas</code>设为 0 并更新即可。</p>
<p>滚动升级（Rolling Update）：旧版本的 Pod 每停止一个，就同时创建一个新版本的 Pod，通过 RC 就很容易实现。</p>
<p>RC 的升级版 Replica Set，支持两种 Label Selector，但目前很少单独使用，主要是被 Deployment 调用，从而形成一套 Pod 创建、删除、更新的编排机制。RepliaSet 和 Deployment 逐渐替代了 RC。</p>
<h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 用于更好解决 Pod 的编排问题，为此，Deployment 在内部使用了 <strong>ReplicaSet</strong> 来实现。Deployment 能让我们随时知道 Pod 的部署进程。</p>
<p>Deployment 的典型应用场景：</p>
<ul>
<li>创建一个 Deployment 对象来生成对应的 ReplicaSet 并完成 Pod 副本创建</li>
<li>检查 Deployment 状态来查看部署是否完成（Pod 是否达到指定数量）</li>
<li>更新 Deployment 创建新 Pod</li>
<li>若当前 Deployment 不稳定，则回滚到上一个 Deployment 版本</li>
<li>暂停 Deployment 以便一次性修改多个 PodTemplateSpec 配置项，之后再恢复 Deployment 进行新发布</li>
<li>扩展 Deployment 应对高负载</li>
<li>查看 Deployment 状态，了解发布是否成功</li>
<li>清除不再需要的旧版本 ReplicaSet</li>
</ul>
<h3 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h3><p>很多服务，尤其是中间件集群，如 Mysql、MongoDB、Akka、Zookeeper 等，都是有状态的。这些集群有以下共同点：</p>
<ul>
<li>每个节点都有固定的身份 ID，通过 ID 集群中成员可互相发现并通信</li>
<li>集群规模是比较固定的，集群规模不能随意变动</li>
<li>集群中的每个节点都是有状态的，通常会持久化数据到永久存储中</li>
<li>若磁盘损坏，则集群中某个节点无法正常运行，集群功能受损</li>
</ul>
<p>StatefulSet 可以看作 Deployment&#x2F;RC 的一个特殊变种，有以下特性：</p>
<ul>
<li>StatefulSet 中每个 Pod 都有稳定、唯一的网络标识，可用于发现集群中其他成员</li>
<li>StatefulSet 控制的 Pod 副本的启停顺序是受控的，操作第 n 个 pod 时，前 n-1 个 Pod 已经运行且准备好</li>
<li>StatefulSet 中 pod 采用稳定的持久化存储卷，通过 PV 或 PVC 实现，删除 Pod 默认不会删除与 StatefulSet 相关的存储卷</li>
</ul>
<p>StatefulSet 除了与 PV 卷捆绑使用存储 pod 状态数据，还要与 Headless Service 配合使用，每个 StatefulSet 定义都要声明属于哪个 Headless Service。</p>
<blockquote>
<p>Headless Service 和普通 Service 的区别在于：Headless Service 没有 ClusterIP。若解析 Headless Service 的 DNS 域名，则返回的是该 Service 对应所有的 Pod 的 Endpoint 列表</p>
</blockquote>
<p>StatefulSet 在 Headless Service 基础上又为 Headless Service 控制的每个 Pod 实例创建一个 DNS 域名，格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(podname).$(Headless Service name)</span><br></pre></td></tr></table></figure>

<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>每个 Service 就算是一个微服务。Service 定义一个服务的访问入口，前端的应用 pod 通过该入口地址访问其背后的一组 pod 副本组成的集群，而 Service 通过 Label Selector 与后端 pod 对接。最终系统由多个提供不同业务能力又相互独立的微服务单元组成，服务间通过 TCP&#x2F;IP 网络通信，形成强大的弹性网络。</p>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/3.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p><strong>客户端如何访问由多个 Pod 副本组成的集群？</strong>通过 node 上的 <strong>kube-proxy</strong> 进程，kube-proxy 是一个智能的负载均衡器，负责把对 Service 的请求转发到后端的某个 Pod 实例上，并在内部实现服务的负载均衡和会话保持，且 Service 没有共用一个负载均衡器的 IP，<strong>每个 Service 都被分配一个全局唯一虚拟 IP，称为 Cluster IP，导致每个服务变成具备唯一 IP 地址的节点，服务调用变成了 TCP 网络通信</strong>。<br>Service 一旦创建，k8s 就自动为它分配一个可用 Cluster IP，且<strong>在 Service 的整个生命周期中，Cluster IP 不会发生改变。所以服务发现只要用 Service 的 Name 和 Cluster IP 做 DNS 映射即可。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Service</span> <span class="string">Name</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">app:</span> <span class="string">Selector</span> <span class="string">Label</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">LoadBalancer</span> <span class="string">|</span> <span class="string">ClusterIP</span> <span class="string">|</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">name-of-the-port</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span> <span class="comment"># 提供服务的容器内暴露的端口。若不指定targetPort，则默认targetPort和Port相同</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClusterIP：Service 通过 Cluster 内部 IP 对外提供服务，只有 Cluster 内的节点和 Pod 可访问。默认为 ClusterIP</li>
<li>NodePort：Service 通过 Cluster 节点的静态端口对外提供服务。CLuster 外部可直接通过<NodeIP>:<NodePort>访问服务。若不指定 nodePort 参数，则 k8s 会从 30000-32767 中选一个作为端口号。</li>
<li>LoadBalancer：Service 利用 Cloud Provider 特有的 Load Balancer 对外提供服务，Cloud Provider 负责将 Load Balancer 的流量导向 Service</li>
</ul>
<p>k8s 服务支持多个 Endpoint，并要求每个 Endpoint 都定义一个名称来区分。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">name-of-the-port</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">name-of-the-port</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">808</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p>Cluster IP 是一种虚拟 IP，但更像一个伪造的 IP，原因如下：</p>
<ul>
<li>Cluster IP 仅作用于 Service 对象，并由 K8s 管理分配 IP 地址（来自 Cluster IP 地址池）</li>
<li>Cluster IP 无法被 ping，因为没有一个实体网络对象来响应</li>
<li>Cluster IP 只能结合 Service Port 组成一个具体的通信端口，单独的 Cluster IP 不具备 TCP&#x2F;IP 通信基础，并且属于 k8s 集群这个封闭的空间，外部若要访问该端口，需要做额外工作</li>
<li>k8s 集群内，Node IP 网、Pod IP 网与 Cluster IP 网之间通信采用 k8s 自己的特殊路由规则，不同于传统 IP 路由。</li>
</ul>
<p>因为 Cluster IP 是集群内部的地址，外界无法直接访问该地址，所以若有要提供给外界的服务，需要用添加 NodePort 参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">selector:</span></span><br><span class="line"><span class="attr">tier:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">8888</span> <span class="comment"># 定义了NodePort，则外界可通过Node IP:nodePort 访问tomcat服务</span></span><br></pre></td></tr></table></figure>

<p>NodePort 实现方式：在 K8s 集群的每个 Node 上都为需要外部访问的 Service 开启一个对应的 TCP 监听端口（kube-proxy 进程开的），外部系统只要用任意一个 Node IP+NodePort 即可访问该服务。</p>
<p>若集群中有多个 Node，则需要借助负载均衡器，外部请求访问负载均衡器 IP，由负载均衡器转发流量到某个 Node 的 Nodeport 上。对于每个 Service，通常要配置一个对应的 Load Balancer，k8s 提供了自动化创建方案，只要将 spec.type 的值设为 LoadBalancer，k8s 就会自动创建一个对应的负载均衡器，并返回它的 IP 地址供外部访问。</p>
<h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>批处理任务通常并行启动多个计算进程处理一批工作项，处理完成后整个批处理任务结束。可通过 k8s Job 启动一个批处理任务。Job 也是一种特殊的 pod 副本自动控制器，但与 RC 的区别如下：</p>
<ul>
<li>job 控制的 pod 副本是短暂运行的，且不能自动重启（RestartPolicy 都被设为了 Never）。k8s 也提供 CronJob，能够反复定时执行某批处理任务。</li>
<li>job 控制的 pod 副本的工作模式能够多实例并行计算</li>
</ul>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>volume 是 Pod 中能被多个容器访问的共享目录，被定义在 pod 上，被该 pod 的容器挂载到各自的具体目录，Volume 的生命周期也与 Pod 一致，与容器不相关，即 pod 中容器重启停止不影响 volume，K8s 也支持多种类型 Volume。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">volume</span></span><br><span class="line">  <span class="attr">mountPath:</span>  <span class="string">Path</span> <span class="string">to</span> <span class="string">mount</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span>  <span class="string">image</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">my-name</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span>  <span class="string">Name</span> <span class="string">of</span> <span class="string">the</span> <span class="string">Volume</span></span><br><span class="line">    <span class="attr">mountPath:</span>  <span class="string">Path</span> <span class="string">to</span> <span class="string">mount</span></span><br></pre></td></tr></table></figure>

<p>k8s 提供的 volume 类型：</p>
<ol>
<li>临时目录：随pod销毁而销毁</li>
</ol>
<ul>
<li>emptyDir：在 Pod 分配到 Node 时创建的，初始内容为空，无须指定宿主机上的目录文件。可用作临时空间、中间过程 CheckPoint 的临时保存目录、一个容器需从另一容器中获取数据的目录</li>
</ul>
<ol start="2">
<li>配置类：将配置以volume形式挂载到pod内</li>
</ol>
<ul>
<li>configMap</li>
<li>secret：一个 Secret Volume 为 Pod 提供加密信息</li>
<li>downwardAPI：将downward API数据以环境变量或文件形式注入容器</li>
<li>gitRepo：挂载一个空目录，从 git 库中 clone 一个仓库供 pod 使用</li>
</ul>
<ol start="3">
<li>本地存储类</li>
</ol>
<ul>
<li>hostPath：在 Pod 上挂载宿主机上的文件或目录。可用于容器的应用日志文件永久保存、定义 hostPath 为宿主机的<code>/var/lib/docker</code>使容器内应用能访问 docker 文件系统。<blockquote>
<p>需要注意：不同 node 上相同配置的 Pod 可能因为宿主机目录和文件不同而对 volume 的目录文件访问结果不一致。若使用资源配额管理，则 k8s 无法将 hostPath 在宿主机上的资源纳入管理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Volume</span> <span class="string">Name</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">Path</span> <span class="string">to</span> <span class="string">mount</span></span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>local：将本地存储以PV形式提供给容器，并能实现存储空间的管理</li>
</ul>
<ol start="4">
<li>共享存储类</li>
</ol>
<ul>
<li>PV</li>
<li>PVC</li>
</ul>
<h3 id="Persistent-Volume"><a href="#Persistent-Volume" class="headerlink" title="Persistent Volume"></a>Persistent Volume</h3><p>Persistent Volume（简称 PV）可被理解为 k8s 集群中某个网络存储对应的一块存储</p>
<ul>
<li>PV 只能是网络存储，不属于任何 Node，但可在 Node 上访问</li>
<li>PV 不是被定义在 Pod 上的，而是独立于 Pod 定义的</li>
<li>PV 比 Volume 支持更多的存储类型</li>
</ul>
<h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>命名空间多用于实现多租户资源隔离，将集群内部的资源对象分配到不同的 Namespace 中，逻辑上形成分组的不同项目、小组、用户组等，不同组共享集群资源同时还能被分别管理。</p>
<p>集群启动后会自动创建一个叫 default 的 Namespace，若不指明 namespace，则创建的 Pod 等资源就使用该 namespace。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>

<h3 id="Autonation"><a href="#Autonation" class="headerlink" title="Autonation"></a>Autonation</h3><p>Autonation 注解，是用户任意定义的附加信息，以便外部工具查找。</p>
<p>通常 Annotation 记录：</p>
<ul>
<li>build 信息、release 信息、Docker 镜像信息等</li>
<li>日志库、监控库、分析库等资源库的地址信息</li>
<li>程序调试工具信息</li>
<li>团队联系信息</li>
</ul>
<h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p>问题：如何在运行时修改配置文件中的内容？<br>常规想法：通过 Docker Volume 将主机上的配置文件映射到容器中<br>引出问题：这种方法必须在主机上先创建配置文件，才能映射到容器。若是在分布式环境下，配置文件的管理与一致性很难控制。<br>K8S 解决方案：所有配置项都当作 key-value 字符串，作为 Map 表中的一个项，整个 Map 的数据可被持久化存储在 k8s 的 Etcd 中，然后提供 API 方便 k8s 组件或应用操作这些数据，这个 Map 就是 ConfigMap 资源对象。接着，K8S 提供一种内建机制，将存储在 etcd 中的 ConfigMap 通过 Volume 映射变成 Pod 内的配置文件，不论 Pod 调度到哪个主机，都能自动完成映射。若 ConfigMap 中的键值对改变，则 Pod 上的配置文件也会更新。</p>
<p>ConfigMap 典型用法：</p>
<ul>
<li>生成为容器内的环境变量</li>
<li>设置容器启动命令的启动参数（需设为环境变量）</li>
<li>以 Volume 形式挂载为容器内部的文件或目录</li>
</ul>
<h2 id="k8s-如何进行版本升级"><a href="#k8s-如何进行版本升级" class="headerlink" title="k8s 如何进行版本升级"></a>k8s 如何进行版本升级</h2><p>k8s 在声明资源对象时，有个关键属性放在最开头，<code>apiVersion: v1</code>。<br>K8s 采用“核心+外围扩展”的设计思路，在保持平台核心稳定的同时，具备持续演进升级的优势。k8s 大部分常见的核心资源对象都归属于 v1 这个核心 API。随着 k8s 版本升级，一些资源对象会引入新的属性，在不影响当前功能的情况下，有两种做法：</p>
<ol>
<li>在设计数据库表时，会在每个表增加一个很长的备注字段，之后扩展的数据就以某种格式（xml、json 或简单字符串）放入备注字段，因此表结构没改变，程序风险也小，但不美观</li>
<li>直接修改数据库，增加列，但程序改动大，风险大，虽然看上去美观</li>
</ol>
<p>于是，k8s 采用先方法 1，再方法 2 的做法。先采用方法 1，等新特性稳定成熟后，采用方法 2 升级到正式版。为此，k8s 为每个资源对象增加了一个类似备注字段的属性<code>Annotations</code>，以实现方法 1 的升级。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">例：</span></span><br><span class="line"><span class="string">先是方法1</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">.....</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">pod.beta.kubernetes.io/init-containers:</span> <span class="string">&#x27;[</span></span><br><span class="line"><span class="string">      &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;init-mydb&quot;,</span></span><br><span class="line"><span class="string">        &quot;image&quot;: &quot;busybox&quot;,</span></span><br><span class="line"><span class="string">        &quot;command&quot;: [......]</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    ]&#x27;</span></span><br><span class="line"><span class="string">.....</span></span><br><span class="line"></span><br><span class="line"><span class="string">等成熟后采用方法2升级以后</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="string">......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">init-mydb</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">xxx</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h2 id="K8s-开放接口"><a href="#K8s-开放接口" class="headerlink" title="K8s 开放接口"></a>K8s 开放接口</h2><p>K8s 开放以下接口，用于对接不同后端，实现不同业务逻辑。</p>
<ul>
<li>CRI：Container Runtime Interface 容器运行时接口，提供计算服务</li>
<li>CNI：Container Network Interface 容器网络接口，提供网络服务</li>
<li>CSI：Container Storage Interface 容器存储接口，提供存储服务</li>
</ul>
<h3 id="CRI"><a href="#CRI" class="headerlink" title="CRI"></a>CRI</h3><p>CRI 中定义了<strong>容器和镜像的服务</strong>的接口，因为容器运行时与镜像的生命周期是彼此隔离的。CRI 包含了 Protocol Buffers、gRPC API、运行库支持以及开发标准规范和工具。CRI 在 kubelet 启动时默认启动。</p>
<p>无论 docker 还是 rkt 都用到了 kubelet 内部接口，导致定制开发难度增加，因此 CRI 接口规范用定义清晰的抽象层清除这一壁垒，当开发者能专注于容器运行时本身。</p>
<p>kubelet 使用 gRPC 框架通过 unix socket 与 CRI 代理（shim）进行通信，这个过程中 kubelet 是客户端，shim 是服务端。<br><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071603640.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071603640.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>Protocol Buffers 包含两个 gRPC 服务：ImageService、RuntimeService</p>
<ul>
<li>ImageService 提供仓库拉取镜像、查看、移除镜像功能</li>
<li>RuntimeService 负责 Pod 和容器生命周期管理以及与容器交互</li>
</ul>
<p>目前支持 CRI 的后端：</p>
<ul>
<li>cri-o：cri-o 是 Kubernetes 的 CRI 标准的实现，并且允许 Kubernetes 间接使用 OCI 兼容的容器运行时，可以把 cri-o 看成 Kubernetes 使用 OCI 兼容的容器运行时的中间层。</li>
<li>cri-containerd：基于 Containerd 的 Kubernetes CRI 实现</li>
<li>rkt：CoreOS 开发的容器运行时</li>
<li>frakti：基于 hypervisor 的 CRI</li>
<li>docker</li>
</ul>
<h3 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h3><p>目前主流容器网络模型主要有 docker 公司提出的 Container Network Model（CNM）和 CoreOS 提出的 Container Network Interface（CNI）。而 k8s 采用的是 CNI 模型。</p>
<p>CNM：主要通过 network sandbox、endpoint、network 三个组件实现</p>
<ul>
<li>network sandbox：容器内部网络栈，包括网络接口、路由表、DNS 等配置管理。一个 sandbox 能包含多个 endpoint。</li>
<li>endpoint：用于将容器内 sandbox 与外界相连的接口。一般用 veth 对、open vswitch 的内部 port 等技术实现。一个 endpoint 只能加入一个 network</li>
<li>network：可直接互联的 endpoint 的集合，通过 linux 网桥、VLAN 等技术实现。一个 network 包含多个 endpoint</li>
</ul>
<p>CNI 由一组用于配置 Linux 容器的网络接口的规范和库组成，同时还包含了一些插件。在 CNI 只涉及两个概念：容器和网络，CNI 仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。<br>该接口只有四个方法，添加网络、删除网络、添加网络列表、删除网络列表。</p>
<p>CNI 插件包含 3 个基本接口定义：添加 ADD、删除 DELETE、检查 CHECK、版本检查 VERSION</p>
<p>CNI 的设计考量：</p>
<ul>
<li>容器运行时必须在调用任何插件之前为容器创建一个新的网络命名空间。然后，运行时必须确定这个容器应属于哪个网络，并为每个网络确定哪些插件必须被执行。</li>
<li>网络配置采用 JSON 格式，可以很容易地存储在文件中。网络配置包括必填字段，如 name 和 type 以及插件（类型）。网络配置允许字段在调用之间改变值。为此，有一个可选的字段 args，必须包含不同的信息。</li>
<li>容器运行时必须按顺序为每个网络执行相应的插件，将容器添加到每个网络中。</li>
<li>在完成容器生命周期后，运行时必须以相反的顺序执行插件（相对于执行添加容器的顺序）以将容器与网络断开连接。</li>
<li>容器运行时不能为同一容器调用并行操作，但可以为不同的容器调用并行操作。</li>
<li>容器运行时必须为容器订阅 ADD 和 DEL 操作，这样 ADD 后面总是跟着相应的 DEL。 DEL 可能跟着额外的 DEL，但是，插件应该允许处理多个 DEL（即插件 DEL 应该是幂等的）。</li>
<li>容器必须由 ContainerID 唯一标识。存储状态的插件应该使用（网络名称，容器 ID）的主键来完成。</li>
<li>给定的容器 ID 必须只能添加到特定的网络一次。</li>
</ul>
<p>CNI 插件必须支持的操作：</p>
<ul>
<li>将容器添加到网络</li>
<li>从网络中删除容器</li>
</ul>
<h3 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h3><p>CSI 用于在 k8s 和外部存储系统之间建立一套标准的存储管理接口，通过该接口为容器提供存储服务。</p>
<p>k8s 通过 PV、PVC、Storageclass 已经提供了基于插件的存储管理机制，但是这些存储服务都是基于 in-tree 方式提供。因此，k8s 推出与容器对接的存储接口标准 CSI，基于 CSI 的存储插件机制也称为 out-of-tree 方式。</p>
<blockquote>
<p>in-tree：存储插件的代码必须放在 k8s 主干代码库才能被 k8s 调用，属于紧耦合开发模式，若存储插件代码出错可能会影响 k8s 的核心组件，存在安全和可靠性问题<br>out-of-tree：存储提供方只需要基于接口标准进行存储插件实现，就能使用 k8s 原生存储机制为容器提供存储服务，实现存储提供方代码与 k8s 彻底解耦</p>
</blockquote>
<p>CSI 存储关键组件：</p>
<ul>
<li>CSI Controller：提供存储服务视角对存储资源和存储卷进行管理操作。k8s 推荐将其部署为单实例 Pod，可使用 StatefulSet 和 Deployment 控制器进行部署，设置副本数量为 1，保证为一种存储插件只运行一个控制器实例。</li>
<li>CSI Node：对主机 Node 上的 Volume 进行管理和操作，k8s 建议部署为 DaemonSet，在每个 Node 上都运行一个 Pod</li>
</ul>
<h1 id="k8s-部署要点"><a href="#k8s-部署要点" class="headerlink" title="k8s 部署要点"></a>k8s 部署要点</h1><p>若是在<strong>测试环境</strong>：</p>
<ul>
<li>可使用单 master，单 etcd</li>
<li>node 节点按需分配</li>
<li>存储直接用 nfs 或 glusterfs</li>
</ul>
<p>若是在<strong>生产环境</strong>：</p>
<ul>
<li>高可用的 etcd 集群（需定期备份 etc 数据文件），建立 3 或 5 或 7 个节点，保证冗余能力</li>
<li>master 一定要高可用<ul>
<li>kube-apiserver 要多实例部署，借助 haproxy、nginx 或 keepalived 实现高可用</li>
<li>kube-scheduler 和 kube-controller-manager 只能有一个活动实例，但可以有多个备用（主备）</li>
</ul>
</li>
<li>node：数量越多，冗余和负载能力越强</li>
<li>集群存储建议：Ceph、GlusterFS、iSCSI 及云存储</li>
</ul>
<p>kubectl启用自动补全。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>确认关闭 swap，并将<code>/proc/sys/net/bridge/bridge-nf-call-iptables</code>设为 1。在 Node 上也要这样设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sysctl -w net.bridge.bridge-nf-call-iptables=1</span><br></pre></td></tr></table></figure>

<p>若要设置详细的系统参数，可以添加内容到<code>/etc/sysctl.d/kubernetes.conf</code>中，并<code>sysctl -p /etc/sysctl.d/kubernetes.conf</code></p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">net.bridge.bridge-nf-call-iptables</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">net.bridge.bridge-nf-call-ip6tables</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.ip_forward</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">net.ipv4.tcp_tw_recycle</span>=<span class="number">0</span>   <span class="comment"># tcp_tw_recycle 和 Kubernetes 的 NAT 冲突，必须关闭 ，否则会导致服务不通</span></span><br><span class="line"><span class="attr">vm.swappiness</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">vm.overcommit_memory</span>=<span class="number">1</span></span><br><span class="line"><span class="attr">vm.panic_on_oom</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">fs.inotify.max_user_watches</span>=<span class="number">89100</span></span><br><span class="line"><span class="attr">fs.file-max</span>=<span class="number">52706963</span></span><br><span class="line"><span class="attr">fs.nr_open</span>=<span class="number">52706963</span></span><br><span class="line"><span class="attr">net.ipv6.conf.all.disable_ipv6</span>=<span class="number">1</span>   <span class="comment"># 不使用的 IPV6 协议栈，防止触发 docker BUG</span></span><br><span class="line"><span class="attr">net.netfilter.nf_conntrack_max</span>=<span class="number">2310720</span></span><br></pre></td></tr></table></figure>

<h2 id="配置使用ipvs模式"><a href="#配置使用ipvs模式" class="headerlink" title="配置使用ipvs模式"></a>配置使用ipvs模式</h2><p>确保安装了ipvs相应软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y conntrack-tools ipset ipvsadm</span><br></pre></td></tr></table></figure>
<p>加载内核模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe ip_vs</span><br><span class="line">modprobe ip_vs_rr</span><br><span class="line">modprobe ip_vs_wrr</span><br><span class="line">modprobe ip_vs_sh</span><br><span class="line"></span><br><span class="line">modprobe nf_conntrack        # linux内核&gt;=4.19</span><br><span class="line">modprobe nf_conntrack_ipv4   # linux内核&lt;4.19</span><br></pre></td></tr></table></figure>
<p>使用systemd-modules-load.service系统服务配置自动加载ipvs模块。<br>首先创建文件<code>/etc/modules-load.d/10-k8s-modules.conf</code>，写入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">br_netfilter</span><br><span class="line">ip_vs</span><br><span class="line">ip_vs_rr</span><br><span class="line">ip_vs_wrr</span><br><span class="line">ip_vs_sh</span><br><span class="line">nf_conntrack</span><br></pre></td></tr></table></figure>
<p>然后设置开启自启，自动加载modules</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable systemd-modules-load.service</span><br></pre></td></tr></table></figure>
<p>查看模块是否加载完成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># lsmod | grep ip_vs</span><br><span class="line">ip_vs_sh               16384  0</span><br><span class="line">ip_vs_wrr              16384  0</span><br><span class="line">ip_vs_rr               16384  744</span><br><span class="line">ip_vs                 155648  750 ip_vs_rr,ip_vs_sh,ip_vs_wrr</span><br><span class="line">nf_conntrack          147456  6 xt_conntrack,nf_nat,nf_conntrack_netlink,xt_CT,xt_MASQUERADE,ip_vs</span><br></pre></td></tr></table></figure>

<h2 id="设置docker的cgroup-driver"><a href="#设置docker的cgroup-driver" class="headerlink" title="设置docker的cgroup driver"></a>设置docker的cgroup driver</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker info</span><br><span class="line">Client:</span><br><span class="line">......</span><br><span class="line">Server:</span><br><span class="line">......</span><br><span class="line"> Cgroup Driver: cgroupfs</span><br></pre></td></tr></table></figure>
<p>Docker默认的Cgroup Driver是cgroupfs，cgroupfs是cgroup为用户开发的虚拟文件系统类型，对cgroup的查询和修改只能通过cgroupfs文件系统进行。</p>
<p>而K8S推荐使用systemd作为cgroup的驱动器，因为systemd是k8s自带的cgroup管理器，负责为每个进程分配cgroups。</p>
<p>若要修改docker的cgroup driver，则直接在<code>/etc/docker/daemon.json</code>中添加以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：如果docker改了，则kubelet也要改，否则容器无法启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /var/lib/kubelet/config.yaml</span><br><span class="line">kind: KubeletConfiguration</span><br><span class="line">apiVersion: kubelet.config.k8s.io/v1beta1</span><br><span class="line">......</span><br><span class="line">cgroupDriver: cgroupfs</span><br><span class="line">cgroupsPerQOS: true</span><br></pre></td></tr></table></figure>
<p>这边的<code>cgroupDriver</code>也要改，改完后，docker和kubelet都要重启。</p>
<h2 id="Kubectl-常用操作"><a href="#Kubectl-常用操作" class="headerlink" title="Kubectl 常用操作"></a>Kubectl 常用操作</h2><ul>
<li>创建资源对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f xxx.yml    # 可同时指定多个-f进行一次性创建</span><br><span class="line">kubectl create -f &lt;目录&gt;     # 创建目录下所有.yml、.json文件定义的对象</span><br></pre></td></tr></table></figure></li>
<li>查看资源对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get pods    # 查看所有Pod列表</span><br><span class="line">kubectl get rc,service  # 查看RC和Service列表</span><br></pre></td></tr></table></figure></li>
<li>描述资源对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl describe nodes &lt;node name&gt;    # 显示node的详细信息</span><br><span class="line">kubectl describe pods/&lt;pod name&gt;      # 显示pod的详细信息</span><br><span class="line">kubectl describe pods &lt;rc name&gt;       # 显示由RC管理的pod的信息</span><br></pre></td></tr></table></figure></li>
<li>删除资源对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl delete -f pod.yml     # 删除指定pod文件定义的pod</span><br><span class="line">kubectl delete pods,services -l name=&lt;label name&gt;   # 删除指定label的Pod</span><br><span class="line">kubectl delete pods --all     # 删除所有pods</span><br></pre></td></tr></table></figure></li>
<li>执行容器命令<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl exec &lt;pod name&gt; &lt;command&gt;   # 在pod的容器中执行命令，默认为第一个容器</span><br><span class="line">kubectl exec &lt;pod name&gt; -c &lt;container name&gt; &lt;command&gt;   # 指定pod中的某个容器执行</span><br><span class="line">kubectl exec -ti &lt;pod name&gt; -c &lt;container name&gt; /bin/bash  # 登录某个容器</span><br></pre></td></tr></table></figure></li>
<li>查看容器日志<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl logs &lt;pod name&gt;    # 查看pod容器输出到stdout的日志</span><br><span class="line">kubectl logs -f &lt;pod name&gt; -c &lt;container name&gt;    # 跟踪查看pod容器的日志，相当于tail -f</span><br></pre></td></tr></table></figure></li>
<li>创建或更新资源对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl apply -f app.yml    # 类似create， 若对象不存在则创建，存在则更新</span><br></pre></td></tr></table></figure></li>
<li>在线编辑运行中的资源对象<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl edit deploy nginx    # 编辑运行中的资源对象</span><br></pre></td></tr></table></figure></li>
<li>将 pod 开放端口映射到本地<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl port-forward --address 0.0.0.0 pod/nginx 8888:80   # 将pod的80端口映射到本地的8888端口</span><br></pre></td></tr></table></figure></li>
<li>在 pod 和本地之间复制文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl cp pod名:&lt;容器内路径&gt; &lt;宿主机本地路径&gt;</span><br></pre></td></tr></table></figure></li>
<li>资源对象的标签设置<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl label namespaces default &lt;labalname=xxx&gt;   # 为default namespace设置标签</span><br></pre></td></tr></table></figure></li>
<li>检查可用 API 资源类型列表<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl api-resources   # 检查特定类型资源是否已经定义，列出所有资源对象类型</span><br></pre></td></tr></table></figure></li>
<li>查看支持的 API 版本<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl api-versions</span><br></pre></td></tr></table></figure></li>
<li>使用命令行插件<br>自定义插件，先编写一个可执行文件，文件名必须为<code>kubectl-&lt;plugin name&gt;</code>，复制到<code>$PATH</code>环境变量指定的目录中，就可通过<code>kubectl &lt;plugin name&gt;</code>执行该自定义插件了。</li>
</ul>
<h2 id="K8s-集群安全"><a href="#K8s-集群安全" class="headerlink" title="K8s 集群安全"></a>K8s 集群安全</h2><p>若是在一个安全的内网环境，则 k8s 各组件可通过 http 通信，若是要对外服务，则最好要使用 https。k8s 提供基于 CA 签名的双向数字证书认证方式以及简单的基于 HTTP Base 或 Token 的认证方式。</p>
<p>证书可分为三大类：</p>
<ul>
<li>root CA<ul>
<li>apiserver：apiserver 自己的证书</li>
<li>apiserver-kubelet-client：kubelet 连接 apiserver 时的客户端证书</li>
</ul>
</li>
<li>etcd CA<ul>
<li>etcd-server：etcd 服务器端证书</li>
<li>etcd-peer：etcd 对等证书，用于 etcd 集群中 https 通信</li>
<li>etcd-healthcheck-client：etcd 健康检查的客户端证书</li>
<li>apiserver-etcd-client：apiserver 连接 etcd 的客户端证书</li>
</ul>
</li>
<li>front-proxy CA<ul>
<li>front-proxyserver-client：apiserver 中的聚合器 aggregator 在前端的客户端证书</li>
</ul>
</li>
</ul>
<p>证书默认存放在<code>/etc/kubernetes/pki</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tree /etc/kubernetes/pki</span><br><span class="line">/etc/kubernetes/pki</span><br><span class="line">├── apiserver.crt</span><br><span class="line">├── apiserver-etcd-client.crt</span><br><span class="line">├── apiserver-etcd-client.key</span><br><span class="line">├── apiserver.key</span><br><span class="line">├── apiserver-kubelet-client.crt</span><br><span class="line">├── apiserver-kubelet-client.key</span><br><span class="line">├── ca.crt</span><br><span class="line">├── ca.key</span><br><span class="line">├── etcd</span><br><span class="line">│   ├── ca.crt</span><br><span class="line">│   ├── ca.key</span><br><span class="line">│   ├── healthcheck-client.crt</span><br><span class="line">│   ├── healthcheck-client.key</span><br><span class="line">│   ├── peer.crt</span><br><span class="line">│   ├── peer.key</span><br><span class="line">│   ├── server.crt</span><br><span class="line">│   └── server.key</span><br><span class="line">├── front-proxy-ca.crt</span><br><span class="line">├── front-proxy-ca.key</span><br><span class="line">├── front-proxy-client.crt</span><br><span class="line">├── front-proxy-client.key</span><br><span class="line">├── sa.key</span><br><span class="line">└── sa.pub</span><br></pre></td></tr></table></figure>

<p>查看证书过期时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -in /etc/kubernetes/pki/front-proxy-client.crt -noout -text | grep Not</span><br><span class="line">            Not Before: Mar 31 09:00:17 2020 GMT</span><br><span class="line">            Not After : Mar 31 09:00:17 2021 GMT</span><br></pre></td></tr></table></figure>

<p>基于 CA 签名的双向数字证书的生成过程：</p>
<ol>
<li>为 kube-apiserver 生成一个数字证书，并用 CA 证书签名</li>
<li>为 kube-apiserver 进程配置证书相关的启动参数，包括 CA 证书（用于验证客户端证书签名真伪）、自己的经过 CA 签名的证书以及私钥</li>
<li>为每个访问 kubernetes API Server 的客户端（controller manager、scheduler、kubelet、kube-proxy、kubectl）进程都生成自己的数字证书，并都用 CA 证书签名，在相关启动参数中添加 CA 证书参数</li>
</ol>
<ul>
<li><p>第一步：生成客户端密钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ca.key 2048</span><br></pre></td></tr></table></figure></li>
<li><p>第二步：用私钥为证书请求文件签名，生成证书文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=kubenode1&quot; -days 5000 -out ca.crt</span><br><span class="line">其中/CN的值为master的主机名</span><br></pre></td></tr></table></figure></li>
<li><p>第三步：生成 apiserver 的私钥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out server.key 2048</span><br></pre></td></tr></table></figure></li>
<li><p>第四步：创建配置文件<code>master_ssl.cnf</code>，用于 x509 v3 版本的证书</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[req]</span></span><br><span class="line"><span class="attr">req_extensions</span> = v3_req</span><br><span class="line"><span class="attr">distinguished_name</span> = req_distinguished_name</span><br><span class="line"></span><br><span class="line"><span class="section">[req_distinguished_name]</span></span><br><span class="line"><span class="section">[v3_req]</span></span><br><span class="line"><span class="attr">basicConstraints</span> = CA:<span class="literal">FALSE</span></span><br><span class="line"><span class="attr">keyUsage</span> = nonRepudiation, digitalSignature, keyEncipherment</span><br><span class="line"><span class="attr">subjectAltName</span> = @alt_name</span><br><span class="line"><span class="section">[alt_name]</span></span><br><span class="line"><span class="attr">DNS.1</span> = kubernetes</span><br><span class="line"><span class="attr">DNS.2</span> = kubernetes.default</span><br><span class="line"><span class="attr">DNS.3</span> = kubernetes.default.svc</span><br><span class="line"><span class="attr">DNS.4</span> = kubernetes.default.svc.cluster.local</span><br><span class="line"><span class="attr">DNS.5</span> = kubenode1   <span class="comment"># master hostname</span></span><br><span class="line"></span><br><span class="line"><span class="attr">IP.1</span> = <span class="number">192.168</span>.<span class="number">60.3</span>    <span class="comment"># master IP</span></span><br><span class="line"><span class="attr">IP.2</span> = <span class="number">192.168</span>.<span class="number">10.1</span>   <span class="comment"># kubernetes.default&#x27;s ClusterIP</span></span><br></pre></td></tr></table></figure>

<p>其中，ClusterIP 可通过命令查看<code>kubectl get svc kubernetes -o yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get svc kubernetes -o yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2020-03-31T09:00:34Z&quot;</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">apiserver</span></span><br><span class="line">    <span class="attr">provider:</span> <span class="string">kubernetes</span></span><br><span class="line">  <span class="string">.......</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.1</span>   <span class="comment"># 属于init-default.yml中serviceSubnet的网段</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">https</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">6443</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">loadBalancer:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第五步：创建证书签名请求文件 server.csr 和证书文件 server.crt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl req -new -key server.key -subj &quot;/CN=kubenode1&quot; -config master_ssl.cnf -out server.csr</span><br><span class="line">openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 5000 -extensions v3_req -extfile master_ssl.cnf -out server.crt</span><br></pre></td></tr></table></figure>
<p>此时目录下有以下相关文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── ca.crt        # CA证书</span><br><span class="line">├── ca.key        # CA私钥</span><br><span class="line">├── ca.srl        # CA签发证书的序列号记录文件</span><br><span class="line">├── server.crt    # 服务端证书</span><br><span class="line">├── server.csr    # 证书签名请求，核心内容是一个公钥</span><br><span class="line">└── server.key    # 服务端私钥</span><br></pre></td></tr></table></figure>
<p>把这些文件都移动到<code>/var/run/kubernetes</code>中</p>
</li>
<li><p>第六步：设置 kube-apiserver 的启动参数<code>KUBE_API_ARGS</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KUBE_API_ARGS=&quot;--client-ca-file=/var/run/kubernetes/ca.crt --tls-private-key-file=/var/run/kubernetes/server.key --tls-cert-file=/var/run/kubernetes/server.crt --secure-port=6443 --insecure-port=0&quot;</span><br></pre></td></tr></table></figure>
<p>重启 kube-apiserver 服务</p>
</li>
<li><p>第七步：设置 kube-controller-manager 的客户端证书、私钥和启动参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out cs_client.key 2048</span><br><span class="line">openssl req -new -key cs_client.key -subj &quot;/CN=kubenode1&quot; -out cs_client.csr</span><br><span class="line">openssl x509 -req -in cs_client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out cs_client.crt -days 5000</span><br></pre></td></tr></table></figure></li>
<li><p>第八步：创建<code>/etc/kubernetes/kubeconfig</code>文件，配置客户端证书相关参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">controllermanager</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">client-certificate:</span> <span class="string">/var/run/kubernetes/cs_client.crt</span></span><br><span class="line">      <span class="attr">client-key:</span> <span class="string">/var/run/kubernetes/cs_client.key</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">certificate-authority:</span> <span class="string">/var/run/kubernetes/ca.crt</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">https://192.168.60.3:6443</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">local</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">controllermanager</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-context</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">my-context</span></span><br></pre></td></tr></table></figure>
<p>设置 controller manager 的启动参数，然后重启 kube-controller-manager：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--service-account-key-file=/var/run/kubernetes/server.key</span><br><span class="line">--root-ca-file=/var/run/kubernetes/ca.crt</span><br><span class="line">--kubeconfig=/etc/kubernetes/kubeconfig</span><br></pre></td></tr></table></figure></li>
<li><p>第九步：设置 kube-scheduler 启动参数，然后重启 kube-scheduler</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--kubeconfig=/etc/kubernetes/kubeconfig</span><br></pre></td></tr></table></figure></li>
<li><p>第十步：设置每个 Node 上 kubelet 的客户端证书、私钥和启动参数<br>先复制 apiserver 上的 ca.crt 和 ca.key 到 Node 上，生成客户端 crt 文件。其中<code>/CN</code>的值为本 Node 的 IP 地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out kubelet_client.key 2048</span><br><span class="line">openssl req -new -key kubelet_client.key -subj &quot;/CN=192.168.60.4&quot; -out kubelet_client.csr</span><br><span class="line">openssl x509 -req -in kubelet_client.csr -CA ca.crt -CAkey ca.key -CAcreateserial -days 5000 -out kubelet_client.crt</span><br></pre></td></tr></table></figure>
<p>将这些文件都复制到<code>/var/run/kubernetes</code>中</p>
</li>
<li><p>第十一步：创建 Node 上的 kubeconfig 文件，配置客户端证书等参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubelet</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">client-certificate:</span> <span class="string">/var/run/kubernetes/kubelet_client.crt</span></span><br><span class="line">      <span class="attr">client-key:</span> <span class="string">/var/run/kubernetes/kubelet_client.key</span></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">local</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">certificate-authority:</span> <span class="string">/var/run/kubernetes/ca.crt</span></span><br><span class="line">      <span class="attr">server:</span> <span class="string">https://192.168.60.3:6443</span></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">context:</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">local</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">controllermanager</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">my-context</span></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">my-context</span></span><br></pre></td></tr></table></figure>
<p>kubelet 的启动参数，并重启 kubelet</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--kubeconfig=/etc/kubernetes/kubeconfig</span><br></pre></td></tr></table></figure></li>
<li><p>第十二步：设置 kube-proxy，同上设置启动参数，并重启 kube-proxy</p>
</li>
</ul>
<h1 id="深入理解-Pod"><a href="#深入理解-Pod" class="headerlink" title="深入理解 Pod"></a>深入理解 Pod</h1><p>K8s 对系统中长时间运行的容器的要求为：<strong>主程序需要一直在前台执行</strong>。<br>若创建一个 Pod 中的 docker 容器执行的命令是在后台运行，则 kubelet 在创建 pod 后运行后台命令，然后认为 pod 执行结束，销毁该 pod。若 pod 定义了 RelicationController，则 pod 销毁后又自动创建，导致不断循环。<strong>因此，K8s 需要自己创建 docker 镜像并以一个前台命令作为启动命令。</strong></p>
<blockquote>
<p>若无法改造为前台命令，则可以使用 Supervisor 辅助进行前台运行功能</p>
</blockquote>
<p>Pod 特征：</p>
<ul>
<li>通过容器各自的 IPC，使得同个 pod 的容器可在 pod 中通信</li>
<li>同一个 pod 的容器之间可通过 localhost 相互访问，使这一组容器被绑定在了一个环境中</li>
<li>每个容器集成 Pod 的名称</li>
<li>每个 Pod 有一个平滑共享网络名称空间的 IP 地址</li>
<li>Pod 内部共享存储卷</li>
</ul>
<h2 id="Pod创建流程"><a href="#Pod创建流程" class="headerlink" title="Pod创建流程"></a>Pod创建流程</h2><ol>
<li>用户使用kubectl命令向APIServer发起pod创建请求</li>
<li>APIServer收到请求后把pod信息以PodSpec格式存储到etcd</li>
<li>Kube-Scheduler监听到新的pod变化，执行一系列调度算法之后给pod标记上最合适的节点</li>
<li>节点上的kubelet监听到本节点上需要去创建的pod信息</li>
<li>kubelet与CRI交互创建pod中包含的资源与环境，如容器、网络、数据目录等</li>
</ol>
<h2 id="静态-Pod"><a href="#静态-Pod" class="headerlink" title="静态 Pod"></a>静态 Pod</h2><p><strong>由 kubelet 管理的仅存在于特定 Node 上的 Pod，不能通过 ApiServer 管理，无法与 ReplicationController、Deployment 及 DaemonSet 关联，kubelet 也无法对它们进行安全检查，仅由 kubelet 创建，并在 kubelet 所在主机上运行。</strong></p>
<p>两种创建静态 Pod 的方式：配置文件、HTTP</p>
<ul>
<li>配置文件方式：设置 kubelet 启动参数<code>--pod-manifest-path</code>或者在 kubelet 配置文件中设置<code>staticPodPath</code>（推荐），kubelet 会自动定期扫描该目录，根据里面的 json 和 yaml 文件进行操作。因为无法通过 APIserver 管理，所以删除 pod 命令并不会删除该 pod，只是将状态变为 Pending。若要删除 pod 一定要到该 Node，把该 pod 配置文件删掉。</li>
<li>HTTP：设置 kubelet 启动参数<code>--manifest-url</code>，会定期从该 URL 下载 Pod 配置文件并创建。</li>
</ul>
<h2 id="Pod-配置管理"><a href="#Pod-配置管理" class="headerlink" title="Pod 配置管理"></a>Pod 配置管理</h2><p>创建 ConfigMap 资源对象</p>
<ul>
<li><p>yaml 文件方式创建</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cm-appvars</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">apploglevel:</span> <span class="string">info</span></span><br><span class="line">  <span class="attr">appdatadir:</span> <span class="string">/var/data</span></span><br></pre></td></tr></table></figure>

<p><code>kubectl create -f cm-appvars.yml</code><br>查看详情：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl describe configmaps cm-appvars</span><br><span class="line">Name:         cm-appvars</span><br><span class="line">Namespace:    default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">apploglevel:</span><br><span class="line">----</span><br><span class="line">info</span><br><span class="line">appdatadir:</span><br><span class="line">----</span><br><span class="line">/var/data</span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>或者直接放配置，要注意缩进</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cm-appconfig</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">tomcat-server-xml:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="string">    &lt;Server port=&quot;8005&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;Listener className=&quot;org.apache.catalina.startup.VersionLoggerListener&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;/&gt;</span></span><br><span class="line"><span class="string">        &lt;Service name=&quot;Catalina&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;Connector port=&quot;8080&quot; relaxedPathChars=&quot;[]|&quot; relaxedQueryChars=&quot;[]|&#123;&#125;^&amp;#x5c;&amp;#x60;&amp;quot;&amp;lt;&amp;gt;&quot;</span></span><br><span class="line"><span class="string">                      maxThreads=&quot;150&quot; minSpareThreads=&quot;25&quot; connectionTimeout=&quot;20000&quot; enableLookups=&quot;false&quot;</span></span><br><span class="line"><span class="string">                      maxHttpHeaderSize=&quot;8192&quot; protocol=&quot;HTTP/1.1&quot; useBodyEncodingForURI=&quot;true&quot; redirectPort=&quot;8443&quot;</span></span><br><span class="line"><span class="string">                      acceptCount=&quot;100&quot; disableUploadTimeout=&quot;true&quot; bindOnInit=&quot;false&quot;/&gt;</span></span><br><span class="line"><span class="string">          ......</span></span><br><span class="line"><span class="string">        &lt;/Service&gt;</span></span><br><span class="line"><span class="string">    &lt;/Server&gt;</span></span><br><span class="line"><span class="string"></span>  <span class="attr">tomcat-loggingproperties:</span></span><br><span class="line">    <span class="string">&quot;1catalina.org.apache.juli.AsyncFileHandler.level = FINE</span></span><br><span class="line"><span class="string">    1catalina.org.apache.juli.AsyncFileHandler.directory = $&#123;catalina.base&#125;/logs</span></span><br><span class="line"><span class="string">    1catalina.org.apache.juli.AsyncFileHandler.prefix = catalina.</span></span><br><span class="line"><span class="string">    1catalina.org.apache.juli.AsyncFileHandler.encoding = UTF-8</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    java.util.logging.ConsoleHandler.level = FINE</span></span><br><span class="line"><span class="string">    java.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatter</span></span><br><span class="line"><span class="string">    java.util.logging.ConsoleHandler.encoding = UTF-8&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>kubectl 直接创建，通过<code>--from-file</code>或<code>--from-literal</code>指定内容，<code>from-file</code>是直接将文件内容作为值，<code>from-literal</code>后面跟着键值对。<br><code>--from-file</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap jira-server-xml --from-file=/opt/atlassian/jira/conf/server.xml</span><br></pre></td></tr></table></figure>
<p><code>--from-literal</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create configmap cm-appenv --from-literal=loglevel=info --from-literal=appdir=/var/data</span><br></pre></td></tr></table></figure></li>
</ul>
<p>容器对 ConfigMap 的使用有以下两种方法</p>
<ul>
<li>通过环境变量获取 ConfigMap 内容<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cm-test-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cm-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cm-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env|grep APP&quot;</span>]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APPLOGLEVEL</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">cm-appenv</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">loglevel</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">APPDATADIR</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">configMapKeyRef:</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">cm-appenv</span></span><br><span class="line">              <span class="attr">key:</span> <span class="string">appdir</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">  <span class="comment"># 需要注意：环境变量的名称受POSIX规范约束，不能以数字开头，且不能包含特殊字符</span></span><br></pre></td></tr></table></figure>
创建完成后，查看 pod<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods</span><br><span class="line">NAME          READY   STATUS      RESTARTS   AGE</span><br><span class="line">cm-test-pod   0/1     Completed   0          22s</span><br></pre></td></tr></table></figure>
查看 pod 的输出日志，说明 pod 内已经读取到了<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl logs cm-test-pod</span><br><span class="line">APPDATADIR=/var/data</span><br><span class="line">APPLOGLEVEL=info</span><br></pre></td></tr></table></figure></li>
<li>通过 Volume 挂载的方式将 ConfigMap 的内容挂载为容器内部的文件或目录<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cm-test-pod-2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cm-test-pod-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cm-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">kubeguide/tomcat-app:v1</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/configfiles</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">serverxml</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">serverxml</span></span><br><span class="line">      <span class="attr">configMap:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">cm-appconfig</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">tomcat-server-xml</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">server.xml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">tomcat-loggingproperties</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">logging.properties</span></span><br></pre></td></tr></table></figure>
创建该 pod，然后进入该 Pod 查看，配置文件已添加成功<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl exec -it cm-test-pod-2 -- bash</span><br><span class="line"># ls /configfiles/</span><br><span class="line">logging.properties  server.xml</span><br></pre></td></tr></table></figure>
若引用 ConfigMap 时不指定 items，则该方法在容器内的目录下会为每个 item 生成一个文件名为<code>key-&lt;key键值&gt;</code>的文件</li>
</ul>
<p>ConfigMap 的限制条件：</p>
<ul>
<li>ConfigMap 必须在 Pod 之前创建</li>
<li>ConfigMap 受 NameSpace 限制，只有在相同 Namespace 的 Pod 才能引用</li>
<li>ConfigMap 的配额管理还未能实现</li>
<li>kubelet 只支持可被 apiserver 管理的 pod 使用 ConfigMap。静态 Pod 无法引用 ConfigMap</li>
<li>ConfigMap 在 Pod 内只能挂载为目录，且若已存在该目录，则直接覆盖。所以最好将文件挂载在一个临时目录，并通过 cp 或 link 命令将配置移动到实际目录下</li>
</ul>
<h2 id="在容器内获取-Pod-信息"><a href="#在容器内获取-Pod-信息" class="headerlink" title="在容器内获取 Pod 信息"></a>在容器内获取 Pod 信息</h2><p>在容器中可通过 Downward API 获取所在 Pod 的信息，仍然是<strong>通过环境变量或 Volume 挂载的方式将 Pod 信息注入容器内部</strong><br>可以通过Downward API获取以下信息：</p>
<ul>
<li><p>能通过 <code>fieldRef</code> 获得：</p>
<ul>
<li><code>metadata.name</code></li>
<li><code>metadata.namespace</code></li>
<li><code>metadata.uid</code></li>
<li><code>metadata.labels[&#39;&lt;KEY&gt;&#39;]</code> - Pod 标签 <code>&lt;KEY&gt;</code> 的值 (例如, <code>metadata.labels[&#39;mylabel&#39;]</code>）</li>
<li><code>metadata.annotations[&#39;&lt;KEY&gt;&#39;]</code> - Pod 的注解 <code>&lt;KEY&gt;</code> 的值（例如, <code>metadata.annotations[&#39;myannotation&#39;]</code>）</li>
</ul>
</li>
<li><p>能通过 <code>resourceFieldRef</code> 获得：</p>
<ul>
<li>容器的 CPU limit</li>
<li>容器的 CPU request</li>
<li>容器的内存 limit</li>
<li>容器的内存 request</li>
<li>容器的临时存储 limit</li>
<li>容器的临时存储 request</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><p>将 Pod 信息注入为环境变量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dapi-test-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;env&quot;</span>]</span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAME</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_NAMESPACE</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">metadata.namespace</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">POD_IP</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">fieldRef:</span></span><br><span class="line">              <span class="attr">fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<p>Downward API 提供变量：</p>
<ul>
<li>metadata.name：pod 名</li>
<li>status.podIP：pod IP。（IP 为 status 而非 metadata，是因为 IP 不是元数据，而是状态数据）</li>
<li>metadata.namespace：pod Namespace</li>
</ul>
<p>创建完成后，查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl logs dapi-test-pod</span><br><span class="line">POD_IP=10.38.0.1</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBERNETES_PORT=tcp://192.168.10.1:443</span><br><span class="line">HOSTNAME=dapi-test-pod</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">POD_NAME=dapi-test-pod</span><br><span class="line">KUBERNETES_PORT_443_TCP_ADDR=192.168.10.1</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class="line">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">KUBERNETES_PORT_443_TCP=tcp://192.168.10.1:443</span><br><span class="line">POD_NAMESPACE=default</span><br><span class="line">KUBERNETES_SERVICE_HOST=192.168.10.1</span><br><span class="line">PWD=/</span><br></pre></td></tr></table></figure>
</li>
<li><p>将容器资源信息注入为环境变量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dapi-test-pod-container-vars</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dapi-test-pod-container-vars</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">printenv</span> <span class="string">CPU_REQUEST</span> <span class="string">CPU_LIMIT;</span></span><br><span class="line">          <span class="string">printenv</span> <span class="string">MEM_REQUEST</span> <span class="string">MEM_LIMIT;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CPU_REQUEST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CPU_LIMIT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MEM_REQUEST</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.memory</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MEM_LIMIT</span></span><br><span class="line">          <span class="attr">valueFrom:</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">test-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>
<p>创建完成后，查看日志</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl logs dapi-test-pod-container-vars</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">134217728</span><br><span class="line">134217728</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Volume 挂载</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-downwardapi-volume-example-2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">client-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">k8s.gcr.io/busybox:1.24</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">while</span> <span class="literal">true</span><span class="string">;</span> <span class="string">do</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span></span><br><span class="line">          <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/cpu_limit</span> ]]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/cpu_limit;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/cpu_request</span> ]]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/cpu_request;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/mem_limit</span> ]]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/mem_limit;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">if</span> [[ <span class="string">-e</span> <span class="string">/etc/podinfo/mem_request</span> ]]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">            <span class="string">echo</span> <span class="string">-en</span> <span class="string">&#x27;\n&#x27;</span><span class="string">;</span> <span class="string">cat</span> <span class="string">/etc/podinfo/mem_request;</span> <span class="string">fi;</span></span><br><span class="line">          <span class="string">sleep</span> <span class="number">5</span><span class="string">;</span></span><br><span class="line">        <span class="string">done;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;32Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;125m&quot;</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/etc/podinfo</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">podinfo</span></span><br><span class="line">      <span class="attr">downwardAPI:</span></span><br><span class="line">        <span class="attr">items:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;cpu_limit&quot;</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.cpu</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1m</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;cpu_request&quot;</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.cpu</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1m</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;mem_limit&quot;</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">limits.memory</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1Mi</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">&quot;mem_request&quot;</span></span><br><span class="line">            <span class="attr">resourceFieldRef:</span></span><br><span class="line">              <span class="attr">containerName:</span> <span class="string">client-container</span></span><br><span class="line">              <span class="attr">resource:</span> <span class="string">requests.memory</span></span><br><span class="line">              <span class="attr">divisor:</span> <span class="string">1Mi</span></span><br></pre></td></tr></table></figure>
<p>进入容器查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ # ls /etc/podinfo/</span><br><span class="line">cpu_limit    cpu_request  mem_limit    mem_request</span><br><span class="line">/ # cat /etc/podinfo/cpu_limit</span><br><span class="line">250</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Pod-生命周期与重启策略"><a href="#Pod-生命周期与重启策略" class="headerlink" title="Pod 生命周期与重启策略"></a>Pod 生命周期与重启策略</h2><p>Pod 状态如下：</p>
<ul>
<li>Pending：apiserver 已创建该 pod，但 pod 中还有容器镜像没有创建（可能在下载）</li>
<li>Running：pod内容器都已创建，且至少有一个容器在运行、正在启动或重启状态</li>
<li>Succeeded：pod内容器都成功执行后退出，且不会再重启</li>
<li>Failed：pod内容器都已退出，但至少有一个容器退出为失败状态</li>
<li>Unknown：无法获取该 pod 状态</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202207102346742.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202207102346742.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>当某个容器异常退出或健康检查失败时，kubelet 会根据 RestartPolicy 的设置进行相应操作<br>pod 重启策略如下：</p>
<ul>
<li>Always：当容器失效，由 kubelet 自动重启该容器</li>
<li>OnFailure：当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器</li>
<li>Never：不论容器什么状态，kubelet 都不会重启该容器</li>
</ul>
<p>每种控制器对 Pod 的重启策略要求如下：</p>
<ul>
<li>RC、DaemonSet：必须设为 Always，保证容器持续运行</li>
<li>Job：OnFailure 或 Never，确保容器执行完成后不再重启</li>
<li>kubelet：在 Pod 失效时自动重启，不论将 RestartPolicy 设为什么值，都不会对 Pod 进行健康检查</li>
</ul>
<p>kubelet 重启失效容器的时间间隔以<code>sync-frequency X 偶数倍</code>计算，最长延时 5min，且在成功重启后的 10min 后重置该时间。</p>
<h2 id="Pod-健康检查和服务可用性检查"><a href="#Pod-健康检查和服务可用性检查" class="headerlink" title="Pod 健康检查和服务可用性检查"></a>Pod 健康检查和服务可用性检查</h2><p>k8s 通过两类探针检查 pod 健康状态：LivenessProbe、ReadinessProbe。kubelet 定期执行这两类探针诊断容器健康。</p>
<ul>
<li>LivenessProbe 存活探针：用于判断容器应用是否正常运行（Running），若判定为不健康，则 kubelet 杀死该容器并根据重启策略处理。若容器不包含该探针，则 kubelet 认为该容器的探针返回值永远为 Success</li>
<li>ReadinessProbe 就绪探针：用于判断容器应用是否可用（Ready），只有达到 Ready 状态，Pod 才能接受请求。<ul>
<li>对于被 Service 管理的 Pod，Service 与 Pod Endpoint 的关联关系也基于 Pod 是否 Ready 进行设置。<ul>
<li>若运行过程中 Ready 变为 False，则系统自动将其从 Service 的后端 Endpoint 列表中隔离出去。</li>
<li>若恢复到 Ready，则再将 Pod 加回 Endpoint 列表。</li>
<li>这样就保证客户端在访问 Service 时不会被转发到服务不可用的 Pod 实例上。</li>
</ul>
</li>
</ul>
</li>
<li>startupProbe 启动探针：类似initialDelaySeconds参数，一旦启动探测成功一次，LivenessProbe就会接管对容器的探测。</li>
</ul>
<blockquote>
<p>LivenessProbe 不等待 ReadinessProbe成功。如果要在执行LivenessProbe之前等待，应该使用 <code>initialDelaySeconds</code> 或 <code>startupProbe</code>。</p>
</blockquote>
<p>LivenessProbe 告诉 K8s 容器是否需要通过重启实现自愈。ReadinessProbe 告诉 K8s 容器是否已准备好加入到 Service 负载均衡池中对外提供服务。<br>LivenessProbe 探测是重启容器，ReadinessProbe 探测是将容器设为不可用，从而不接收 Service 转发的请求。<br>若不特意配置，则 K8s 对两种检查采取相同默认行为，<strong>通过判断容器启动进程的返回值是否为 0 判断探测是否成功。</strong></p>
<p>两种探针都有三种实现方式：</p>
<ul>
<li>ExecAction：在容器内部执行一个命令，若该命令的返回码为 0，则表明容器健康<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-exec</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">echo</span> <span class="string">ok</span> <span class="string">&gt;</span> <span class="string">/tmp/health;</span> <span class="string">sleep</span> <span class="number">10</span><span class="string">;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">/tmp/health;</span> <span class="string">sleep</span> <span class="number">600</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> <span class="comment"># 查看/tmp/health文件是否存在作为是否存活条件</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/tmp/health</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">15</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
结果应为 failed，通过 describe 查看信息，可看到<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Warning  Unhealthy  18s (x6 over 107s)   kubelet, kubenode2  Liveness probe failed: cat: can&#x27;t open &#x27;/tmp/health&#x27;: No such file or directory</span><br><span class="line">Normal   Killing    18s (x2 over 88s)    kubelet, kubenode2  Container liveness-exec failed liveness probe, will be restarted</span><br></pre></td></tr></table></figure>
导致 kubelet 不断杀死并重启</li>
<li>TCPSocketAction：通过容器 IP 和端口号进行 TCP 检查，若能建立 TCP 连接，则说明健康<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-tcp</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">liveness-tcp</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-tcp</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">tcpSocket:</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>HTTPGetAction：通过容器的 IP、端口号和 HTTP get，若响应状态码大于等于 200 小于 400，则认为容器健康<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">liveness-httpget</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">liveness-httpget</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">liveness-httpget</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">          <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">livenessProbe:</span></span><br><span class="line">        <span class="attr">httpGet:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">/_status/healthz</span></span><br><span class="line">          <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">        <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>探针参数字段：</p>
<ul>
<li>initialDelaySeconds：启动容器后进行首次健康检查的等待时间</li>
<li>timeoutSeconds：健康检查发送请求后等待响应的超时时间。若超时则 kubelet 认为该容器无法提供服务，并重启该容器</li>
<li>periodSeconds：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li>
<li>successThreshold：探测器在失败后，被视为成功的最小连续成功数。默认值是 1。 存活和启动探测的这个值必须是 1。最小值是 1。</li>
<li>failureThreshold：当探测失败时，Kubernetes 的重试次数。 对存活探测而言，放弃就意味着重新启动容器。 对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li>
</ul>
<h2 id="Pod-调度"><a href="#Pod-调度" class="headerlink" title="Pod 调度"></a>Pod 调度</h2><h3 id="Deployment-与-RepliaSet"><a href="#Deployment-与-RepliaSet" class="headerlink" title="Deployment 与 RepliaSet"></a>Deployment 与 RepliaSet</h3><p>Deployment 和 RepliaSet 的主要功能就是自动部署一个容器应用的多个副本并持续监控副本数量，在集群中始终维持指定的副本数量</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>创建 nginx 的 deployment，副本数为 3。创建完成后查看 deployment 状态，以及 ReplicaSet 信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get deployments nginx-deploy</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   3/3     3            3           49s</span><br><span class="line"></span><br><span class="line"># kubectl get rs</span><br><span class="line">NAME                     DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-d46f5678b   3         3         3       115s</span><br></pre></td></tr></table></figure>

<p>Deployment 配置文件 spec 重点参数：</p>
<ul>
<li>replicas：副本数量</li>
<li>tempalte：Pod 模板<ul>
<li>template.metadata：Pod 元数据，至少要一个 Label</li>
<li>tamplate.spec：Pod 规格，定义 Pod 中每个容器的属性</li>
</ul>
</li>
</ul>
<h3 id="NodeSelector"><a href="#NodeSelector" class="headerlink" title="NodeSelector"></a>NodeSelector</h3><p>若在实际情况中需要将 Pod 调度到指定的 Node 上，则可以通过 Node 的标签 Label 和 Pod 的 nodeSelector 相匹配来实现。</p>
<p>首先给 node 打标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</span><br></pre></td></tr></table></figure>

<p>例如：给 kubenode2 打上<code>app=redis-master</code>标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl label nodes kubenode2 app=redis</span><br></pre></td></tr></table></figure>

<p>创建一个 redis 的 deployment，部署到 kubenode2 上</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">redis-master</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">redis-master</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>

<p>创建后查看 pod，确认部署到了 kubenode2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pod -o wide</span><br><span class="line">NAME                            READY   STATUS             RESTARTS   AGE   IP          NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">redis-master-7f84cc5d4d-8mrfr   1/1     Running            0          70s   10.38.0.6   kubenode2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>若多个 Node 都打了相同标签，则 scheduler 在分配时会根据算法选择一个可用的 Node 进行调度。<br><strong>若指定了标签，但是集群中不存在打了该标签的 node，则 Pod 无法成功调度</strong></p>
<p>k8s 目前偏向于发展亲和性调度，随着节点亲和性越来越能表达 NodeSelector 的功能，最终会淘汰掉 NodeSelector。<br>Node 亲和性调度极大扩展了 Pod 的调度能力，调度功能包含：节点亲和性（NodeAffinity）和 Pod 亲和性（PodAffinity）。增强了一些功能：</p>
<ul>
<li>可使用软限制、优先采用等限制方式，<strong>调度器在无法满足优先需求时，会退而求其次继续运行该 pod</strong></li>
<li>可<strong>根据节点上正在运行的其他 pod 的标签来进行限制</strong>，即可定义一种规则<strong>描述 Pod 之间的亲和或互斥关系</strong></li>
</ul>
<h3 id="NodeAffinity"><a href="#NodeAffinity" class="headerlink" title="NodeAffinity"></a>NodeAffinity</h3><p>有两种节点亲和性表达：</p>
<ul>
<li>RequiredDuringSchedulingIgnoredDuringExecution：必须满足指定规则才能调度 Pod，类似 NodeSelector，相当于硬限制。</li>
<li>PreferredDuringSchedulingIgnoredDuringExecution：强调优先满足指定规则，但不强求，相当于软限制。还可设置权重，定义先后顺序。</li>
</ul>
<p>其中 IgnoredDuringExecution 的意思为：若 pod 所在节点在 pod 运行期间标签发生了更改，不再符合亲和性要求，则系统会忽略变化，pod 仍在该节点上运行。</p>
<p>例：创建 pod，只运行在 amd64 的节点，且尽量运行在磁盘为 ssd 的节点</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-affinity-test</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">node-affinity-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">node-affinity-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">google/pause</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">beta.kubernetes.io/arch</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">amd64</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">preference:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">disk-type</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure>

<p>NodeAffinity 语法支持的操作符包括：</p>
<ul>
<li>In</li>
<li>NotIn</li>
<li>Exists</li>
<li>DoesNotExist</li>
<li>Gt</li>
<li>Lt</li>
</ul>
<p>NodeAffinity 规则注意事项：</p>
<ul>
<li>若同时定义了 nodeSelector 和 nodeAffinity，则必须两个条件都得到满足时 pod 才能最终运行在指定 node 上</li>
<li>若 nodeAffinity 指定了多个 nodeSelectorTerms，则其中一个能匹配成功即可</li>
<li>若在 nodeSelectorTerms 中有多个 matchExpressions，则一个节点必须满足所有 matchExpressions 才能运行该 Pod</li>
</ul>
<h3 id="PodAffinity"><a href="#PodAffinity" class="headerlink" title="PodAffinity"></a>PodAffinity</h3><p>根据<strong>在节点上正在运行的 Pod 标签而不是节点的标签</strong>进行判断和调度，要求对<strong>节点和 Pod 两个条件</strong>进行匹配。<br>若在具有标签 X 的 node 上运行了一个或多个符合条件 Y 的 Pod，则 Pod 应该运行在该 node 上。X 指一个集群中的节点、区域等概念，通过 k8s 内置节点标签的 key 进行声明，该 key 名字为 topologyKey，意为节点所属 topology 范围。</p>
<p>因为 pod 是属于某个命名空间的，所以 Y 表示的是一个或全部命名空间的一个 Label Selector。<br>pod 亲和性表达和节点亲和性表达是相同的。</p>
<p>先创建一个参考 pod，有两个自定义标签 security 和 app。其中 security 是用于亲和性调度，app 是用于互斥性调度</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-flag</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-flag</span></span><br><span class="line">    <span class="attr">security:</span> <span class="string">s1</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-flag</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>该 pod 在 kubenode2</p>
<p>进行亲和性调度测试</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-affinity</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-affinity</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">google/pause</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">security</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">s1</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>匹配包含 security&#x3D;s1 的 pod 的 node。查看创建情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE     IP          NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">pod-affinity                    1/1     Running   0          10s     10.38.0.2   kubenode2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">pod-flag                        1/1     Running   0          5m26s   10.38.0.1   kubenode2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>进行互斥性调度测试</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-anti-affinity</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod-anti-affinity</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">pod-anti-affinity</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">google/pause</span></span><br><span class="line">  <span class="attr">affinity:</span></span><br><span class="line">    <span class="attr">podAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">security</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">s1</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">            <span class="attr">matchExpressions:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">app</span></span><br><span class="line">                <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">                <span class="attr">values:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<h3 id="Taints-与-Tolerations"><a href="#Taints-与-Tolerations" class="headerlink" title="Taints 与 Tolerations"></a>Taints 与 Tolerations</h3><p>与亲和性相反，Taint（污点）让 Node 拒绝 Pod 的运行。</p>
<p>Taint 需要配合 Toleration（容忍）使用，让 Pod 避开那些不适合的 Node，在 node 设置了 taint 后，除非 node 声明能容忍这些污点，否则无法在这些 node 上运行。Toleration 是 Pod 属性，让 Pod 能运行在标注了 Taint 的 Node 上。</p>
<p>例：给 node 添加污点，键为 key，值为 value，效果为 NoSchedule，除非 Pod 容忍，否则不调度到该 Node</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl taint node kubenode2 key=value:NoSchedule</span><br><span class="line">node/kubenode2 tainted</span><br></pre></td></tr></table></figure>

<p>此时创建 deployment 等资源对象时，不会部署到污点 node 上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE   IP          NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-toleration-deployment-5f6d8b47d6-8kk8q   1/1     Running   0          45s   10.32.0.2   kubenode3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-toleration-deployment-5f6d8b47d6-fbqkm   1/1     Running   0          45s   10.32.0.3   kubenode3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-toleration-deployment-5f6d8b47d6-vm7vx   1/1     Running   0          45s   10.32.0.4   kubenode3   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>然后在 Deployment 中声明 Toleration，表示允许调度到该污点 Node</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">......</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-toleration-deployment</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">&quot;value&quot;</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line"><span class="string">或者</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;key&quot;</span></span><br><span class="line">        <span class="attr">operator:</span> <span class="string">&quot;Exists&quot;</span></span><br><span class="line">        <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br></pre></td></tr></table></figure>

<p>其中键值和 effect 需要和污点设置一致，并满足：</p>
<ul>
<li>operator 值为 Exists，这样无需指定 value</li>
<li>operator 值为 Equal，需要指定 value 并一致</li>
<li>若不指定 operator，则默认值为 Equal</li>
<li>空的 key 配合 Exists 能匹配所有键值</li>
<li>空的 effect 能匹配所有的 effect</li>
</ul>
<p>除了 NoSchedule，还有另外两个 effect</p>
<ul>
<li>PreferNoSchedule：NoSchedule 的软限制版本，只是尽量不调度到污点 node，不强制</li>
<li>NoExecute：在该 node 上正在运行的所有无对应 Toleration 配置的 Pod 立刻被驱逐，且具有相应 Toleration 的 Pod 永远不被驱逐</li>
</ul>
<p>同个 Node 可配置多个污点，pod 也可设置多个容忍，处理多个污点和容忍的顺序为：</p>
<ol>
<li>先列出节点的所有污点</li>
<li>忽略 Pod 的容忍能匹配的部分</li>
<li>剩下的没有忽略的污点就是对 Pod 不会调度到的节点</li>
</ol>
<p>特殊情况：</p>
<ol>
<li>若剩余污点中存在 NoSchedule，则调度器不会把该 Pod 调度到这个节点</li>
<li>若剩余污点中没有 NoSchedule，但有 PreferNoSchedule，则调度器尽量不把 Pod 调度到这个节点</li>
<li>若剩余污点中有 NoExecute，且 Pod 已经在该节点上运行，则会被驱逐，若还没有在该节点上运行，则不再会被调度到该节点</li>
</ol>
<p>对于 NoExecute，若需要让已经在运行的 Pod 被逐出前还能运行一段时间，而不是立刻被逐出，则可以添加参数</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerationSeconds:</span> <span class="number">3600</span></span><br></pre></td></tr></table></figure>

<p>若要将一些节点专门给特定应用使用，则可以通过添加污点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes &lt;node_name&gt; dedicated=&lt;group_name&gt;:NoSchedule</span><br></pre></td></tr></table></figure>

<p>然后给这些应用 Pod 加入相应 Toleration，带有合适 Toleration 的 Pod 就能使用这样的 Node。</p>
<p>若集群中有特殊硬件设备如 GPU，希望只有相关特定 Pod 使用这些设备，可设置污点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes &lt;node_name&gt; special=true:NoSchedule或PreferNoSchedule</span><br></pre></td></tr></table></figure>

<p>出于安全考虑，默认 k8s 不会将 Pod 调度到 Master，若希望 master 也当做 Node 使用，则可以使用污点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint node &lt;master_name&gt; node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure>

<p>若要恢复 Master Only 状态，则使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl taint mode &lt;master_name&gt; mode-role.kubernetes.io/master=&quot;&quot;:NoSchedule</span><br></pre></td></tr></table></figure>

<h3 id="Pod-Priority-Preemption"><a href="#Pod-Priority-Preemption" class="headerlink" title="Pod Priority Preemption"></a>Pod Priority Preemption</h3><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><p>DaemonSet 用于<strong>管理在集群中每个 Node 上仅运行一份 Pod 的副本实例</strong>。DaemonSet 的 Pod 调度策略和 RC 类似，除了使用系统内置算法在每个 Node 上进行调度，也可以在 Pod 的定义中使用 NodeSelector 或 NodeAffinity 进行调度。</p>
<p>例：集群的每个 Node 都创建一个 fluentd-elasticsearch，并挂载两个主机目录。DaemonSet 的配置与 Deployment 几乎一致</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fluented-logging</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">fluented-logging</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">fluented-logging</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">fluented-logging</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">fluented-logging</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">ist0ne/fluentd-elasticsearch</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FLUENTD_ARGS</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">-q</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">containers</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">containers</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/var/lib/docker/containers</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">varlog</span></span><br><span class="line">          <span class="attr">hostPath:</span></span><br><span class="line">            <span class="attr">path:</span> <span class="string">/var/log</span></span><br></pre></td></tr></table></figure>

<p>启动后查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get daemonsets</span><br><span class="line">NAME               DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE</span><br><span class="line">fluented-logging   2         2         2       2            2           &lt;none&gt;          4m39s</span><br><span class="line"></span><br><span class="line"># kubectl get pods -o wide</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE    IP          NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">fluented-logging-h8dwx          1/1     Running   0          104s   10.32.0.2   kubenode3   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">fluented-logging-l68n2          1/1     Running   0          104s   10.38.0.5   kubenode2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>两台 node 节点都自动部署好了。</p>
<p>DaemonSet 自动滚动升级，在更新 DaemonSet 模板时，旧 pod 副本会自动删除，同时新 pod 副本自动创建。只需添加策略，与 containers 同级：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">updateStrategy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br></pre></td></tr></table></figure>

<p>DaemonSet 的常见应用场景：</p>
<ul>
<li>节点上运行存储，如 Glusterd 或 Ceph</li>
<li>节点上运行日志收集，如 Flunentd 或 Logstash</li>
<li>节点上运行监控，如 Prometheus Exporter 或 Collectd</li>
</ul>
<p>K8s 也在运行自己的 DaemonSet 组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get daemonsets.apps --namespace=kube-system</span><br><span class="line">NAME         DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR            AGE</span><br><span class="line">kube-proxy   3         3         3       3            3           kubernetes.io/os=linux   8d</span><br><span class="line">weave-net    3         3         3       3            3           &lt;none&gt;                   8d</span><br></pre></td></tr></table></figure>

<h3 id="Job-1"><a href="#Job-1" class="headerlink" title="Job"></a>Job</h3><p>Job 用于定义并启动一个批处理任务，能并行或串行处理一批工作项（work item）。批处理包含以下模式：</p>
<ul>
<li>Job Template Expansion：一个 Job 对应一个 Work Item，适合工作项少、每个工作项要处理数据量大的场景</li>
<li>Queue With Pod Per Work Item：一个任务队列存放工作项，一个 job 作为消费者去完成这些工作项。job 会启动 N 个 Pod，每个 Pod 对应一个工作项</li>
<li>Queue With Variable Pod Count：同上，但是 job 启动的 pod 数量是可变的</li>
<li>Single Job With Static Work Assignment：一个 job 产生多个 Pod，采用程序静态方式分配任务项，而不是采用队列动态分配</li>
</ul>
<p>Job 类型：</p>
<ul>
<li>Non-parallel jobs：一个 Job 只启动一个 Pod，除非 Pod 异常，才会重启该 Pod，一旦 Pod 正常结束，job 就结束</li>
<li>Parallel jobs with a fixed completion count：并行 Job 会启动多个 Pod，此时需要设定 Job 的 <code>spec.completions</code> 参数，当正常结束的 Pod 数量到达该数值后，Job 结束。<code>spec.parallelism</code> 参数控制并行数（同时启动多少个 Job 处理）</li>
<li>Parallel Jobs with a work queue：并行 Job 有一个独立 Queue，工作项在 Queue 中存放，不能设置 <code>spec.completions</code>参数。有以下特性：<ul>
<li>每个 Pod 都能独立判断决定是否有任务项需要处理</li>
<li>若某个 Pod 正常结束，则 Job 不会再启动新 Pod</li>
<li>若一个 Pod 成功结束，则此时应该不存在其他 Pod 还在工作的情况，而是都处于结束和退出的状态</li>
<li>若所有 pod 都结束了，且至少一个 Pod 成功结束，则 job 成功结束</li>
</ul>
</li>
</ul>
<p>job 的重启策略只能为 Never 或 OnFailure，且必须设置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">9</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myjob</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">job</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">hello-world</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>

<p>查看 job 信息情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get jobs.batch</span><br><span class="line">NAME    COMPLETIONS   DURATION   AGE</span><br><span class="line">myjob   9/9           10s        66s</span><br></pre></td></tr></table></figure>

<h3 id="Cronjob"><a href="#Cronjob" class="headerlink" title="Cronjob"></a>Cronjob</h3><p>类似 Linux Cron，定时启动 Job</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span> <span class="comment"># 每分钟执行一次</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">              <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">              <span class="attr">args:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">/bin/sh</span> <span class="string">-c</span></span><br><span class="line">                <span class="bullet">-</span> <span class="string">date</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化容器-Init-Container"><a href="#初始化容器-Init-Container" class="headerlink" title="初始化容器 Init Container"></a>初始化容器 Init Container</h2><p>Init容器是一种特殊容器，在 Pod 内的应用容器启动之前运行。Init容器可以包括一些应用镜像中不存在的实用工具和安装脚本。Pod可以有一个或多个先于应用容器启动的Init容器。</p>
<p>Init 容器与普通的容器非常像，除了如下两点：</p>
<ul>
<li>它们总是运行到完成。</li>
<li>每个都必须在下一个启动之前成功完成。</li>
</ul>
<p>如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。 然而，如果 Pod 对应的 <code>restartPolicy</code> 值为 <code>Never</code>，并且 Pod 的 Init 容器失败， 则 Kubernetes 会将整个 Pod 状态设置为失败。</p>
<h2 id="容器运行时类-Runtime-Class"><a href="#容器运行时类-Runtime-Class" class="headerlink" title="容器运行时类 Runtime Class"></a>容器运行时类 Runtime Class</h2><p>RuntimeClass 是一个用于选择容器运行时配置的特性，容器运行时配置用于运行 Pod 中的容器，可以在不同的 Pod 设置不同的 RuntimeClass，以提供性能与安全性之间的平衡。还可以使用 RuntimeClass 运行具有相同容器运行时但具有不同设置的 Pod。</p>
<h2 id="容器生命周期钩子-Container-Lifecycle-Hooks"><a href="#容器生命周期钩子-Container-Lifecycle-Hooks" class="headerlink" title="容器生命周期钩子 Container Lifecycle Hooks"></a>容器生命周期钩子 Container Lifecycle Hooks</h2><p>有两个暴露给容器的hook：</p>
<ul>
<li>PostStart：hook会在容器被创建之后立即被执行。 但是，不能保证hook会在容器的ENTRYPOINT之前执行。</li>
<li>PreStop：在容器因 API 请求或者管理事件（诸如存活态探针、启动探针失败、资源抢占、资源竞争等） 而被终止之前，此hook会被调用。如果容器已经处于已终止或者已完成状态，则对 preStop hook的调用会失败。在用来停止容器的 TERM 信号被发出之前，hook必须执行结束。Pod 的termination grace period在 PreStop hook被执行之前开始计数，所以无论 hook函数的执行结果如何，容器最终都会在 Pod 的termination grace period内被终止。</li>
</ul>
<p>容器可以通过实现和注册该hook的处理程序来访问该hook。针对容器，有两种类型的hook处理程序可供实现：</p>
<ul>
<li>Exec：在容器的 cgroups 和名称空间中执行特定的命令。命令所消耗的资源计入容器的资源消耗。</li>
<li>HTTP：对容器上的endpoint执行 HTTP 请求。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">lifecycle-demo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">lifecycle-demo-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;nginx -s quit; while killall -0 nginx; do sleep 1; done&quot;</span>]</span><br></pre></td></tr></table></figure>


<h2 id="Pod-升级与回滚"><a href="#Pod-升级与回滚" class="headerlink" title="Pod 升级与回滚"></a>Pod 升级与回滚</h2><p>只要对 Deployment 的 Pod 定义进行修改并应用到 Deployment 对象上，即可完成 Deployment 的自动更新操作。若更新中发生错误，则可以通过回滚恢复 Pod 版本。</p>
<h3 id="Deployment-升级"><a href="#Deployment-升级" class="headerlink" title="Deployment 升级"></a>Deployment 升级</h3><p>例：创建 nginx 的 Deployment，版本为 1.7.9</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>然后需要升级到 1.17.9 版本，先通过<code>set</code>命令设置参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl set image deployment/nginx-deploy nginx=nginx:1.17.9</span><br><span class="line">deployment.apps/nginx-deploy image updated</span><br></pre></td></tr></table></figure>

<p>此时已经开始滚动升级了，立刻查看更新过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout status deployment nginx-deploy</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 old replicas are pending termination...</span><br><span class="line">deployment &quot;nginx-deploy&quot; successfully rolled out</span><br></pre></td></tr></table></figure>

<p>再次查看 Pod 列表，能看到 pod 名称都已经更新了，可通过<code>describe</code>查看具体 Pod 情况，能看到 Pod 镜像已经更新。</p>
<p>滚动升级的流程<br><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071604530.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071604530.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type    Reason             Age                From                   Message</span><br><span class="line">  ----    ------             ----               ----                   -------</span><br><span class="line">  Normal  ScalingReplicaSet  14s (x2 over 87m)  deployment-controller  Scaled up replica set nginx-deploy-5bf87f5f59 to 1</span><br><span class="line">  Normal  ScalingReplicaSet  11s (x2 over 87m)  deployment-controller  Scaled down replica set nginx-deploy-5df494d57d to 2</span><br><span class="line">  Normal  ScalingReplicaSet  11s                deployment-controller  Scaled up replica set nginx-deploy-5bf87f5f59 to 2</span><br><span class="line">  Normal  ScalingReplicaSet  8s (x2 over 93m)   deployment-controller  Scaled up replica set nginx-deploy-5bf87f5f59 to 3</span><br><span class="line">  Normal  ScalingReplicaSet  8s                 deployment-controller  Scaled down replica set nginx-deploy-5df494d57d to 1</span><br><span class="line">  Normal  ScalingReplicaSet  6s                 deployment-controller  Scaled down replica set nginx-deploy-5df494d57d to 0</span><br><span class="line"></span><br><span class="line">查看RS情况</span><br><span class="line"># kubectl get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-5bf87f5f59   3         3         3       94m</span><br><span class="line">nginx-deploy-5df494d57d   0         0         0       90m</span><br></pre></td></tr></table></figure>

<p>在整个升级过程中，系统会保证至少有两个 Pod 有用，并最多同时运行 4 个 Pod。默认情况下，Deployment 确保 Pod 总数至少为所需副本数量（DESIRED）-1，即最多一个不可用，Pod 总数最多比所需 Pod 数多一个，即最多一个浪涌值（maxSurge&#x3D;1）。这样，升级过程中 Deployment 就能保证服务不中断，且副本数量始终维持为用户指定数量。</p>
<h4 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h4><p>在 Deployment 定义中，可通过<code>spec.strategy</code>指定 Pod 更新的策略，目前支持两种策略：</p>
<ul>
<li>Recreate 重建：设置<code>spec.strategy.type=Recreate</code>Deployment 在更新 Pod 时，会先杀掉所有正在运行的 Pod，然后重新创建 Pod</li>
<li>RollingUpdate 滚动更新：默认，设置<code>spec.strategy.type=RollingUpdate</code>，Deployment 会以滚动更新方式逐个更新 Pod，并可通过参数<code>maxUnavailable</code>和<code>maxSurge</code>控制滚动更新的过程<ul>
<li><code>maxUnavailable</code>：指定 Deployment 在更新过程中不可用 Pod 的数量上限，可以是数字，或 Pod 期望副本数的百分比（会向下取整），默认为 25%</li>
<li><code>maxSurge</code>：指定在 Deployment 更新过程中 Pod 总数超过 Pod 期望副本数部分的最大值，值类型同上，默认为 25%</li>
<li><code>maxSurge</code>越大，初始创建的新副本数量越多。<code>maxUnavailable</code>越大，初始销毁的旧副本数量越多。</li>
</ul>
</li>
</ul>
<p>多重更新（Rollover）：若在更新时再次发起更新，则会立刻将之前正在更新的 RS 停止扩容，且将其加入到旧版本 RS 列表中，并开始缩容至 0。对于 Pod，Deployment 会立刻杀死创建的中间版本的 Pod，并开始创建最后指定版本的 Pod。</p>
<h3 id="Deployment-回滚"><a href="#Deployment-回滚" class="headerlink" title="Deployment 回滚"></a>Deployment 回滚</h3><p>默认情况所有 Deployment 的发布历史记录都被保留在系统中，以便随时进行回滚。</p>
<p>可通过以下命令查看 Deployment 更新状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout status deployment nginx-deploy</span><br><span class="line">deployment &quot;nginx-deploy&quot; successfully rolled out</span><br><span class="line"></span><br><span class="line">若更新出现问题，则会卡住</span><br><span class="line"># kubectl rollout status deployment nginx-deploy</span><br><span class="line">Waiting for deployment &quot;nginx-deploy&quot; rollout to finish: 1 out of 3 new replicas have been updated...</span><br><span class="line"></span><br><span class="line"># kubectl get rs</span><br><span class="line">NAME                      DESIRED   CURRENT   READY   AGE</span><br><span class="line">nginx-deploy-57574fd9dd   1         1         0       3m48s</span><br><span class="line">nginx-deploy-5bf87f5f59   0         0         0       6m44s</span><br><span class="line">nginx-deploy-5d85b5fb59   3         3         3       4m9s</span><br><span class="line"></span><br><span class="line"># kubectl get pods</span><br><span class="line">NAME                            READY   STATUS             RESTARTS   AGE</span><br><span class="line">nginx-deploy-57574fd9dd-k9hk2   0/1     ImagePullBackOff   0          73s  # 镜像拉取出错</span><br><span class="line">nginx-deploy-5d85b5fb59-gl2ch   1/1     Running            0          88s</span><br><span class="line">nginx-deploy-5d85b5fb59-lg79f   1/1     Running            0          91s</span><br><span class="line">nginx-deploy-5d85b5fb59-vtlt2   1/1     Running            0          86s</span><br></pre></td></tr></table></figure>

<p>此时需要先查询之前的稳定版本的 Deployment，注意 REVISION 版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout history deployment nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy</span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         kubectl create --filename=nginx-deploy.yml --record=true</span><br><span class="line">2         kubectl create --filename=nginx-deploy.yml --record=true</span><br><span class="line">9         kubectl create --filename=nginx-deploy.yml --record=true</span><br><span class="line">10        kubectl create --filename=nginx-deploy.yml --record=true</span><br></pre></td></tr></table></figure>

<p>可通过<code>--revision</code>查看指定版本的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout history deployment nginx-deploy --revision 2</span><br><span class="line">deployment.apps/nginx-deploy with revision #2</span><br><span class="line">Pod Template:</span><br><span class="line">  Labels:       app=nginx</span><br><span class="line">        pod-template-hash=7b45d69949</span><br><span class="line">  Annotations:  kubernetes.io/change-cause: kubectl create --filename=nginx-deploy.yml --record=true</span><br><span class="line">  Containers:</span><br><span class="line">   nginx:</span><br><span class="line">    Image:      nginx:1.16.1</span><br><span class="line">    Port:       80/TCP</span><br><span class="line">    Host Port:  0/TCP</span><br><span class="line">    Environment:        &lt;none&gt;</span><br><span class="line">    Mounts:     &lt;none&gt;</span><br><span class="line">  Volumes:      &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>此时要退回到 revision 2，则可以指定版本回滚</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout undo deployment nginx-deploy --to-revision=2</span><br><span class="line">deployment.apps/nginx-deploy rolled back</span><br></pre></td></tr></table></figure>

<p>对于复杂的 Deployment 配置修改，为避免频繁触发 Deployment 的更新操作，可先暂停 Deployment 的更新操作，然后进行配置修改，再恢复 Deployment，一次性触发完整的更新操作。</p>
<p>暂停 Deployment 的更新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout pause deployment nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy paused</span><br></pre></td></tr></table></figure>

<p>修改完成后恢复 Deployment 的部署</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl rollout resume deployment nginx-deploy</span><br><span class="line">deployment.apps/nginx-deploy resumed</span><br></pre></td></tr></table></figure>

<p><strong>注：暂停 Deployment 期间是不能进行回滚的</strong></p>
<h4 id="RC-滚动升级"><a href="#RC-滚动升级" class="headerlink" title="RC 滚动升级"></a>RC 滚动升级</h4><p>K8s 通过配置文件进行</p>
<p>例：RC redis-master 的 v1 版本升级到 v2 版本</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RC的v1版本的配置</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-master</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redis-master</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-master</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubeguide/redis-master:1.0</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kubectl get rc -o wide</span></span><br><span class="line"><span class="string">NAME</span>              <span class="string">DESIRED</span>   <span class="string">CURRENT</span>   <span class="string">READY</span>   <span class="string">AGE</span>     <span class="string">CONTAINERS</span>        <span class="string">IMAGES</span>                       <span class="string">SELECTOR</span></span><br><span class="line"><span class="string">redis-master-v1</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">0</span>       <span class="string">3m18s</span>   <span class="string">redis-master-v1</span>   <span class="string">kubeguide/redis-master:1.0</span>   <span class="string">name=redis-master,version=v1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RC的v2版本的配置，是修改的v1的配置文件</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">redis-master-v2</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">redis-master</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v2</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis-master-v2</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">kubeguide/redis-master:2.0</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">minReadySeconds:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">strategy:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">RollingUpdate</span></span><br><span class="line">        <span class="attr">rollingUpdate:</span></span><br><span class="line">          <span class="attr">maxSurge:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">maxUnavailable:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="Pod-扩缩容"><a href="#Pod-扩缩容" class="headerlink" title="Pod 扩缩容"></a>Pod 扩缩容</h2><h3 id="手动扩缩容"><a href="#手动扩缩容" class="headerlink" title="手动扩缩容"></a>手动扩缩容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replicas-number&gt;</span><br></pre></td></tr></table></figure>

<p>若设置为比当前副本数量更小的数字，则会杀死一些正在运行的 pod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get deployments</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   3/3     3            3           5h42m</span><br><span class="line"></span><br><span class="line">[root@kubenode1 ~]# kubectl scale deployment nginx-deploy --replicas=5</span><br><span class="line">deployment.apps/nginx-deploy scaled</span><br><span class="line"></span><br><span class="line"># kubectl get deployments</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx-deploy   5/5     5            5           5h43m</span><br></pre></td></tr></table></figure>

<h2 id="K8s弹性伸缩"><a href="#K8s弹性伸缩" class="headerlink" title="K8s弹性伸缩"></a>K8s弹性伸缩</h2><p>三种弹性伸缩：</p>
<ul>
<li>CA（Cluster Autoscaler）：Node级别自动扩缩容，通过cluster-autoscaler组件（主要是在云服务商上进行创建新节点，Cluster AutoScaler会监听Node资源使用情况。还有一种就是通过ansible等方式进行扩容）</li>
<li>HPA（Horizontal Pod Autoscaler）：Pod个数自动扩缩容</li>
<li>VPA（Vertical Pod Autoscaler）：Pod配置（如CPU、内存）自动扩缩容，通过addmin-resizer组件（主要对象是有些有状态的服务，不能横向扩容）</li>
</ul>
<h3 id="HPA"><a href="#HPA" class="headerlink" title="HPA"></a>HPA</h3><p>Horizontal Pod Autoscaler（Pod 横向自动扩容），也是一种资源对象。通过追踪分析指定 RC 控制的所有目标 Pod 的负载情况，来确定是否需要针对性调整目标 Pod 的副本数量。由于需要监控Node的性能信息，所以依赖Metrics Server组件。<br>HPA 有两种方法作为 Pod 负载的度量指标：</p>
<ul>
<li>CPUUtilizationPercentage，是目标 Pod 所有副本自身 CPU 利用率的算数平均值（<code>Pod自身CPU利用率=Pod当前CPU使用量/Pod Request</code>）。<ul>
<li>若某一时刻该值超过 80%，则意味着当前 Pod 副本数量不足以支撑更多请求，需要动态扩容，而当请求高峰过去，CPU 利用率又降下来，则副本数也自动减少到一个合理值。</li>
<li>通常是 1min 的平均值</li>
<li>K8s 通过基础性能数据监控框架（Kubernetes Monitoring Architecture）支持 HPA。该框架中 K8s 定义了标准化 API 接口 Resource Metrics API，方便客户端（如 HPA）获取性能数据</li>
</ul>
</li>
<li>应用自定义的度量指标（如 TPS、QPS）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">例：</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>   <span class="comment"># HPA控制一个叫php-apache的Deployment中的Pod副本</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">php-apache</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">90</span>    <span class="comment"># 该值超过90%则触发自动扩容</span></span><br></pre></td></tr></table></figure>

<p>为防止副本数量因扩容大幅波动，K8s在Controller manager中设置了冷却时间，即在每次扩缩容后的冷却时间。</p>
<ul>
<li>horizontal-pod-autoscaler-downscale-dalay: 缩容冷却，默认5min</li>
<li>horizontal-pod-autoscaler-upscale-dalay: 扩容冷却，默认3min</li>
</ul>
<p>目前除了<code>autoscaling/v1</code>（仅支持基于CPU使用率）外，还有<code>autoscaling/v2beta2</code>，支持了多指标以及自定义指标。</p>
<p>从 v1.18 开始，<code>v2beta2</code> API 允许通过 HPA 的 <code>behavior</code> 字段配置扩缩行为。 在 behavior 字段中的 scaleUp 和 scaleDown 分别指定扩容和缩容行为。 可以两个方向指定一个稳定窗口，以防止扩缩目标中副本数量的波动。 类似地，指定扩缩策略可以控制扩缩时副本数的变化率。<br>在 <code>spec</code> 字段的 <code>behavior</code> 部分可以指定一个或多个扩缩策略。 当指定多个策略时，默认选择允许更改最多的策略，就是说每个操作周期都会计算当前该策略能操作的pod数，然后挑能操作pod数最多的策略执行。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">behavior:</span></span><br><span class="line">  <span class="attr">scaleDown:</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">4</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">60</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">60</span></span><br></pre></td></tr></table></figure>

<p>当用于扩缩的指标持续抖动时，可以使用稳定窗口来限制副本数上下振动。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">scaleDown:</span></span><br><span class="line">  <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>

<p>默认扩缩容行为，即未设置的默认配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">behavior:</span></span><br><span class="line">  <span class="attr">scaleDown:</span>   <span class="comment"># 缩容配置</span></span><br><span class="line">    <span class="attr">stabilizationWindowSeconds:</span> <span class="number">300</span>    <span class="comment"># 稳定窗口为300s</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span>      <span class="comment"># 按照百分率</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">100</span>         <span class="comment"># 可以直接降低到最小允许的副本数，即minReplicas配置。</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">15</span>  <span class="comment"># 每15s为一个操作周期</span></span><br><span class="line">  <span class="attr">scaleUp:</span>     <span class="comment"># 扩容配置</span></span><br><span class="line">    <span class="attr">stabilizationWindowSeconds:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">policies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Percent</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">100</span>         <span class="comment"># 可以直接扩容到最大允许的副本数，即maxReplicas配置。</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">15</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">Pods</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">4</span></span><br><span class="line">      <span class="attr">periodSeconds:</span> <span class="number">15</span></span><br><span class="line">    <span class="attr">selectPolicy:</span> <span class="string">Max</span></span><br></pre></td></tr></table></figure>

<h1 id="深入理解-Service"><a href="#深入理解-Service" class="headerlink" title="深入理解 Service"></a>深入理解 Service</h1><p>通过创建 Service 可为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。</p>
<p>两种方法创建 Service：</p>
<ul>
<li>先创建 RC 或 Deployment，然后执行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl expose rc|deployment &lt;rc-name|deployment-name&gt;</span><br></pre></td></tr></table></figure>
然后查看服务<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get svc</span><br><span class="line">NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">kubernetes                 ClusterIP   192.168.10.1     &lt;none&gt;        443/TCP    4d1h</span><br><span class="line">webapp-tomcat              ClusterIP   192.168.10.144   &lt;none&gt;        8080/TCP   5m47s</span><br><span class="line">webapp-tomcat-deployment   ClusterIP   192.168.10.67    &lt;none&gt;        8080/TCP   5m40s</span><br></pre></td></tr></table></figure>
就可通过 ClusterIP 加上端口访问该服务了</li>
<li>直接 YAML 创建 Service<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webapp-tomcat-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">webapp-tomcat-service</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">808</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>
Service 的关键字段为 ports 和 selector。posts 为提供给外部访问的端口，selector 为后端 pod 的 label。</li>
</ul>
<p>Service 的 Pod 被 k8s 进行负载负载均衡，具体有两种分发策略：</p>
<ul>
<li>RoundRobin：轮询（默认）</li>
<li>SessionAffinity：基于客户端 IP 进行会话保持。相同客户端 IP 的请求分到同一个 Pod 上。若要修改为此模式，则需要在配置中 spec 下添加<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sessionAffinity:</span> <span class="string">ClientIP</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>若服务开放多个端口，则需要在每个端口定义内加上<code>name</code>定义。且端口定义中可指定传输层协议，通过添加<code>protocol</code>定义。</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">app-dns</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">app-dns</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.200</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">53</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dns-tcp</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">53</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">UDP</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dns-udp</span></span><br></pre></td></tr></table></figure>

<h2 id="外部服务-Service"><a href="#外部服务-Service" class="headerlink" title="外部服务 Service"></a>外部服务 Service</h2><p>若应用需要连接一个外部数据库，或将另一个集群或 Namespace 中服务作为服务的后端，这时需要创建一个无 Label Selector 的 Service。</p>
<p>例：一个无标签 http 服务，开放端口 80，但指向另一个 http 服务，目的 IP 为 10.1.1.2</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nolabel-http-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nolabel-http-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ip:</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>分别创建一个无标签 Service 和一个 Endpoint，因为<strong>系统不会自动创建 Endpoint，且该 Endpoint 需要和 Service 同名</strong>，指向实际后端访问 IP。</p>
<h2 id="Headless-Service"><a href="#Headless-Service" class="headerlink" title="Headless Service"></a>Headless Service</h2><p>若需要自己控制负载均衡策略，而不使用 Service 默认负载策略，则可使用 Headless Service，<strong>不为 Service 设置 ClusterIP，仅通过 Label Selector 将后端 Pod 列表返回给调用的客户端。</strong>不指定特定的 ClusterIP，访问该 service 将会返回所有标签为 app&#x3D;nginx 的 Pod 列表，然后客户端自定义策略如何处理该列表。StatefulSet 就是使用 Headless Service 为客户端返回多个服务地址的。Headless Service 主要应用在<strong>去中心化的应用集群</strong>。</p>
<p>例：创建 Headless nginx 服务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">headless-nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br></pre></td></tr></table></figure>

<p>查看该服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get service headless-nginx</span><br><span class="line">NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">headless-nginx   ClusterIP   None         &lt;none&gt;        80/TCP    49m</span><br></pre></td></tr></table></figure>

<h3 id="通过-Service-动态查找-Pod"><a href="#通过-Service-动态查找-Pod" class="headerlink" title="通过 Service 动态查找 Pod"></a>通过 Service 动态查找 Pod</h3><p>由于 pod 的创建和销毁都会实时更新 Service 的 Endpoint 数据，所以可动态对 Service 的后端 Pod 进行查询，因此一个 Cassandra 节点只需要查询到其他节点就能自动组成一个集群。</p>
<p>Cassandra 节点加入集群的过程<br><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071603288.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071603288.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<ol>
<li>新节点出现会更新 Service 的 Endpoint</li>
<li>Master 获取 Service 的后端 Endpoint，将新 Pod 加入集群</li>
</ol>
<p>创建服务 cassandra，并打上标签 app&#x3D;cassandra，且 selector 也选择 app&#x3D;cassandra。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cassandra</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cassandra</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">9042</span></span><br></pre></td></tr></table></figure>

<p>创建 RC</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cassandra</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">cassandra</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">cassandra</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">cassandra</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cassandra</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">cassandra</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9042</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">cql</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9160</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">thrift</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/cassandra_data</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/run.sh</span></span><br><span class="line">        <span class="string">res</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">data</span></span><br><span class="line">        <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="从集群外部访问-Pod-和-Service"><a href="#从集群外部访问-Pod-和-Service" class="headerlink" title="从集群外部访问 Pod 和 Service"></a>从集群外部访问 Pod 和 Service</h2><h1 id="核心组件运行机制"><a href="#核心组件运行机制" class="headerlink" title="核心组件运行机制"></a>核心组件运行机制</h1><h2 id="API-Server"><a href="#API-Server" class="headerlink" title="API-Server"></a>API-Server</h2><p>APIserver 的功能：</p>
<ul>
<li>提供 K8s 各资源对象的增删改查及 Watch 等 REST 接口，是整个系统的数据总线和数据中心</li>
<li>是集群管理的 API 入口</li>
<li>是资源配额控制的入口</li>
<li>提供完备的集群安全机制</li>
</ul>
<p>默认 kube-apiserver 在 master 上 8080 端口提供服务，也可启动 HTTPS 安全端口启动安全机制。</p>
<p>常见 REST API：</p>
<ul>
<li>apiserver 支持的资源对象列表：<code>localhost:8080/api/v1</code></li>
<li>pod 列表：<code>localhost:8080/api/pods</code></li>
<li>service 列表：<code>localhost:8080/api/services</code></li>
<li>RC 列表：<code>localhost:8080/api/replicationcontrollers</code></li>
<li>等</li>
</ul>
<p>若只要对外暴露部分 REST，则需要在 Master 或其他节点运行 proxy，在 8001 端口启动代理拒绝客户端访问 RC 的 API</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl proxy --reject-paths=&quot;^/api/v1/replicationcontrollers&quot; --port=8001 --v=2</span><br></pre></td></tr></table></figure>

<p>然后访问该 REST 查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># curl localhost:8001/api/v1/replicationcontrollers</span><br><span class="line">Forbidden</span><br></pre></td></tr></table></figure>

<p>K8s apiserver 本身就是一个 Service，名叫 kubernetes，且 ClusterIP 就是地址池的第一个地址，端口是 HTTPS&#x2F;443</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># kubectl get service</span><br><span class="line">NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   192.168.10.1   &lt;none&gt;        443/TCP   6d2h</span><br></pre></td></tr></table></figure>

<p>K8s 设计通过以下方式最大程度保证 API server 的性能：</p>
<ul>
<li>API server 的底层代码性能高，使用了协程和队列的并发代码</li>
<li>普通 List 接口结合异步 Watch 接口，解决了资源对象高性能同步问题并提高了响应事件的灵敏度</li>
<li>采用 etcd 解决了数据可靠性问题，提升了 APIserver 数据访问层的性能</li>
</ul>
<p>API Server 架构：</p>
<ul>
<li>API 层：以 REST 提供各种 API</li>
<li>访问控制层：当客户端访问 API 时负责对用户身份的鉴权，进行访问控制（许可逻辑 Admission Controll）</li>
<li>注册表层：K8s 将所有资源对象都保存在注册表（Registry）中，包含了资源对象类型、如何创建资源对象、如何转换资源版本、如何将资源编码和解码为 Json 或 ProtoBuf 格式</li>
<li>etcd 数据库</li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071604800.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071604800.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>完整 Pod 的调度机制 List-Watch</p>
<ol>
<li>API server 通过 etcd 提供的 Watch API 监听 etcd 上发生的数据操作，如 Pod 创建更新等，etcd 会及时通知 APIserver。当一个 ReplicaSet 对象被创建并保存到 etcd 后，etcd 立刻发送一个 Create 事件给 API Server。</li>
<li>API Server 通过自身的 Watch 接口获取它们感兴趣的任务资源对象的相关事件。</li>
<li>K8s List-Watch 实现数据同步，客户端先调用 API server 的 List 接口获取相关资源对象的全量数据并缓存到内存中，然后启动对应资源对象的 Watch 协程，接收到 Watch 事件后根据事件类型对内存的全量资源对象列表同步修改，能达到近乎实时的数据同步</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071604806.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202206071604806.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>所有 K8s 内建的资源对象实现都包含以下功能：</p>
<ul>
<li>元数据（Schema）定义：定义了资源对象的数据结构</li>
<li>校验逻辑：确保用户提交的资源对象属性的合法性</li>
<li>CRUD 代码</li>
<li>自动控制器：确保对应资源对象的数量、状态、行为始终符合用户期望</li>
</ul>
<h2 id="Controller-Manager"><a href="#Controller-Manager" class="headerlink" title="Controller Manager"></a>Controller Manager</h2><p>在 K8s 中，每个 Controller 都是一个功能系统，通过 APIServer 提供的 List-Watch 接口实时监控集群中特定资源的状态变化，当发生各种故障导致资源对象状态变化时，Controller 会尝试将其状态调整为期望的状态。Controller Manager 是 K8s 各种 Controller 的管理者，是集群内的管理控制中心和自动化的核心。</p>
<h3 id="Replication-Controller-1"><a href="#Replication-Controller-1" class="headerlink" title="Replication Controller"></a>Replication Controller</h3><p>与资源对象 ReplicationController（RC）不同，在 Controller Manager 中的 Replication Controller 为<strong>副本控制器</strong>，核心作用为确保任何时候集群中某个 RC 关联的 Pod 副本数量保持预定值。<br>注：只有 Pod 的重启策略为 Always 时（<code>RestartPolicy=Always</code>），Replication Controller 才会管理该 Pod 的操作。<br>通常情况下 Pod 对象被成功创建后就不会消失，除非 Pod 处于 succeed 或 failed 状态的时间过长，该 Pod 就会被系统自动回收，然后副本控制器在其他节点上重新创建该 Pod 副本。</p>
<p>Pod 可通过修改标签来脱离 RC 的管控，一般用在将 Pod 从集群中迁移、数据修复等调试，对于被迁移的 Pod 副本，RC 会自动新建一个副本替换被迁移的副本。<br>若要删除一个 RC 控制的所有 Pod，只需将 RC 定义的副本数设为 0 并应用即可。</p>
<h3 id="Node-Controller"><a href="#Node-Controller" class="headerlink" title="Node Controller"></a>Node Controller</h3><p>Node Controller 通过 API Server 实时获取 Node 的相关信息，实现管理和监控集群中的各 Node 的相关控制功能。</p>
<p>工作流程：</p>
<ol>
<li>Controller Manager 若在启动时设置了<code>cluster-cidr</code>参数，则会为每个没有设置<code>Spec.PodCIDR</code>的 Node 都生成一个 CIDR 地址，然后再用该 CIDR 地址设置<code>Spec.PodCIDR</code>，从而防止 CIDR 地址冲突</li>
<li>逐个读取 Node 信息，尝试修改 nodeStatusMap 的节点状态信息，将该信息与 Node Controller 的 nodeStatusMap 的节点信息比较。<ul>
<li>若没收到 kubelet 发的节点信息、或者是第一次收到节点信息、或者处理过程中节点状态变为非健康状态，则在 nodeStatusMap 中保存该节点状态信息，且修改探测时间与节点状态变化时间为 Master 节点的系统时间</li>
<li>若指定时间内收到新的节点信息，且节点状态未发生变化，则在 nodeStatusMap 中保存该节点状态，且修改探测时间为 Master 节点的系统时间、节点状态变化时间为上次节点变化时间</li>
<li>若指定时间内收到新的节点信息，且节点状态发生变化，则在 nodeStatusMap 中保存该节点状态，且修改探测时间和节点状态变化时间为 Master 节点的系统时间</li>
<li>若指定时间内未收到节点信息，则设置节点状态为未知，并通过 API server 保存节点状态</li>
</ul>
</li>
<li>逐个读取节点信息，根据节点状态删除或同步节点信息</li>
</ol>
<h3 id="ResourceQuota-Controller"><a href="#ResourceQuota-Controller" class="headerlink" title="ResourceQuota Controller"></a>ResourceQuota Controller</h3><p>ResourceQuota Controller（资源配额管理）确保了指定资源对象在任何时刻都不会超量占用系统物理资源。目前支持三个层次的配额管理：</p>
<ul>
<li>容器级别：对 CPU 和内存</li>
<li>Pod 级别：对 Pod 内所有容器的资源</li>
<li>Namespace 级别：多租户级别的资源限制，包括：Pod 数量、ReplicationController 数量、Service 数量、ResourceQuota 数量、Secret 数量、PV 数量</li>
</ul>
<p>配额管理通过 Admission Control（准入控制）来控制，提供两种方式：</p>
<ul>
<li>LimitRanger：作用于 Pod 和 Container</li>
<li>ResourceQuota：作用于 Namespace</li>
</ul>
<p>若在 Pod 中声明了 LimitRanger，则通过 APIserver 请求创建或修改资源时，Admission Control 会计算当前配额的使用情况，若不符合配额约束，则创建失败。<br>若在 Namespace 中声明了 ResourceQuota，则 ResourceQuota Controller 负责定期统计和生成该 Namespace 下各个资源对象的资源使用总量并写入 etcd 的 resourceQuotaStatusStorage 目录（resourceQuotas&#x2F;status），然后这些统计被 Admission Control 使用，确保相关 Namespace 下资源配额总量不超过 ResourceQuota 的限定值。</p>
<h3 id="Namespace-Controller"><a href="#Namespace-Controller" class="headerlink" title="Namespace Controller"></a>Namespace Controller</h3><p>用户通过 APIServer 创建新的 Namespace 并保存在 etcd 中，Namespace Controller 定时通过 API Server 读取这些 Namespace 信息。</p>
<p>若 Namespace 被 API 标识为优雅删除（<code>DeletionTimestamp</code>属性，删除期限），则将该 Namespace 状态设为 Terminating 并保存在 etcd 中，同时 Namespace Controller 删除该 Namespace 下的 ServiceAccount、RC、Pod、Secret、PersistentVolume、ListRange、ResourceQuota 和 Event 等资源对象。</p>
<h3 id="Service-Controller-和-Endpoints-Controller"><a href="#Service-Controller-和-Endpoints-Controller" class="headerlink" title="Service Controller 和 Endpoints Controller"></a>Service Controller 和 Endpoints Controller</h3><p>Endpoints 表示了一个 Service 对应的所有 Pod 副本的访问地址，Endpoints Controller 就是负责生成和维护所有 Endpoints 对象的控制器。<br>Endpoints Controller 监听 Service 和对应 Pod 副本的变化</p>
<ul>
<li>若检测到 Service 被删除，则删除和该 Service 同名的 Endpoints 对象</li>
<li>若检测到 Service 被创建或修改，则根据该 Service 信息获取相应 Pod 列表，然后创建更新对应 Endpoints 对象</li>
<li>若检测到 Pod 事件，则更新对应 Service 的 Endpoints 对象</li>
</ul>
<p>Service Controller 监听 Service 变化，若该 Service 是 LoadBalancer 类型，则 Service Controller 确保在外部云平台上该 Service 对应的 LoadBalancer 实例被相应地创建、删除或更新。</p>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p>Scheduler 在整个系统中担任承上启下的作用，将待调度的Pod（API新创建的Pod，Controller Manager为补足副本而创建的Pod等）按特定调度算法和调度策略绑定到集群中某个合适的节点，并将绑定信息写入etcd。</p>
<ul>
<li>承上：接收controller manager创建的新Pod，将Pod调度到最合适的Node。</li>
<li>启下：目标节点的kubelet进程接管后续工作，负责Pod生命周期的后续。</li>
</ul>
<p>调度中涉及三个对象：待调度Pod列表，可用Node列表，调度算法及策略。简单说，就是通过调度算法为待调度pod列表中每个pod从Node列表中选择一个最合适的Node。</p>
<p>随后，目标节点上的kubelet通过APIserver监听到kubernetes Scheduler产生的pod绑定事件，然后获取对应Pod清单，下载镜像并启动容器。</p>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202207251111901.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202207251111901.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>Scheduler默认调度流程分以下两步：</p>
<ol>
<li>预选调度过程：遍历所有目标节点，筛选出符合要求的候选节点，K8S内置了多种预选策略。</li>
<li>确定最优节点，在第一步基础上采用优选策略计算出每个候选节点的积分，积分高者胜出。</li>
</ol>
<p>Scheduler调度流程是通过插件方式加载的调度算法提供者（AlgorithmProvider）具体实现的，一个AlgorithmProvider就是包括一组预选策略与一组优先选择策略的结构体。</p>
<p>以下为<strong>预选策略</strong>：</p>
<ol>
<li><strong>NoDiskConflict</strong>：读取pod volume信息（<code>pod.Spec.Volumes</code>），<strong>对每个volume进行冲突检测</strong>：<ul>
<li>若volume是gcePersistentDisk，将volume和备选节点上所有pod的每个volume进行比较，若发现相同gcePersistentDisk，则返回false，表明存在磁盘冲突，反馈给调度器该备选节点不适合备选pod</li>
<li>若volume是AWSElasticBlockStore，则将volume和备选节点上所有pod的每个volume进行比较，同上。</li>
<li>若上述检查均未发现冲突，则返回true，表明不存在磁盘冲突，反馈给调度器该备选节点适合备选pod。</li>
</ul>
</li>
<li><strong>PodFitsResources</strong>：判断备选<strong>节点资源是否满足备选pod需求</strong>。检测过程如下：<ul>
<li>计算备选pod和节点中已存在pod的所有容器的需求资源总和。</li>
<li>获得备选节点的状态信息，包含节点资源信息</li>
<li>若备选pod和节点中已存在pod的所有容器的需求资源总和超出了备选节点的资源，则返回false，表明备选节点不适合备选pod，否则返回true。</li>
</ul>
</li>
<li><strong>PodSelectorMatches</strong>：判断备选节点<strong>是否包含备选pod的标签选择器指定的标签</strong>。<ul>
<li>若pod没有指定<code>spec.nodeSelector</code>标签选择器，则返回true。</li>
<li>否则获得备选节点的标签信息，判断节点是否包含备选pod的标签选择器所指定的标签，若包含返回true，否则返回false。</li>
</ul>
</li>
<li><strong>PodFitsHost</strong>：判断备选pod的<code>spec.nodeName</code><strong>指定的节点名和备选节点是否一致</strong>，若一致则返回true，否则返回false。</li>
<li>CheckNodeLabelPresence：若用户在配置文件中指定了该策略，则Scheduler会通过RegisterCustomFitPredicate方法注册该策略，该策略用于判断策略列出的标签在备选节点中存在时，是否选择该备选节点。检测过程如下：<ul>
<li>读取备选节点的标签列表信息</li>
<li>若策略配置的标签列表存在于备选节点的标签列表中，且策略配置的presence值为false，则返回false，否则返回true。</li>
<li>若策略配置的标签列表不存在于备选节点的标签列表中，且策略配置的presence值为true，则返回false，否则返回true。</li>
</ul>
</li>
<li>CheckServicesAffinity：若用户在配置文件中指定了该策略，则Scheduler会通过RegisterCustomFitPredicate方法注册该策略，该策略用于判断备选节点是否包含策略指定的标签，或包含和备选pod在相同service和namespace下的pod所在节点的标签列表。若存在返回true，否则返回false。</li>
<li><strong>PodFitsPorts</strong>：判断备选pod所用的端口列表中的<strong>端口是否在备选节点中已被占用</strong>，若被占用则返回false，否则返回true。</li>
</ol>
<p>以下为<strong>优选策略</strong>：</p>
<ol>
<li>LeastRequestedPriority：用于从备选节点列表中选出<strong>资源消耗最小的节点</strong><ul>
<li>计算出在所有备选节点上运行的pod和备选pod的cpu占用量totalMilliCPU。</li>
<li>计算出在所有备选节点上运行的pod和备选pod的呢哦次年占用量totalMemory。</li>
<li>计算每个节点的得分，规则大致如下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">score = int(((nodeCpuCapacity - totalMilliCPU) * 10) / nodeCpuCapacity + ((nodeMemoryCapacity - totalMemory) * 10) / nodeMemoryCapacity) / 2)</span><br><span class="line"></span><br><span class="line"># nodeCpuCapacity 为节点CPU</span><br><span class="line"># nodeMemoryCapacity 为节点内存</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>CalculateNodeLabelPriority：若用户在配置文件中指定了该策略，则Scheduler会通过RegisterCustomPriorityFunction方法注册该策略。该策略用于判断策略列出的标签在备选节点中存在时，是否选择该备选节点。<ul>
<li>若备选节点的标签在优选策略的标签列表中且优选策略的presence值为true，或备选节点的标签不在优选策略的标签列表中且优选策略的presence值为false，则备选节点score&#x3D;10，否则备选节点score&#x3D;0。</li>
</ul>
</li>
<li>BalancedResourceAllocation：用于从备选节点列表中选出各项资源使用率最均衡的节点。<ul>
<li>计算出在所有备选节点上运行的pod和备选pod的cpu占用量totalMilliCPU。</li>
<li>计算出在所有备选节点上运行的pod和备选pod的呢哦次年占用量totalMemory。</li>
<li>计算每个节点的得分，规则大致如下 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">score = int(10 - math.Abs(totalMilliCPU / nodeCpuCapacity - totalMemory / nodeMemoryCapacity) * 10)</span><br><span class="line"></span><br><span class="line"># nodeCpuCapacity 为节点CPU</span><br><span class="line"># nodeMemoryCapacity 为节点内存</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h2><p>每个Node上都启动kubelet服务进程，用于处理master下发到本节点的任务，并管理pod以及pod中的容器。每个kubelet进程都会在apiserver上注册节点自身的信息，定时（默认10s）向master汇报节点资源的使用情况，并通过cadvisor监控容器和节点资源，apiserver收到信息后，将这些信息写入到etcd。</p>
<h3 id="pod管理"><a href="#pod管理" class="headerlink" title="pod管理"></a>pod管理</h3><p>kubelet通过以下几种方法获取node上要运行的pod清单：</p>
<ol>
<li>文件：kubelet启动参数<code>--config</code>指定配置文件目录下的文件（默认<code>/etc/kubernetes/manifests/</code>），这里指定的pod就不由kube-controller-manager进行管理，称为静态pod。</li>
<li>http端点（url）：通过<code>--manifest-url</code>设置，获取远程目录下的pod列表。</li>
<li>apiserver：kubelet通过apiserver监听etcd目录，同步pod列表。</li>
</ol>
<p>所有以非apiserver方式创建的pod都称为静态pod（static pod），kubelet将静态pod的状态汇报给apiserver，然后apiserver为该静态pod创建一个mirror pod与之匹配，mirror pod的状态也将真实反映静态pod的状态。当静态pod删除时，对应的mirror pod也会被删除。</p>
<p>kubelet监听etcd，所有针对pod的操作都会被kubelet监听，若发现有新的绑定到本节点的pod，则按pod清单的要求创建pod。<br>若发现本地pod被修改，则kubelet会做出相应修改，例如通过docker client删除容器。</p>
<p>kubelet若监听到创建或修改pod的任务，则按以下流程处理：</p>
<ol>
<li>为该pod创建一个数据目录</li>
<li>从apiserver读取该pod清单</li>
<li>为该pod挂载外部卷</li>
<li>下载pod用到的secret</li>
<li>检查已运行在节点的pod，若该pod没有容器或pause容器未启动，则先停止pod内所有容器的进程，若pod中有需要删除的容器，则删除这些容器</li>
<li>用pause容器为每个pod创建一个容器，pause容器接管pod中所有其他容器的网络</li>
<li>为每个容器计算一个hash值，然后用容器名称去查询对应docker容器的hash值，若找到，且hash值不同，则停止docker中容器的进程，并停止与之关联的pause容器；若找到且hash值相同，则不做处理</li>
<li>调用docker client下载容器镜像并启动容器</li>
</ol>
<h3 id="cAdvisor资源监控"><a href="#cAdvisor资源监控" class="headerlink" title="cAdvisor资源监控"></a>cAdvisor资源监控</h3><p>cAdvisor是一个开源容器资源分析工具，也被集成到Kubernetes的代码中，kubelet通过cAdvisor获取其所在节点及容器的数据，cAdvisor会自动查找所有节点上的容器，采集cpu、内存、文件系统、网络的使用情况。</p>
<p>cAdvisor只能提供2-3分钟的监控数据，没有对数据进行持久化。从k8s 1.8版本开始。性能指标数据的查询接口升级为标准的metrics api，后端服务升级为Metrics Server，Metrics Server用于提供core metrics（核心指标），包括node、pod的cpu和内存数据。</p>
<h2 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h2><p>Kube-proxy是真正将service作用落实的组件。在每个node上都运行了一个kube-proxy服务进程，可以把这个进程看做service的透明代理兼负载均衡器，核心功能是将到某个service的访问请求转发到后端的多个pod实例上。并且service的ClusterIP和NodePort等概念是kube-proxy服务通过iptables的NAT转换实现的，kube-proxy在运行过程中动态创建与service相关的iptables规则，实现了将访问服务的请求负载分发到后端pod的功能。由于iptables机制针对的是本地的kube-proxy端口，所以在每个node上都要运行kube-proxy组件，于是便可以在集群内任意node上对service进行请求。综上，由于kube-proxy，在service调用过程中客户端无须关心后端有几个pod，中间过程的通信、负载均衡和故障恢复都是透明的。</p>
<h3 id="iptables模式"><a href="#iptables模式" class="headerlink" title="iptables模式"></a>iptables模式</h3><p>iptables作为kube-proxy的默认模式，iptables模式下的kube-proxy不再起到proxy作用，核心功能为：通过API server的watch接口实时跟踪service和endpoint的变更信息，并更新对应的iptables规则，client的请求流量则通过iptables的NAT机制直接路由到目标pod。</p>
<p>iptables模式完全在内核态工作，不用再经过用户态的kube-proxy中转，因此性能更强。</p>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202208011352390.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202208011352390.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>iptables模式虽然简单，但是存在无法避免的缺陷：集群中的service和pod大量增加后，iptables的规则会急速膨胀，导致性能下降，在某些极端情况下会出现规则丢失的情况。</p>
<h3 id="ipvs模式"><a href="#ipvs模式" class="headerlink" title="ipvs模式"></a>ipvs模式</h3><p>为了解决iptables缺陷，k8s在1.8版本引入ipvs模式，并在1.11版本升级为稳定版。<br>虽然iptables和ipvs都是基于netfilter实现的，但是定位不同，iptables是为防火墙设计的，ipvs是专门用于高性能负载均衡，使用更高效的数据结构（hash表），允许几乎无限的规模扩张。</p>
<p>相比iptables，ipvs有以下优势：</p>
<ol>
<li>为大型集群提供更好的可扩展性和性能</li>
<li>支持比iptables更复杂的负载均衡算法</li>
<li>支持服务器健康检查和连接重试等功能</li>
<li>可动态修改ipset集合，即使iptables规则也正在使用这个集合</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202208011439628.png" class="lazyload" data-srcset="https://gcore.jsdelivr.net/gh/serchaofan/picBed/blog/202208011439628.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<p>由于ipvs无法提供包过滤、地址伪装、SNAT等功能，因此在某些场景（如NodePort实现）还需要与iptables搭配使用。在ipvs模式下，kube-proxy使用了iptables的扩展ipset，而不是直接调用iptables生成规则链。</p>
<blockquote>
<p>iptables规则链是一个线性的数据结构，ipset则引入了带索引的数据结构，因此当规则很多时，也可以高效地查找与匹配。<br>可以将ipset理解为一个ip（段）的集合，这个集合可以是ip地址、ip网段、端口等，iptables可直接添加规则对这个可变集合进行操作，大大减少了iptables规则的数量，从而减少了性能损耗。<br>假设要禁止上万的ip访问服务器，若使用iptables，就需要一条一条地添加规则，会在iptables中生成大量的规则。若使用ipset，只需要将相关的ip地址加入ipset集合中集合，这样只需要设置少量的iptables规则即可实现。</p>
</blockquote>
<p>kube-proxy针对service和pod创建的一些主要的iptables规则如下：</p>
<ul>
<li>KUBE-CLUSTER-IP：在<code>masquerad-all=true</code>或clusterCIDR指定的情况下对Service ClusterIP地址进行伪装，解决数据包欺骗问题。</li>
<li>KUBE-EXTERNAL-IP：将数据包伪装为Service的外部IP地址。</li>
<li>KUBE-LOAD-BALANCER、KUBE-LOAD-BALANCER-LOCAL：伪装LoadBalancer类型的Service流量。</li>
<li>KUBE-NODE-PORT-TCP、KUBE-NODE-PORT-LOCAL-TCP、KUBE-NODE-PORT-UDP、KUBE-NODE-PORT-LOCAL-UDP：伪装NodePort类型的Service流量。</li>
</ul>
<blockquote>
<p>参考文章</p>
<p><a href="#http://www.dockone.io/article/932">十分钟带你理解 Kubernetes 核心概念</a></p>
<p><a target="_blank" rel="noopener" href="https://jimmysong.io/kubernetes-handbook/">Kubernetes Handbook——Kubernetes 中文指南&#x2F;云原生应用架构实践手册</a></p>
<p><a target="_blank" rel="noopener" href="http://docs.kubernetes.org.cn/">Kubernetes 中文社区 | 中文文档</a></p>
<p><a target="_blank" rel="noopener" href="https://k8s-install.opsnull.com/">和我一步步部署 kubernetes 集群</a></p>
<p>docker 容器与容器云</p>
<p>Docker 高级应用实战——李振良——视频课程</p>
<p>Kubernetes 权威指南（第四版）</p>
<p>每天 5 分钟玩转 Kubernetes</p>
<p><a target="_blank" rel="noopener" href="http://blog.51cto.com/12331508/2315352?source=dra">Kubernetes 1.12.2 版，使用 docker 镜像安装</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jinguangliu/article/details/82792617">Kubernetes：如何解决从 k8s.gcr.io 拉取镜像失败问题</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/cloumn/detail/87">Kubernetes: 21 天完美通关</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/396450">k8s之pod的创建流程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/6766.html">图解kubernetes Pod创建流程大揭秘</a></p>
</blockquote>

  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Kubernetes/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>Kubernetes</p></a></div>
  <span hidden itemprop="keywords">Kubernetes</span>


        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2018/Docker-Compose/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>Docker Compose</p>
          <p class='content'>环境：docker：18.06.1，docker-compose：1.22.0
docker18.06 对应的 Compose 文件格式版本为 3.7
本篇包含以下内容：

docker-com...</p>
        </a>
      
      
        <a class='next' href='/2018/Docker%E5%AD%98%E5%82%A8/'>
          <p class='title'>Docker存储<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>主要是对 docker 文档(v18.03)的翻译以及自己的学习笔记本篇主要包含以下内容

Docker 存储介绍
BindMount
bind-propagation 传播挂载
Selinux...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>




</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Kubernetes-%E6%A6%82%E8%BF%B0"><span class="toc-text">Kubernetes 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s-%E7%BB%93%E6%9E%84%E4%B8%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">k8s 结构与组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s-%E5%9F%BA%E7%A1%80%E5%AF%B9%E8%B1%A1"><span class="toc-text">k8s 基础对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod"><span class="toc-text">Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Pause%E5%AE%B9%E5%99%A8"><span class="toc-text">Pause容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod%E7%B1%BB%E5%9E%8B"><span class="toc-text">pod类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Label"><span class="toc-text">Label</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication-Controller"><span class="toc-text">Replication Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment"><span class="toc-text">Deployment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StatefulSet"><span class="toc-text">StatefulSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service"><span class="toc-text">Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Job"><span class="toc-text">Job</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Volume"><span class="toc-text">Volume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Persistent-Volume"><span class="toc-text">Persistent Volume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespace"><span class="toc-text">Namespace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Autonation"><span class="toc-text">Autonation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigMap"><span class="toc-text">ConfigMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#k8s-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7"><span class="toc-text">k8s 如何进行版本升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K8s-%E5%BC%80%E6%94%BE%E6%8E%A5%E5%8F%A3"><span class="toc-text">K8s 开放接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CRI"><span class="toc-text">CRI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CNI"><span class="toc-text">CNI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSI"><span class="toc-text">CSI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#k8s-%E9%83%A8%E7%BD%B2%E8%A6%81%E7%82%B9"><span class="toc-text">k8s 部署要点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8ipvs%E6%A8%A1%E5%BC%8F"><span class="toc-text">配置使用ipvs模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEdocker%E7%9A%84cgroup-driver"><span class="toc-text">设置docker的cgroup driver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kubectl-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">Kubectl 常用操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K8s-%E9%9B%86%E7%BE%A4%E5%AE%89%E5%85%A8"><span class="toc-text">K8s 集群安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Pod"><span class="toc-text">深入理解 Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-text">Pod创建流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81-Pod"><span class="toc-text">静态 Pod</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-text">Pod 配置管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%86%85%E8%8E%B7%E5%8F%96-Pod-%E4%BF%A1%E6%81%AF"><span class="toc-text">在容器内获取 Pod 信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc-text">Pod 生命周期与重启策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-text">Pod 健康检查和服务可用性检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E8%B0%83%E5%BA%A6"><span class="toc-text">Pod 调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment-%E4%B8%8E-RepliaSet"><span class="toc-text">Deployment 与 RepliaSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NodeSelector"><span class="toc-text">NodeSelector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NodeAffinity"><span class="toc-text">NodeAffinity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PodAffinity"><span class="toc-text">PodAffinity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Taints-%E4%B8%8E-Tolerations"><span class="toc-text">Taints 与 Tolerations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pod-Priority-Preemption"><span class="toc-text">Pod Priority Preemption</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DaemonSet"><span class="toc-text">DaemonSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Job-1"><span class="toc-text">Job</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cronjob"><span class="toc-text">Cronjob</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8-Init-Container"><span class="toc-text">初始化容器 Init Container</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB-Runtime-Class"><span class="toc-text">容器运行时类 Runtime Class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90-Container-Lifecycle-Hooks"><span class="toc-text">容器生命周期钩子 Container Lifecycle Hooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%9B%9E%E6%BB%9A"><span class="toc-text">Pod 升级与回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment-%E5%8D%87%E7%BA%A7"><span class="toc-text">Deployment 升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-text">更新策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deployment-%E5%9B%9E%E6%BB%9A"><span class="toc-text">Deployment 回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RC-%E6%BB%9A%E5%8A%A8%E5%8D%87%E7%BA%A7"><span class="toc-text">RC 滚动升级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pod-%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-text">Pod 扩缩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-text">手动扩缩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#K8s%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9"><span class="toc-text">K8s弹性伸缩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HPA"><span class="toc-text">HPA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Service"><span class="toc-text">深入理解 Service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1-Service"><span class="toc-text">外部服务 Service</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Headless-Service"><span class="toc-text">Headless Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Service-%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE-Pod"><span class="toc-text">通过 Service 动态查找 Pod</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E9%9B%86%E7%BE%A4%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE-Pod-%E5%92%8C-Service"><span class="toc-text">从集群外部访问 Pod 和 Service</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-text">核心组件运行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#API-Server"><span class="toc-text">API-Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Controller-Manager"><span class="toc-text">Controller Manager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Replication-Controller-1"><span class="toc-text">Replication Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-Controller"><span class="toc-text">Node Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceQuota-Controller"><span class="toc-text">ResourceQuota Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Namespace-Controller"><span class="toc-text">Namespace Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Controller-%E5%92%8C-Endpoints-Controller"><span class="toc-text">Service Controller 和 Endpoints Controller</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Scheduler"><span class="toc-text">Scheduler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubelet"><span class="toc-text">kubelet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pod%E7%AE%A1%E7%90%86"><span class="toc-text">pod管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cAdvisor%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7"><span class="toc-text">cAdvisor资源监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kube-proxy"><span class="toc-text">kube-proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#iptables%E6%A8%A1%E5%BC%8F"><span class="toc-text">iptables模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipvs%E6%A8%A1%E5%BC%8F"><span class="toc-text">ipvs模式</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.add("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="none";
      cover_wrapper.style.display="none";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="https://github.com/serchaofan"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <div><p>博客内容遵循 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>






<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->



<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>









      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"}},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"Tianyi的技术随笔","url":"https://tianyigu.top/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"Tianyi Gu","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://tianyigu.top/","sameAs":["https://github.com/volantis-x"],"description":"Tianyi的技术随笔"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"https://tianyigu.top/","name":"Tianyi的技术随笔"}},{"@type":"ListItem","position":2,"item":{"@id":"https://tianyigu.top/categories/Kubernetes/","name":"Kubernetes"}},{"@type":"ListItem","position":3,"item":{"@id":"https://tianyigu.top/2018/Kubernetes/","name":"Kubernetes"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"Tianyi的技术随笔","url":"https://tianyigu.top/","description":"Tianyi的技术随笔","author":{"@type":"Person","name":"Tianyi Gu","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://tianyigu.top/","description":"Tianyi的技术随笔"},"publisher":{"@type":"Organization","name":"Tianyi的技术随笔","url":"https://tianyigu.top/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"https://tianyigu.top?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"Kubernetes","description":"Tianyi的技术随笔","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https://tianyigu.top/2018/Kubernetes/"},"author":{"@type":"Person","name":"Tianyi Gu","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"https://tianyigu.top/"},"publisher":{"@type":"Organization","name":"Tianyi的技术随笔","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"https://tianyigu.top/2018/Kubernetes/","wordCount":0,"datePublished":"2018-07-13T12:33:37.000Z","dateModified":"2023-04-20T18:13:43.297Z","articleSection":"Kubernetes","keywords":"Kubernetes","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
  </body>
</html>
