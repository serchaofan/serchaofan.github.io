---
title: Zookeeper
tags: [zookeeper]
categories: []
date: 2020-02-29 18:51:48
comments: false
---

<!-- more -->

# 概述
ZooKeeper是分布式应用的调度服务，通过一组简单的原语，分布式应用程序可以在这些原语的基础上实现更高级别的同步、配置维护、分组以及命名。ZooKeeper被设计为易于编程，并使用一种数据模型，该模型使用文件系统目录树结构。ZooKeeper在Java环境中运行。

## zookeeper的设计目的
- ZooKeeper允许分布式进程通过**共享的分层命名空间**（hierarchical namespace）相互协同调度，该命名空间的组织方式**类似于标准文件系统**。命名空间由数据寄存器组成，称为 **znodes**，类似于文件和目录。与为存储而设计的典型文件系统不同，ZooKeeper的**数据保存在内存中**，这意味着 ZooKeeper 可以实现高吞吐量和低延迟。ZooKeeper的实现非常重视高性能、高可用性、严格有序的访问。ZooKeeper的高性能意味着它**可以用于大型分布式系统**，高可靠性使其**不会出现单点故障**，严格的排序意味着**可以在客户端实现复杂的同步原语**。
- 与它协调的分布式进程一样，ZooKeeper本身旨在通过一组主机进行横向扩展。组成 ZooKeeper集群的服务器必须相互通信，**这些服务器在内存中维护集群状态，以及持久存储中的事务日志和快照。只要大多数服务器可用，ZooKeeper 服务就可用**。 客户端只需连接到单个 ZooKeeper 服务器，并且客户端会维护一个 TCP 连接，通过它发送请求、获取响应、获取监视事件并发送心跳，如果与服务器的 TCP 连接中断，客户端将连接到不同的服务器。
  ![](https://cdn.jsdelivr.net/gh/serchaofan/picBed/blog/202206301215404.png)
- ZooKeeper **使用数字标记每个更新，通过数字反映所有 ZooKeeper 事务的顺序**。后续操作可以使用该顺序来实现更高级别的抽象，例如同步原语。
- ZooKeeper 在**以读取为主（read-dominant）的工作负载中特别快**。ZooKeeper 应用程序能在数千台机器上运行，并且它在读比写多的情况下表现最佳。

## 数据类型与分层命名空间
命名空间的组织方式类似于标准文件系统。**名称是由斜杠 (/) 分隔的一系列路径，命名空间中的每个节点都由路径标识**。
![](https://cdn.jsdelivr.net/gh/serchaofan/picBed/blog/202206301236488.png)

## 节点与临时节点
与标准文件系统不同，ZooKeeper 命名空间中的每个节点都可以拥有与其关联的数据以及子节点，就像一个允许文件也成为目录的文件系统，原因是ZooKeeper 被设计用于存储协调数据，如状态信息、配置、位置信息等，因此每个节点存储的数据通常很小，在字节到千字节的范围内。ZooKeeper 数据节点称为znode。

Znode 维护一个统计结构，其中包括了**数据更改、ACL变更和时间戳**的版本号，以允许缓存验证和协调更新。每次 znode 的数据更改时，版本号都会增加。例如，每当客户端检索数据时，它也会收到数据的版本。

存储在命名空间中每个 znode 的数据是**原子读取和写入**的。读取会获取与 znode 关联的所有数据字节，写入会替换所有数据。

每个节点都有一个访问控制列表 (ACL)，它限制谁可以做什么。

ZooKeeper 也有临时节点（ephemeral nodes）的概念，只要创建 znode 的会话处于活动状态，这些 znode 就存在。当会话结束时，znode 被删除。

## 有条件的更新和监视
ZooKeeper支持 watch，客户端可以在 znode 上设置监视。当 znode 发生变化时，watch 将被触发并移除。当 watch 被触发时，客户端会收到一个数据包告知 znode 已更改。如果客户端和其中一个 ZooKeeper 服务器之间的连接断开，客户端将收到本地通知（local notification）。

## 保证Guarantees
由于ZooKeeper的目标是成为构建更复杂服务（例如同步）的基础，因此它提供了一组保证，如下：
- 顺序一致性（Sequential Consistency）：来自客户端的更新将按照它们发送的顺序进行应用。
- 原子性（Atomicity）：更新要么成功，要么失败，没有中间状态的结果。
- 单一系统映像（Single System Image）：客户端都将看到相同的服务视图，不管它连接到的服务器是什么，也就是说，即使客户端故障转移到具有相同会话的不同服务器，客户端也永远不会看到系统的旧视图。
- 可靠性（Reliability）：当更新被应用后，它将从那时起持续存在，直到客户端覆盖更新。
- 及时性（Timeliness）：系统的客户端视图能保证在一定的时间范围内是最新的。

## 提供接口
ZooKeeper 提供非常简单的编程接口，仅支持以下操作：
- create：在树中的某个位置创建一个节点
- delete：删除一个节点
- exists：测试节点是否存在于某个位置
- get data：从节点读取数据
- set data：将数据写入节点
- get children：检索节点的子节点列表
- sync：等待数据传播

## 实现
如下图，运行 ZooKeeper 的每个服务器都会复制自己的每个组件的副本（除了请求处理器（Request Processor））。
![](https://cdn.jsdelivr.net/gh/serchaofan/picBed/blog/202206301350235.png)

复制数据库（Replicated Database）是包含整个数据树的内存数据库。更新的数据会被记录到磁盘以便恢复，写入的数据在被应用到内存数据库之前会被先序列化到磁盘。

每个 ZooKeeper 服务器都服务于客户端，客户端仅连接到一台服务器以提交请求。每个服务器数据库的本地副本会为读取请求提供服务，而改变服务状态的请求以及写请求是由一致性协议（agreement protocol）处理。

作为一致性协议的一部分，来自客户端的所有写入请求都会被转发到一台服务器，称为领导者（Leader）。其余 ZooKeeper 服务器，称为追随者（followers），会接收来自领导者的消息申请并同意消息传递。消息传递层（messaging layer）负责在失败时替换领导者并将追随者与领导者同步。

ZooKeeper 使用自定义的原子消息传递协议（即Atomic Broadcast）。由于消息传递层具有原子性，因此 ZooKeeper 可以保证本地副本永远不会存在分歧。当领导者收到一个写请求时，它会计算系统在执行写请求时的状态，并将其转换为捕获这个新状态的事务。

## Zookeeper内部
ZooKeeper 的核心是一个原子消息系统，它使所有服务器保持同步。

Zookeeper 会在消息系统中使用以下特定保证（Guarantees）：
- 可靠传递（Reliable delivery）：如果某条消息被一个服务器传递了，最终这条消息会被所有服务器都传递一遍。
- 全序（Total order）：如果一条消息A在另一条消息B之前被一台服务器传递，则这条消息A会在B之前被所有服务器传递，如果A和B都是被传递的消息，则要么A在B前被传递，要么B在A前被传递。
- 因果序（Causal order）：如果消息B的发送方发送了消息A后又发送了B消息，则A必须被排在B之前。如果发送方在发送消息B之后发送了消息C，则C必须排在B之后。

原子消息系统的协议依赖于TCP的以下属性：
- 有序传递（Ordered delivery）：数据的下发顺序与消息的下发顺序相同，消息M只有在消息M之前发送的所有消息都被下发后才会下发。(由此得出的推论是，如果消息M丢失，那么M之后的所有消息都将丢失。)
- 关闭后不再有消息（No message after close）：一旦FIFO（First-In First-Out 先进先出）通道关闭，就不会收到来自它的消息。

FLP证明，在可能发生故障的异步分布式系统中，共识是无法实现的。为了确保在出现故障时达成共识，我们使用了超时。然而，我们依靠时间来生存，而不是正确。因此，如果超时停止工作(例如时钟故障)，消息传递系统可能会挂起，但不会违反其保证。

当描述ZooKeeper消息协议时，我们将讨论报文、提议和消息:将通过FIFO通道发送的字节序列分组，提议一个协议单元。通过与ZooKeeper服务器的quorum组交换报文来达成协议。大多数提案包含消息，但是NEW LEADER提案是不对应于消息的提案的一个例子。消息一个字节序列将被原子地广播到所有ZooKeeper服务器。提案:放在提案中并在提交之前达成一致的信息