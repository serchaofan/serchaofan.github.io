---
title: I/O学习笔记
date: 2018-04-29 09:26:12
tags: [网络,I/O]
---
## I/O
本篇包含以下知识点：
* 同、异步概念
* 五种Unix I/O模型
  * 同步模型
  * 异步模型

<!-- more -->

### 同、异步
**同步：** 指的是在两个或多个数据库、文件、模块、线程之间用来保持数据内容一致性的机制。<br>
同步处理过程：提交请求->等待服务器处理（期间客户端浏览器不能干任何事）->处理完毕返回<br>
**异步：** 异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。<br>
异步处理过程：请求通过事件触发->服务器处理（这是浏览器仍然可以作其他事情）->处理完毕
> 同步、异步关注的是消息通知机制，针对的是客户端。

**阻塞与非阻塞**<br>
阻塞：调用结果返回之前，调用者会被挂起（不可中断），调用者只有在得到返回结果后才能继续。
非阻塞：调用结果返回前，不会被挂起，调用不会阻塞调用者。在内核的数据还未准备好时，会立即返回，进程可以去干其他事情。
> 阻塞、非阻塞关注的是调用者等待被调用者返回结果时的状态，针对的是服务器端。

**阻塞、非阻塞与同步、异步的区别**<br>
**同步是在I/O中的一系列操作都是调用者（用户进程）自己完成（自己去问内核）。而异步是调用者在发起调用后，自己不管了，等内核数据准备好了以后，内核自己告诉进程，即让内核去通知进程，实现回调。** <br>
**至于阻塞与非阻塞，是决定是否让调用者挂起。**

网络I/O的本质是socket的读取，socket在linux系统被抽象为流，I/O可以理解为对流的操作。这个操作又分为两个阶段：

    1.等待流数据准备，即等待网络上的数据分组到达，然后被复制到内核的某个缓冲区
    2.从内核向进程复制数据，把数据从内核缓冲区复制到应用进程缓冲区


### 五种Unix I/O模型
**I/O模型：**
进程是无法直接操作I/O设备的，其必须通过系统调用请求内核来协助完成I/O动作，而内核会为每个I/O设备维护一个buffer。 用户进程发起请求，内核接受到请求后，从I/O设备中获取数据到buffer中，再将buffer中的数据copy到用户进程的地址空间，该用户进程获取到数据后再响应客户端。
如下图中，真正称为I/O的就是**内核内存与与进程内存间的过程**<br>
{% asset_img iomoxing.bmp iomoxing %}

#### 同步I/O模型
**阻塞I/O（Blocking I/O）：** 当用户进程进行系统调用read()时，进程发起recvform系统调用，内核就开始了I/O的第一个阶段，准备数据到缓冲区中，当数据都准备完成后，则将数据从内核缓冲区中拷贝到用户进程的内存中，这时用户进程才解除block的状态重新运行。整个过程中用户进程都是阻塞的。不会消耗CPU时间，执行效率高。<br>
{% asset_img zuseio.jpg zuseio %}

**非阻塞I/O（Non-Blocking I/O）：** 用户进程只有在第二个阶段被阻塞了，而第一个阶段没有阻塞。在第一个阶段中，recvform系统调用调用之后，内核马上返回给进程，如果数据还没准备好，此时会返回一个error，进程在返回之后，可以干点别的事情，然后再发起recvform系统调用，用户进程需要盲等，不停的去轮询内核，看数据是否准备好了。在拷贝数据整个过程，进程仍然是属于阻塞的状态。由于用户进程轮询内核，所以该模型是比较消耗CPU的，效率较低。<br>
{% asset_img feizuseio.jpg feizuseio %}

** I/O复用（I/O Multiplexing）：** I/O执行的两个阶段都是用户进程都是阻塞的，但是两个阶段是独立的，在一次完整的I/O操作中，该用户进程是发起了两次系统调用。使用select()、poll()或epoll()（poll的改进版）进行调用，可支持两路调用。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。
> select调用是内核级别的，select轮询可以等待多个socket，当其中任何一个socket的数据准备好了（通过内核监视），就能返回进行可读，然后进程再进行recvform系统调用。select在此模式下最多只支持1024个并发。

{% asset_img iofuyong.jpg iofuyong %}

**I/O复用应用场景：** <br>
* 服务器需要同时处理多个处于监听状态或多个连接状态的套接字。
* 服务器需要同时处理多种网络协议的套接字。

**信号驱动I/O（Signal Driven I/O）：** 也称基于事件的I/O。只有在I/O执行的第二阶段阻塞了用户进程，而在第一阶段是没有阻塞的。在I/O执行的第一阶段，当数据准备完成之后，内核会主动的通知用户进程数据已经准备完成（通过返回一个SIGIO信号），即对用户进程做一个回调。该通知分为两种，一为水平触发，即如果用户进程不响应则会一直发送通知，二为边缘触发，即只通知一次。
> 注：需要先开启套接字的信号驱动I/O功能，并使系统调用sigaction安装一个信号处理函数

{% asset_img xinxiqudongio.jpg xinxiqudongio %}

#### 异步I/O模型
**异步I/O（Asynchrnous I/O）：** 当用户进程发起系统调用后，立刻就可以开始去做其它的事情，然后直到I/O执行的两个阶段都完成之后，内核会给用户进程发送通知，告诉用户进程操作已经完成了。由于在调用后进程会立刻返回，所以在整个输入操作的等待和复制期间，进程都不会阻塞。
> 异步I/O不需要select或poll 主动询问，也没有询问描述符的数量限制。

{% asset_img yibuio.jpg yibuio %}

<br><br><br>

> 参考文章：
简明网络I/O模型---同步异步阻塞非阻塞之惑 https://www.jianshu.com/p/55eb83d60ab1
浅谈Linux下的五种I/O模型 https://www.cnblogs.com/chy2055/p/5220793.html
Linux 网络 I/O 模型简介（图文） https://blog.csdn.net/anxpp/article/details/51503329
socket 和 网络I/O模型 https://www.jianshu.com/p/7ac69db65a0e